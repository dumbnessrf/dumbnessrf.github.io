[{"content":"CalcBinding 是一个 WPF 第三方绑定增强库，它允许你在 XAML 中使用表达式进行数据绑定计算，而无需在 ViewModel 中写额外的属性或转换器（Converter）。\u0026ndash;它非常适合用于简单的数学运算、字符串拼接、条件判断等场景。\n📦 一、简介 GitHub 地址：https://github.com/Alex198711/CalcBinding 功能：支持类似 {calcBinding Path=Width*2+Height} 的表达式绑定 不依赖 IValueConverter 支持多绑定、条件语句、函数调用等 🧩 二、安装方式 你可以通过 NuGet 安装：\n1 Install-Package CalcBinding 然后在 XAML 中添加命名空间引用：\n1 xmlns:calc=\u0026#34;clr-namespace:CalcBinding;assembly=CalcBinding\u0026#34; 📘 三、常见用法与示例 ✅ 示例 1：基本数学运算 1 \u0026lt;TextBlock Text=\u0026#34;{calc:Binding Path=Width * 2 + Height}\u0026#34; /\u0026gt; 将 Width 乘以 2 再加上 Height，结果作为 TextBlock.Text\n✅ 示例 2：字符串拼接 1 \u0026lt;TextBlock Text=\u0026#34;{calc:Binding Path=FirstName + \u0026#39; \u0026#39; + LastName}\u0026#34; /\u0026gt; 把两个字段拼接成完整姓名\n✅ 示例 3：布尔值转可见性（Visibility） 1 2 \u0026lt;Button Content=\u0026#34;Submit\u0026#34; Visibility=\u0026#34;{calc:Binding Path=IsEnabled ? Visible : Collapsed}\u0026#34; /\u0026gt; 使用三元运算符实现 Visibility 控制，无需 Converter\n✅ 示例 4：绑定多个属性并做计算 1 \u0026lt;TextBlock Text=\u0026#34;{calc:MultiBinding Path1=Value1, Path2=Value2, Expression=Path1 + Path2}\u0026#34; /\u0026gt; 多绑定支持最多 5 个路径（Path1~Path5），可以组合任意表达式\n✅ 示例 5：使用 Math 函数（如 Max、Min、Round） 1 \u0026lt;TextBlock Text=\u0026#34;{calc:Binding Path=Math.Max(Width, Height)}\u0026#34; /\u0026gt; 显示 Width 和 Height 中较大的那个\n支持的函数包括：\nMath.Abs Math.Round Math.Min Math.Max Math.Ceiling Math.Floor Math.Pow(x, y) Math.Sqrt(x) ✅ 示例 6：条件判断结合绑定 1 \u0026lt;TextBlock Text=\u0026#34;{calc:Binding Path=Value \u0026gt; 0 ? Value : 0}\u0026#34; /\u0026gt; 如果 Value 大于 0，则显示 Value，否则显示 0\n✅ 示例 7：绑定集合元素 1 \u0026lt;TextBlock Text=\u0026#34;{calc:Binding Path=Items[0].Price * Items[0].Quantity}\u0026#34; /\u0026gt; 绑定集合中第一个元素的属性并进行计算\n✅ 示例 8：绑定资源中的静态值 1 2 3 4 5 \u0026lt;Window.Resources\u0026gt; \u0026lt;sys:Double x:Key=\u0026#34;ScaleFactor\u0026#34;\u0026gt;1.5\u0026lt;/sys:Double\u0026gt; \u0026lt;/Window.Resources\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{calc:Binding Path=Width * {StaticResource ScaleFactor}}\u0026#34; /\u0026gt; 可以在表达式中嵌入静态资源\n✅ 示例 9：使用方法调用（需要注册） 你可以在代码中注册自定义函数，例如：\n1 CalcBindingHelper.RegisterFunction(\u0026#34;Format\u0026#34;, (string format, object arg) =\u0026gt; string.Format(format, arg)); 然后在 XAML 中使用：\n1 \u0026lt;TextBlock Text=\u0026#34;{calc:Binding Path=Format(\u0026#39;{0:C}\u0026#39;, Price)}\u0026#34; /\u0026gt; 类似格式化货币输出，替代 StringFormat\n✅ 示例 10：绑定依赖属性（如控件尺寸） 1 2 3 4 5 \u0026lt;Canvas\u0026gt; \u0026lt;Ellipse Width=\u0026#34;50\u0026#34; Height=\u0026#34;50\u0026#34; Canvas.Left=\u0026#34;{calc:Binding ElementName=canvas, Path=ActualWidth / 2 - 25}\u0026#34; Canvas.Top=\u0026#34;{calc:Binding ElementName=canvas, Path=ActualHeight / 2 - 25}\u0026#34; /\u0026gt; \u0026lt;/Canvas\u0026gt; 计算控件居中位置，不需要在后台代码中设置布局逻辑\n🧪 四、性能与注意事项 注意点 说明 表达式复杂度 避免过于复杂的嵌套表达式，影响可读性和调试 调试困难 表达式错误不会抛出异常，只会显示为空或默认值 性能 相比普通绑定稍慢，但对 UI 影响不大 兼容性 支持 WPF，不支持 UWP 或 .NET MAUI 🎯 五、适合使用的场景 简单的数学计算绑定 字符串拼接 条件控制（Visible/Collapsed） 布局调整（基于控件大小） 替代简单 Converter 的场景 🧩 六、替代方案对比 方案 优点 缺点 CalcBinding 快速编写表达式，无需 Converter 不易调试，不适合复杂逻辑 IValueConverter 更强类型安全和逻辑控制 需要编写额外类 MultiBinding + IMultiValueConverter 支持多值绑定 实现繁琐 XAML Binding.StringFormat 简单格式化 不支持表达式计算 ","date":"2025-06-06T14:46:48+08:00","image":"https://www.notion.so/images/page-cover/rijksmuseum_mignons_1660.jpg","permalink":"https://dumbnessrf.github.io/p/calcbinding/","title":"WPF技巧-XAML中使用表达式进行数据绑定计算"},{"content":"什么是依赖注入（Dependency Injection） 📌 概念 依赖注入（Dependency Injection，简称 DI）是一种常见的软件设计模式，主要用于解耦组件之间的依赖关系，提高代码的可维护性和可测试性。\n在 C# 开发中，如果不使用依赖注入，类 A 可能会在内部直接实例化类 B，导致两个类之间形成强耦合。而通过依赖注入的方式，可以将类 B 的实例从外部传递给类 A（通常通过构造函数、属性或方法参数），从而实现松耦合的设计。\n✅ 主要作用 提升可维护性\n当系统规模变大时，如果各个组件之间紧密耦合，修改一个组件可能会引发连锁反应。通过依赖注入，可以使依赖关系更加清晰明了，便于后期维护。\n简化单元测试\n在编写单元测试时，可以轻松地模拟（Mock）依赖对象，而不是依赖真实的复杂对象，使测试更简单、更精准。\n🛠 常用依赖注入框架及示例 1. Microsoft.Extensions.DependencyInjection 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 using Microsoft.Extensions.DependencyInjection; class MyClassA { private readonly MyClassB _dependency; public MyClassA(MyClassB dependency) =\u0026gt; _dependency = dependency; public void DoSomething() =\u0026gt; _dependency.SomeMethod(); } class MyClassB { public void SomeMethod() =\u0026gt; Console.WriteLine(\u0026#34;MyClassB\u0026#39;s method is called.\u0026#34;); } class Program { static void Main() { var serviceCollection = new ServiceCollection(); serviceCollection.AddTransient\u0026lt;MyClassB\u0026gt;(); serviceCollection.AddTransient\u0026lt;MyClassA\u0026gt;(); var serviceProvider = serviceCollection.BuildServiceProvider(); var a = serviceProvider.GetService\u0026lt;MyClassA\u0026gt;(); a.DoSomething(); } } 2. Autofac 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 using Autofac; class MyClassA { private readonly MyClassB _dependency; public MyClassA(MyClassB dependency) =\u0026gt; _dependency = dependency; public void DoSomething() =\u0026gt; _dependency.SomeMethod(); } class MyClassB { public void SomeMethod() =\u0026gt; Console.WriteLine(\u0026#34;MyClassB\u0026#39;s method is called.\u0026#34;); } class Program { static void Main() { var builder = new ContainerBuilder(); builder.RegisterType\u0026lt;MyClassB\u0026gt;().AsSelf(); builder.RegisterType\u0026lt;MyClassA\u0026gt;().AsSelf(); var container = builder.Build(); var a = container.Resolve\u0026lt;MyClassA\u0026gt;(); a.DoSomething(); } } 什么是动态加载程序集（Dynamic Assembly Loading） 📌 定义 在 C# 中，动态加载程序集允许程序在运行时加载并使用 DLL 文件，而不是在编译时静态引用它们。这种方式提供了更高的灵活性，例如：\n根据不同的条件或用户需求加载不同的功能模块。 在程序运行过程中更新某些功能模块，而无需重新编译整个项目。 🧪 示例：动态加载 DLL 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 using System.Reflection; class Program { static void Main() { // 加载程序集 Assembly assembly = Assembly.Load(\u0026#34;xxx.dll\u0026#34;); // 获取类型 Type type = assembly.GetType(\u0026#34;MyNamespace.MyClass\u0026#34;); // 创建实例 object instance = Activator.CreateInstance(type); // 调用方法 MethodInfo method = type.GetMethod(\u0026#34;DoSomething\u0026#34;); method.Invoke(instance, null); } } ⚠️ 注意：使用 Assembly.Load(\u0026quot;xxx.dll\u0026quot;) 加载的程序集会一直占用该 DLL 文件。若需要卸载或更新 DLL，建议使用如下方式：\n1 2 byte[] rawAssembly = File.ReadAllBytes(dllPath); Assembly assembly = Assembly.Load(rawAssembly); 🔄 将动态加载的 DLL 注入到依赖容器中（以 Autofac 为例） 我们以 Autofac 作为依赖注入容器，演示如何对动态加载的 DLL 进行服务注册与解析。\n步骤 1：加载程序集 1 2 byte[] rawAssembly = File.ReadAllBytes(dllPath); Assembly assembly = Assembly.Load(rawAssembly); 步骤 2：定义注入特性（Attribute） 为了筛选需要注册的服务类型，我们可以自定义一个 [Inject] 特性：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)] public class InjectAttribute(string name, string category) : Attribute { public string Name { get; } = name; public string Category { get; } = category; } public interface ITool { void DoWork(); void ShowDialog(); } // 示例类 [Inject(\u0026#34;工具2\u0026#34;, \u0026#34;类别1\u0026#34;)] public class MainFrame : ITool { public void DoWork() { /* 实现逻辑 */ } public void ShowDialog() { /* 实现逻辑 */ } } 步骤 3：注册服务到 Autofac 容器 1 2 3 4 5 6 7 8 9 10 11 12 13 var builder = new ContainerBuilder(); var types = assembly.DefinedTypes.ToList().Where(IsToolType).ToList(); foreach (var type in types) { var attr = type.CustomAttributes.First(a =\u0026gt; a.AttributeType == typeof(InjectAttribute)); var name = attr.ConstructorArguments[0].Value?.ToString(); var category = attr.ConstructorArguments[1].Value?.ToString(); string key = $\u0026#34;{category}_{name}\u0026#34;; builder.RegisterType(type).Named\u0026lt;ITool\u0026gt;(key); } 步骤 4：构建容器并解析服务 1 2 3 4 5 6 7 8 9 10 var container = builder.Build(); var tool1 = container.ResolveNamed\u0026lt;ITool\u0026gt;(\u0026#34;类别1_工具1\u0026#34;); tool1.DoWork(); var tool2 = container.ResolveNamed\u0026lt;ITool\u0026gt;(\u0026#34;类别1_工具2\u0026#34;); tool2.ShowDialog(); var tool3 = container.ResolveNamed\u0026lt;ITool\u0026gt;(\u0026#34;类别2_工具1\u0026#34;); tool3.ShowDialog(); 🧩 依赖自动解析能力 当被注入的类型存在其他依赖项时，如日志 (ILogger) 或数据库 (IDatabase) 接口，依赖注入容器会自动完成这些依赖的解析。\n1 2 3 4 5 6 7 8 9 10 public interface ILogger { void Log(string message); } public interface IDatabase { List\u0026lt;string\u0026gt; Select(); void Insert\u0026lt;T\u0026gt;(T entity); } 示例：单例注入 1 2 builder.RegisterType\u0026lt;ConsoleLogger\u0026gt;().SingleInstance().As\u0026lt;ILogger\u0026gt;(); builder.RegisterType\u0026lt;MysqlMocker\u0026gt;().SingleInstance().As\u0026lt;IDatabase\u0026gt;(); 使用示例类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 [Inject(\u0026#34;工具1\u0026#34;, \u0026#34;类别1\u0026#34;)] public class Tool1 : ITool { private readonly ILogger _logger; private readonly IDatabase _database; public Tool1(ILogger logger, IDatabase database) { _logger = logger; _database = database; } public void DoWork() { _logger.Log(\u0026#34;This is a log message from Tool1\u0026#34;); _logger.Log(\u0026#34;Doing work in MainFrame\u0026#34;); var data = _database.Select(); var str = JsonConvert.SerializeObject(data); _logger.Log($\u0026#34;Data from database: {str}\u0026#34;); } public void ShowDialog() { } } ✅ 总结 功能 描述 依赖注入 解耦组件，提升可维护性和可测试性 动态加载 灵活加载 DLL，支持热插拔和运行时扩展 结合使用 可以将动态加载的 DLL 类型注册为服务，并由 DI 容器管理其生命周期和依赖关系 通过上述方式，你可以实现一个高度模块化、易于扩展和维护的 C# 应用架构，适用于插件式系统、微服务架构等场景。\n","date":"2025-06-04T14:04:44+08:00","image":"https://www.notion.so/images/page-cover/met_william_morris_1877_willow.jpg","permalink":"https://dumbnessrf.github.io/p/dependency_injection_with_dynamic_loaded_dll.md/","title":"C#对动态加载的DLL依赖注入"},{"content":"🧩 Avalonia 框架概览 🔍 简介 Avalonia 是一个 跨平台的 .NET 用户界面框架，支持使用 C# 和 XAML 构建桌面、移动和 Web 应用程序。其设计灵感来源于 WPF 和 UWP，但具有更强的跨平台兼容性。\n✅ 主要特点： 使用熟悉的 XAML 语法 支持多种 UI 控件和样式 可运行于多个操作系统 支持 MVVM 模式及依赖注入 🌐 平台支持 Avalonia 支持以下平台：\n平台 支持情况 Windows 完全支持 Linux 完全支持 macOS 完全支持 Android/iOS 实验性支持（需额外适配） WebAssembly 支持（通过 WASM 渲染器） 💡 Avalonia 提供了真正的跨平台开发能力，适用于需要统一多端体验的应用场景。\n⚙️ 性能表现 Avalonia 的渲染引擎经过优化，具备高效的绘制能力和良好的硬件加速支持，尤其在处理复杂图形与数据可视化时表现出色。\n高效的渲染管道 支持 GPU 加速 低延迟响应用户交互 例如：当应用中存在大量动态图表或动画元素时，Avalonia 能保持流畅的帧率，避免卡顿现象。\n🔄 Microsoft.Extensions.DependencyInjection 详解 📦 概述 Microsoft.Extensions.DependencyInjection 是 .NET 中的一个 轻量级依赖注入（DI）容器，它提供了一种灵活的方式来管理应用程序中的对象及其依赖关系。\n💡 为什么使用 DI？ 解耦业务逻辑与具体实现 提高代码可测试性和可维护性 支持模块化开发 🕒 服务生命周期（Service Lifecycle） 生命周期类型 描述 Transient（瞬态） 每次请求都会创建新实例，适合无状态服务 Scoped（作用域） 同一作用域内共享同一个实例，常用于 Web 请求上下文 Singleton（单例） 整个应用程序周期内共享唯一实例，适合全局资源管理 示例说明： Transient：每次调用 IDataProcessor 都会返回一个新的实例。 Scoped：在一次 HTTP 请求中，所有对 IDatabaseContext 的请求都返回同一个实例。 Singleton：如 IAppSettings，在整个应用程序中始终为同一实例。 🧪 示例：在 Avalonia 中集成依赖注入 📝以下示例将添加Redis和第三方Avalonia样式库SukiUI作为参考\n1️⃣ 安装依赖注入包 1 install-package Microsoft.Extensions.DependencyInjection 2️⃣ 初始化服务容器 在 App.xaml.cs 中重写 OnFrameworkInitializationCompleted() 方法以注册并构建服务容器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public override void OnFrameworkInitializationCompleted() { var collection = new ServiceCollection(); collection.AddCommonServices(); collection.AddDistributedCache(); _services = collection.BuildServiceProvider(); var vm = _services.GetRequiredService\u0026lt;MainWindowViewModel\u0026gt;(); var toastService = _services.GetRequiredService\u0026lt;ISukiToastManager\u0026gt;(); var dialogService = _services.GetRequiredService\u0026lt;ISukiDialogManager\u0026gt;(); if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop) { desktop.MainWindow = _services.GetRequiredService\u0026lt;MainWindow\u0026gt;(); } else if (ApplicationLifetime is ISingleViewApplicationLifetime singleViewPlatform) { singleViewPlatform.MainView = new MainWindow(toastService, dialogService) { DataContext = vm, }; } base.OnFrameworkInitializationCompleted(); } 3️⃣ 注册服务 自定义扩展方法注册常用服务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static void AddCommonServices(this IServiceCollection collection) { collection.AddSingleton\u0026lt;MainWindowViewModel\u0026gt;(); collection.AddSingleton\u0026lt;MainWindow\u0026gt;(s =\u0026gt; new MainWindow( s.GetRequiredService\u0026lt;ISukiToastManager\u0026gt;(), s.GetRequiredService\u0026lt;ISukiDialogManager\u0026gt;() ) { DataContext = s.GetRequiredService\u0026lt;MainWindowViewModel\u0026gt;(), }); collection.AddSingleton\u0026lt;ISukiToastManager\u0026gt;(s =\u0026gt; DialogExManager.GetToastManager()); collection.AddSingleton\u0026lt;ISukiDialogManager\u0026gt;(s =\u0026gt; DialogExManager.GetDialogManager()); } 注册 Redis 缓存服务 1 2 3 4 5 6 7 8 9 10 11 12 public static void AddDistributedCache(this IServiceCollection collection) { var connection = ConnectionMultiplexer.Connect(\u0026#34;127.0.0.1:6379\u0026#34;); var redis = connection.GetDatabase(); collection.AddSingleton(redis); collection.AddSingleton(connection); collection.AddSingleton\u0026lt;IDistributedCache, RedisCache\u0026gt;(s =\u0026gt; { return new RedisCache(s.GetRequiredService\u0026lt;IDatabase\u0026gt;()); }); } 4️⃣ 辅助类：对话框与 Toast 管理器 1 2 3 4 5 6 7 8 public static class DialogExManager { private static readonly ISukiToastManager ToastManager = new SukiToastManager(); private static readonly ISukiDialogManager DialogManager = new SukiDialogManager(); public static ISukiToastManager GetToastManager() =\u0026gt; ToastManager; public static ISukiDialogManager GetDialogManager() =\u0026gt; DialogManager; } 5️⃣ 视图定位器（ViewLocator） 如果启用了 ViewLocator，则 ViewModel 与 View 将自动绑定。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class ViewLocator : IDataTemplate { public Control? Build(object? param) { if (param is null) return null; var name = param.GetType().FullName!.Replace(\u0026#34;ViewModel\u0026#34;, \u0026#34;View\u0026#34;, StringComparison.Ordinal); var type = Type.GetType(name); return type != null ? (Control)Activator.CreateInstance(type)! : new TextBlock { Text = \u0026#34;Not Found: \u0026#34; + name }; } public bool Match(object? data) { return data is ViewModelBase; } } 📝 如果未启用 ViewLocator，则需要手动设置 DataContext。\n✅ 总结 Avalonia 是一个强大的跨平台 UI 框架，结合 Microsoft.Extensions.DependencyInjection 可实现高度解耦和模块化的应用程序架构。通过合理配置服务生命周期和使用视图定位器等机制，可以显著提升开发效率和代码质量。\n","date":"2025-06-04T11:04:44+08:00","image":"https://images.unsplash.com/photo-1649972904349-6e44c42644a7?ixlib=rb-4.0.3\u0026q=85\u0026fm=jpg\u0026crop=entropy\u0026cs=srgb\u0026w=3600","permalink":"https://dumbnessrf.github.io/p/dependency_injection/","title":"Avalonia中使用依赖注入重构代码"},{"content":"Converter 类型详解与使用示例 目录 Normal Converter IMultiValueConverter FuncValueConverter 为了提高 Converter 的利用率，可以将其实例定义为静态资源，避免重复创建实例。例如：\n1 2 3 4 /// \u0026lt;summary\u0026gt; /// 获取 MathAddConverter 的静态实例 /// \u0026lt;/summary\u0026gt; public static MathAddConverter AddConverter { get; } = new MathAddConverter(); 在 XAML 中调用该静态资源的方式如下：\n1 2 \u0026lt;NumericUpDown Grid.Row=\u0026#34;1\u0026#34; Grid.Column=\u0026#34;1\u0026#34; Value=\u0026#34;{Binding Number1, Converter={x:Static MathAddConverter.AddConverter}, ConverterParameter={StaticResource MyConverterParameter}}\u0026#34; /\u0026gt; Normal Converter 普通值转换器（IValueConverter）：用于单个绑定值的转换，但 ConverterParameter 不支持动态绑定。\n示例：AddConverter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class AddConverter : IValueConverter { public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture) { if (value is decimal d1 \u0026amp;\u0026amp; parameter is decimal d2) { return d1 + d2; } return null; } public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture) { if (value is decimal d1 \u0026amp;\u0026amp; parameter is decimal d2) { return d1 - d2; } return null; } } XAML 资源定义 1 2 3 4 \u0026lt;Window.Resources\u0026gt; \u0026lt;conv:AddConverter x:Key=\u0026#34;AddConverter\u0026#34; /\u0026gt; \u0026lt;x:Decimal x:Key=\u0026#34;inputAddValue\u0026#34;\u0026gt;2\u0026lt;/x:Decimal\u0026gt; \u0026lt;/Window.Resources\u0026gt; 使用示例 1 2 3 4 5 6 7 8 9 10 \u0026lt;StackPanel Orientation=\u0026#34;Horizontal\u0026#34;\u0026gt; \u0026lt;TextBlock Classes=\u0026#34;Header\u0026#34; Text=\u0026#34;NormalConverter\u0026#34; /\u0026gt; \u0026lt;TextBlock Text=\u0026#34;Input a number to sum\u0026#34; /\u0026gt; \u0026lt;NumericUpDown Increment=\u0026#34;0.1\u0026#34; Value=\u0026#34;{Binding Number}\u0026#34; /\u0026gt; \u0026lt;TextBlock Text=\u0026#34;Sum\u0026#34; /\u0026gt; \u0026lt;NumericUpDown Value=\u0026#34;{Binding Number, Converter={StaticResource AddConverter}, ConverterParameter={StaticResource inputAddValue}}\u0026#34; /\u0026gt; \u0026lt;/StackPanel\u0026gt; IMultiValueConverter 多值转换器（IMultiValueConverter）：支持多个绑定值输入，ConverterParameter 支持绑定。\n示例：MultiValueAddConverter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class MultiValueAddConverter : IMultiValueConverter { public object? Convert(IList\u0026lt;object?\u0026gt; values, Type targetType, object? parameter, CultureInfo culture) { if (values.Any(s =\u0026gt; s is not decimal)) { return new BindingNotification( new InvalidOperationException( \u0026#34;Not all input parameter type is decimal, this converter only support decimal type\u0026#34; ), BindingErrorType.Error ); } return values.Sum(s =\u0026gt; (decimal)s); } } 使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;StackPanel Orientation=\u0026#34;Horizontal\u0026#34;\u0026gt; \u0026lt;TextBlock Classes=\u0026#34;Header\u0026#34; Text=\u0026#34;MultiValueConverter\u0026#34; /\u0026gt; \u0026lt;TextBlock Text=\u0026#34;Input numbers to sum\u0026#34; /\u0026gt; \u0026lt;NumericUpDown Increment=\u0026#34;0.1\u0026#34; Value=\u0026#34;{Binding Number1}\u0026#34; /\u0026gt; \u0026lt;NumericUpDown Increment=\u0026#34;0.1\u0026#34; Value=\u0026#34;{Binding Number2}\u0026#34; /\u0026gt; \u0026lt;NumericUpDown Increment=\u0026#34;0.1\u0026#34; Value=\u0026#34;{Binding Number3}\u0026#34; /\u0026gt; \u0026lt;TextBlock Text=\u0026#34;Sum\u0026#34; /\u0026gt; \u0026lt;NumericUpDown IsReadOnly=\u0026#34;True\u0026#34;\u0026gt; \u0026lt;NumericUpDown.Value\u0026gt; \u0026lt;MultiBinding Converter=\u0026#34;{StaticResource MultiValueAddConverter}\u0026#34; Mode=\u0026#34;OneWay\u0026#34;\u0026gt; \u0026lt;Binding Path=\u0026#34;Number1\u0026#34; /\u0026gt; \u0026lt;Binding Path=\u0026#34;Number2\u0026#34; /\u0026gt; \u0026lt;Binding Path=\u0026#34;Number3\u0026#34; /\u0026gt; \u0026lt;/MultiBinding\u0026gt; \u0026lt;/NumericUpDown.Value\u0026gt; \u0026lt;/NumericUpDown\u0026gt; \u0026lt;/StackPanel\u0026gt; FuncValueConverter 函数式转换器（FuncValueConverter）：通过委托方式定义转换逻辑，适用于类型明确、逻辑简单的场景。\n示例：字符串转画刷 1 2 3 4 5 6 7 8 9 10 11 12 13 public class FuncValueConverters { public static FuncValueConverter\u0026lt;string?, Brush?\u0026gt; StringToBrushFuncConverter { get; } = new(s =\u0026gt; { Color color; if (Color.TryParse(s, out color) || Color.TryParse($\u0026#34;#{s}\u0026#34;, out color)) { return new SolidColorBrush(color); } return null; }); } 使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;StackPanel Orientation=\u0026#34;Horizontal\u0026#34;\u0026gt; \u0026lt;TextBlock Classes=\u0026#34;Header\u0026#34; Text=\u0026#34;FuncValueConverter\u0026#34; /\u0026gt; \u0026lt;TextBox Text=\u0026#34;red\u0026#34; UseFloatingWatermark=\u0026#34;True\u0026#34; Watermark=\u0026#34;Type the color to parse (e.g.: red, green, blue, #FF112233)\u0026#34;\u0026gt; \u0026lt;TextBox.InnerLeftContent\u0026gt; \u0026lt;Ellipse Fill=\u0026#34;{Binding $parent[TextBox].Text, Converter={x:Static conv:FuncValueConverters.StringToBrushFuncConverter}}\u0026#34; Height=\u0026#34;20\u0026#34; Margin=\u0026#34;5,0,0,0\u0026#34; Stroke=\u0026#34;Gray\u0026#34; StrokeThickness=\u0026#34;1\u0026#34; Width=\u0026#34;20\u0026#34; /\u0026gt; \u0026lt;/TextBox.InnerLeftContent\u0026gt; \u0026lt;/TextBox\u0026gt; \u0026lt;/StackPanel\u0026gt; 如需扩展更多转换逻辑，可以继续添加新的 Converter 或使用 FuncValueConverter 快速实现轻量级转换逻辑。\n","date":"2025-06-04T11:04:44+08:00","image":"https://www.notion.so/images/page-cover/rijksmuseum_jansz_1637.jpg","permalink":"https://dumbnessrf.github.io/p/converter-in-avalonia/","title":"Avalonia中的各种Converter使用"},{"content":"WPF 中的 DataTemplateSelector：高级数据模板选择技巧与应用 在 WPF（Windows Presentation Foundation）开发中，DataTemplate 是我们用来定义如何显示绑定数据的重要工具。然而，有时候我们需要根据不同的数据对象动态地选择不同的 DataTemplate 来呈现 UI。这时，DataTemplateSelector 就派上用场了。\n本文将介绍：\n什么是 DataTemplateSelector 如何自定义一个 DataTemplateSelector 实际应用场景和代码示例 使用技巧与最佳实践 一、什么是 DataTemplateSelector？ DataTemplateSelector 是一个抽象类，它允许你根据绑定项的内容来决定使用哪个 DataTemplate。你可以继承这个类并重写它的 SelectTemplate 方法，从而实现自定义的模板选择逻辑。\n二、如何自定义一个 DataTemplateSelector？ 我们先来看一个简单的例子。\n示例场景：聊天消息列表 假设我们有一个聊天程序，每条消息可能是用户发送的，也可能是系统自动发送的。我们想对这两种消息应用不同的样式。\n1. 定义数据模型 1 2 3 4 5 6 7 8 9 10 11 public class Message { public string Content { get; set; } public MessageType Type { get; set; } } public enum MessageType { User, System } 2. 创建两个不同的 DataTemplate 在 XAML 中定义两种不同风格的消息模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;Window.Resources\u0026gt; \u0026lt;!-- 用户消息模板 --\u0026gt; \u0026lt;DataTemplate x:Key=\u0026#34;UserMessageTemplate\u0026#34;\u0026gt; \u0026lt;Border Background=\u0026#34;LightBlue\u0026#34; Padding=\u0026#34;10\u0026#34; Margin=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding Content}\u0026#34; /\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;!-- 系统消息模板 --\u0026gt; \u0026lt;DataTemplate x:Key=\u0026#34;SystemMessageTemplate\u0026#34;\u0026gt; \u0026lt;Border Background=\u0026#34;LightGray\u0026#34; Padding=\u0026#34;10\u0026#34; Margin=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding Content}\u0026#34; FontStyle=\u0026#34;Italic\u0026#34;/\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/Window.Resources\u0026gt; 3. 自定义 DataTemplateSelector 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class MessageTemplateSelector : DataTemplateSelector { public DataTemplate UserMessageTemplate { get; set; } public DataTemplate SystemMessageTemplate { get; set; } public override DataTemplate SelectTemplate(object item, DependencyObject container) { if (item is Message message) { switch (message.Type) { case MessageType.User: return UserMessageTemplate; case MessageType.System: return SystemMessageTemplate; } } return base.SelectTemplate(item, container); } } 4. 在 XAML 中注册并使用 TemplateSelector 1 2 3 4 5 6 7 8 \u0026lt;Window.Resources\u0026gt; \u0026lt;local:MessageTemplateSelector x:Key=\u0026#34;messageTemplateSelector\u0026#34; UserMessageTemplate=\u0026#34;{StaticResource UserMessageTemplate}\u0026#34; SystemMessageTemplate=\u0026#34;{StaticResource SystemMessageTemplate}\u0026#34; /\u0026gt; \u0026lt;/Window.Resources\u0026gt; \u0026lt;ListBox ItemsSource=\u0026#34;{Binding Messages}\u0026#34; ItemTemplateSelector=\u0026#34;{StaticResource messageTemplateSelector}\u0026#34; /\u0026gt; 注意：local 需要引用你的命名空间，例如：\n1 2 \u0026lt;Window xmlns:local=\u0026#34;clr-namespace:YourNamespace\u0026#34; ... 三、应用场景举例 场景 1：多类型列表展示（如新闻、通知、订单等混合展示） 你可以为不同类型的数据项选择不同的模板，使得同一个列表中能展示多种结构不同的信息。\n场景 2：UI 主题或状态变化 根据对象的状态（如“已读”、“未读”、“错误”等）切换不同的 UI 样式。\n场景 3：个性化内容展示 比如在一个论坛应用中，帖子作者、管理员、普通用户的发言需要不同颜色或图标标识。\n四、使用技巧与最佳实践 ✅ 技巧 1：保持 TemplateSelector 的可复用性 目标： 设计一个通用的 DataTemplateSelector，可以通过依赖属性传入模板，提高组件复用性。\n实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class ReusableTemplateSelector : DataTemplateSelector { public DataTemplate DefaultTemplate { get; set; } public DataTemplate AlternateTemplate { get; set; } public override DataTemplate SelectTemplate(object item, DependencyObject container) { if (item is ICustomType customItem \u0026amp;\u0026amp; customItem.IsSpecial) { return AlternateTemplate; } return DefaultTemplate ?? base.SelectTemplate(item, container); } } // 接口用于判断是否是“特殊类型” public interface ICustomType { bool IsSpecial { get; } } 使用 XAML： 1 2 3 \u0026lt;local:ReusableTemplateSelector x:Key=\u0026#34;reusableSelector\u0026#34; DefaultTemplate=\u0026#34;{StaticResource NormalTemplate}\u0026#34; AlternateTemplate=\u0026#34;{StaticResource SpecialTemplate}\u0026#34; /\u0026gt; 应用场景： 多个页面中重复使用同一个选择器。 不同业务逻辑下只需更换绑定的 DataTemplate。 ✅ 技巧 2：结合 MVVM 模式使用 目标： 在 MVVM 架构中使用 DataTemplateSelector，将 UI 展示与数据分离。\n实现： ViewModel 示例： 1 2 3 4 5 6 7 8 9 10 11 public class MessageViewModel : INotifyPropertyChanged { public string Content { get; set; } public MessageType Type { get; set; } // User / System } public enum MessageType { User, System } 自定义 Selector： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class MessageTypeSelector : DataTemplateSelector { public DataTemplate UserTemplate { get; set; } public DataTemplate SystemTemplate { get; set; } public override DataTemplate SelectTemplate(object item, DependencyObject container) { if (item is MessageViewModel msg) { return msg.Type == MessageType.User ? UserTemplate : SystemTemplate; } return base.SelectTemplate(item, container); } } XAML 中绑定： 1 2 \u0026lt;ListBox ItemsSource=\u0026#34;{Binding Messages}\u0026#34; ItemTemplateSelector=\u0026#34;{StaticResource messageTypeSelector}\u0026#34; /\u0026gt; 优势： 完全解耦 View 和 ViewModel。 易于维护和测试。 ✅ 技巧 3：避免过度复杂的逻辑 目标： 确保 SelectTemplate 方法逻辑简洁，不嵌套复杂判断。\n反面例子（不推荐）： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public override DataTemplate SelectTemplate(...) { if (item is Order o) { if (o.Status == \u0026#34;Pending\u0026#34;) { if (o.CustomerLevel == \u0026#34;VIP\u0026#34;) return VipPendingTemplate; else return PendingTemplate; } else if (o.Status == \u0026#34;Completed\u0026#34;) { ... } } } 改进方式： 使用策略模式或状态枚举映射 1 2 3 4 5 6 7 8 9 10 11 12 13 public class OrderTemplateSelector : DataTemplateSelector { public Dictionary\u0026lt;OrderState, DataTemplate\u0026gt; Templates { get; } = new(); public override DataTemplate SelectTemplate(object item, DependencyObject container) { if (item is Order order) { return Templates.GetValueOrDefault(order.State); } return base.SelectTemplate(item, container); } } XAML 配置： 1 2 3 4 5 6 \u0026lt;local:OrderTemplateSelector x:Key=\u0026#34;orderSelector\u0026#34;\u0026gt; \u0026lt;local:OrderTemplateSelector.Templates\u0026gt; \u0026lt;Component:TemplateMapEntry Key=\u0026#34;Pending\u0026#34; Value=\u0026#34;{StaticResource PendingTemplate}\u0026#34; /\u0026gt; \u0026lt;Component:TemplateMapEntry Key=\u0026#34;Completed\u0026#34; Value=\u0026#34;{StaticResource CompletedTemplate}\u0026#34; /\u0026gt; \u0026lt;/local:OrderTemplateSelector.Templates\u0026gt; \u0026lt;/local:OrderTemplateSelector\u0026gt; 💡 注：你可以自定义 TemplateMapEntry 类型来支持这种字典结构。\n✅ 技巧 4：调试时注意 Binding 上下文问题 常见错误： 在 SelectTemplate 中获取不到正确对象。 绑定路径错误导致无法识别类型。 解决方法： 确保绑定上下文正确 1 2 \u0026lt;ListBox ItemsSource=\u0026#34;{Binding MyItems}\u0026#34; ItemTemplateSelector=\u0026#34;{StaticResource mySelector}\u0026#34; /\u0026gt; 确保 MyItems 是 IEnumerable\u0026lt;T\u0026gt;，且每一项类型都能被识别。\n添加日志辅助调试： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public override DataTemplate SelectTemplate(object item, DependencyObject container) { if (item == null) { Debug.WriteLine(\u0026#34;Item is null\u0026#34;); return base.SelectTemplate(item, container); } Debug.WriteLine($\u0026#34;Item type: {item.GetType().Name}\u0026#34;); if (item is CustomType ct) { return ct.IsSpecial ? SpecialTemplate : NormalTemplate; } return base.SelectTemplate(item, container); } 五、总结 DataTemplateSelector 是 WPF 中非常强大且灵活的功能，它帮助我们实现了数据驱动的 UI 模板选择。无论是构建复杂的 UI 列表还是实现高度定制化的展示逻辑，DataTemplateSelector 都是一个值得掌握的技能。\n","date":"2025-05-30T14:46:48+08:00","image":"https://www.notion.so/images/page-cover/nasa_new_york_city_grid.jpg","permalink":"https://dumbnessrf.github.io/p/data-template-selector-tips/","title":"WPF技巧-数据模板动态选择"},{"content":"解锁.NET 新姿势：基于文件的程序特性深度解析与实战 在.NET 的世界里，新项目的创建和运行往往离不开.csproj项目文件，从编写代码到调试运行，需要一系列繁琐的步骤。但随着.NET 技术的不断演进，基于文件的程序（File-based programs） 这一新特性的出现，打破了这一传统模式，为开发者带来了更加便捷、高效的开发体验。\n基于文件的程序特性概述 基于文件的程序，简单来说，就是将部分 MSBuild 项目功能嵌入到 C# 代码中，允许开发者直接运行单个 C# 文件，就像运行一个完整的项目一样。在以往，运行 C# 代码通常需要先创建一个项目，编写 .csproj 文件来配置项目的各种属性，如引用的包、目标框架等。而基于文件的程序则无需这些复杂的操作，它通过在 C# 源文件中添加特殊的 #: 指令，在内存中生成一个 “虚拟项目”，然后将这个 “虚拟项目” 传递给 MSBuild 进行构建和运行。\n其背后的运行机制是：当使用 dotnet run 命令运行一个 C# 文件时，命令行会解析源文件中的 #: 指令，根据这些指令在内存中构建一个 C# 项目 XML 文档，这个文档就相当于一个常规项目的 .csproj 文件。随后，MSBuild 会基于这个内存中的项目文档进行编译和运行，使得单个文件能够像完整项目一样执行 。\n应用示例详解 示例 1：经典 Hello World 1 2 3 // HelloWorld.cs #:r \u0026#34;System.Net.Http\u0026#34; Console.WriteLine(\u0026#34;Hello, World!\u0026#34;); 在这个简单示例中，#:r \u0026quot;System.Net.Http\u0026quot; 是一个 #: 指令，它用于引用 System.Net.Http 程序集。虽然代码中没有传统的项目文件配置，但通过这条指令，我们为程序添加了所需的引用。在命令行中进入该文件所在目录，执行 dotnet run HelloWorld.cs，就能看到熟悉的 “Hello, World!” 输出。这展示了基于文件的程序最基础的运行方式，仅需一个 C# 文件和简单指令，即可快速运行代码。\n示例 2：引用外部 NuGet 包 1 2 3 4 5 6 7 8 9 10 11 12 13 // NewtonsoftJsonExample.cs #:package Newtonsoft.Json 13.0.1 using Newtonsoft.Json; class Program { static void Main() { var person = new { Name = \u0026#34;Alice\u0026#34;, Age = 30 }; var json = JsonConvert.SerializeObject(person); Console.WriteLine(json); } } 在这个示例中，#:package Newtonsoft.Json 13.0.1 指令用于引入 Newtonsoft.Json 包及其指定版本。引入后，代码中就能使用 Newtonsoft.Json 提供的功能，如将对象序列化为 JSON 字符串。运行时，dotnet run 命令会根据该指令自动下载并引用所需的 NuGet 包，无需手动在项目文件中添加包引用，极大地简化了使用外部包的流程 。\n示例 3：多文件协作 假设我们有一个简单的数学计算项目，包含两个文件：Calculator.cs 和 Program.cs。\nCalculator.cs 文件内容如下：\n1 2 3 4 5 6 7 8 9 10 11 // Calculator.cs namespace MathUtils { public static class Calculator { public static int Add(int a, int b) { return a + b; } } } Program.cs 文件内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 // Program.cs #:r \u0026#34;System.Net.Http\u0026#34; using MathUtils; class Program { static void Main() { int result = Calculator.Add(5, 3); Console.WriteLine($\u0026#34;The result of addition is: {result}\u0026#34;); } } 在基于文件的程序中，无需手动在项目文件中配置文件引用关系。当使用 dotnet run Program.cs 命令运行时，SDK CLI 会自动解析 Program.cs 所在目录树中的所有 .cs 文件，将 Calculator.cs 包含在编译过程中，使得不同文件之间能够顺利协作，实现复杂的功能 。\n与传统项目模式的对比优势 降低入门门槛\n对于初学者来说，传统的 .csproj 项目文件配置复杂，包含众多属性和节点，容易让新手感到困惑。而基于文件的程序模式，只需关注代码本身和简单的 #: 指令，无需深入了解项目文件配置，能够更快地编写和运行代码，降低了学习成本。\n快速原型开发\n在开发初期进行原型设计时，往往需要快速验证想法和功能。基于文件的程序无需创建完整项目结构，直接编写单个文件并运行，能够大大提高开发效率，快速迭代原型。\n简化小型工具开发\n对于一些简单的小型工具或脚本，使用传统项目模式显得过于繁琐。基于文件的程序可以用最少的配置和步骤实现功能，使代码更加简洁、轻便，便于维护和管理。\n使用注意事项 虽然基于文件的程序带来了诸多便利，但在使用过程中也有一些需要注意的地方：\n目前基于文件的程序在功能上还存在一定限制，例如对某些复杂的项目配置和构建自定义支持不够完善。 由于其依赖于 #: 指令来配置项目属性，指令的语法和使用规则需要开发者熟练掌握，否则可能会出现引用错误或构建失败等问题。 在团队协作开发中，基于文件的程序可能会因为成员使用不同版本的 .NET SDK 而导致运行结果不一致，需要统一开发环境。 以上就是对 .NET 基于文件的程序特性的详细介绍和应用示例。这一特性为开发者提供了更灵活高效的开发方式，无论是初学者快速上手，还是经验丰富的开发者进行快速开发，都能发挥重要作用。不妨亲自尝试，感受它带来的便捷！如果你在使用过程中有新的发现或遇到问题，欢迎一起交流探讨。\n","date":"2025-05-29T11:04:44+08:00","image":"https://www.notion.so/images/page-cover/rijksmuseum_mignons_1660.jpg","permalink":"https://dumbnessrf.github.io/p/single-file-run/","title":"单文件运行C#代码"}]