[{"content":"🧩 Avalonia 框架概览 🔍 简介 Avalonia 是一个 跨平台的 .NET 用户界面框架，支持使用 C# 和 XAML 构建桌面、移动和 Web 应用程序。其设计灵感来源于 WPF 和 UWP，但具有更强的跨平台兼容性。\n✅ 主要特点： 使用熟悉的 XAML 语法 支持多种 UI 控件和样式 可运行于多个操作系统 支持 MVVM 模式及依赖注入 🌐 平台支持 Avalonia 支持以下平台：\n平台 支持情况 Windows 完全支持 Linux 完全支持 macOS 完全支持 Android/iOS 实验性支持（需额外适配） WebAssembly 支持（通过 WASM 渲染器） 💡 Avalonia 提供了真正的跨平台开发能力，适用于需要统一多端体验的应用场景。\n⚙️ 性能表现 Avalonia 的渲染引擎经过优化，具备高效的绘制能力和良好的硬件加速支持，尤其在处理复杂图形与数据可视化时表现出色。\n高效的渲染管道 支持 GPU 加速 低延迟响应用户交互 例如：当应用中存在大量动态图表或动画元素时，Avalonia 能保持流畅的帧率，避免卡顿现象。\n🔄 Microsoft.Extensions.DependencyInjection 详解 📦 概述 Microsoft.Extensions.DependencyInjection 是 .NET 中的一个 轻量级依赖注入（DI）容器，它提供了一种灵活的方式来管理应用程序中的对象及其依赖关系。\n💡 为什么使用 DI？ 解耦业务逻辑与具体实现 提高代码可测试性和可维护性 支持模块化开发 🕒 服务生命周期（Service Lifecycle） 生命周期类型 描述 Transient（瞬态） 每次请求都会创建新实例，适合无状态服务 Scoped（作用域） 同一作用域内共享同一个实例，常用于 Web 请求上下文 Singleton（单例） 整个应用程序周期内共享唯一实例，适合全局资源管理 示例说明： Transient：每次调用 IDataProcessor 都会返回一个新的实例。 Scoped：在一次 HTTP 请求中，所有对 IDatabaseContext 的请求都返回同一个实例。 Singleton：如 IAppSettings，在整个应用程序中始终为同一实例。 🧪 示例：在 Avalonia 中集成依赖注入 📝以下示例将添加Redis和第三方Avalonia样式库SukiUI作为参考\n1️⃣ 安装依赖注入包 1 install-package Microsoft.Extensions.DependencyInjection 2️⃣ 初始化服务容器 在 App.xaml.cs 中重写 OnFrameworkInitializationCompleted() 方法以注册并构建服务容器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public override void OnFrameworkInitializationCompleted() { var collection = new ServiceCollection(); collection.AddCommonServices(); collection.AddDistributedCache(); _services = collection.BuildServiceProvider(); var vm = _services.GetRequiredService\u0026lt;MainWindowViewModel\u0026gt;(); var toastService = _services.GetRequiredService\u0026lt;ISukiToastManager\u0026gt;(); var dialogService = _services.GetRequiredService\u0026lt;ISukiDialogManager\u0026gt;(); if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop) { desktop.MainWindow = _services.GetRequiredService\u0026lt;MainWindow\u0026gt;(); } else if (ApplicationLifetime is ISingleViewApplicationLifetime singleViewPlatform) { singleViewPlatform.MainView = new MainWindow(toastService, dialogService) { DataContext = vm, }; } base.OnFrameworkInitializationCompleted(); } 3️⃣ 注册服务 自定义扩展方法注册常用服务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static void AddCommonServices(this IServiceCollection collection) { collection.AddSingleton\u0026lt;MainWindowViewModel\u0026gt;(); collection.AddSingleton\u0026lt;MainWindow\u0026gt;(s =\u0026gt; new MainWindow( s.GetRequiredService\u0026lt;ISukiToastManager\u0026gt;(), s.GetRequiredService\u0026lt;ISukiDialogManager\u0026gt;() ) { DataContext = s.GetRequiredService\u0026lt;MainWindowViewModel\u0026gt;(), }); collection.AddSingleton\u0026lt;ISukiToastManager\u0026gt;(s =\u0026gt; DialogExManager.GetToastManager()); collection.AddSingleton\u0026lt;ISukiDialogManager\u0026gt;(s =\u0026gt; DialogExManager.GetDialogManager()); } 注册 Redis 缓存服务 1 2 3 4 5 6 7 8 9 10 11 12 public static void AddDistributedCache(this IServiceCollection collection) { var connection = ConnectionMultiplexer.Connect(\u0026#34;127.0.0.1:6379\u0026#34;); var redis = connection.GetDatabase(); collection.AddSingleton(redis); collection.AddSingleton(connection); collection.AddSingleton\u0026lt;IDistributedCache, RedisCache\u0026gt;(s =\u0026gt; { return new RedisCache(s.GetRequiredService\u0026lt;IDatabase\u0026gt;()); }); } 4️⃣ 辅助类：对话框与 Toast 管理器 1 2 3 4 5 6 7 8 public static class DialogExManager { private static readonly ISukiToastManager ToastManager = new SukiToastManager(); private static readonly ISukiDialogManager DialogManager = new SukiDialogManager(); public static ISukiToastManager GetToastManager() =\u0026gt; ToastManager; public static ISukiDialogManager GetDialogManager() =\u0026gt; DialogManager; } 5️⃣ 视图定位器（ViewLocator） 如果启用了 ViewLocator，则 ViewModel 与 View 将自动绑定。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class ViewLocator : IDataTemplate { public Control? Build(object? param) { if (param is null) return null; var name = param.GetType().FullName!.Replace(\u0026#34;ViewModel\u0026#34;, \u0026#34;View\u0026#34;, StringComparison.Ordinal); var type = Type.GetType(name); return type != null ? (Control)Activator.CreateInstance(type)! : new TextBlock { Text = \u0026#34;Not Found: \u0026#34; + name }; } public bool Match(object? data) { return data is ViewModelBase; } } 📝 如果未启用 ViewLocator，则需要手动设置 DataContext。\n✅ 总结 Avalonia 是一个强大的跨平台 UI 框架，结合 Microsoft.Extensions.DependencyInjection 可实现高度解耦和模块化的应用程序架构。通过合理配置服务生命周期和使用视图定位器等机制，可以显著提升开发效率和代码质量。\n","date":"2025-06-04T11:04:44+08:00","image":"https://images.unsplash.com/photo-1649972904349-6e44c42644a7?ixlib=rb-4.0.3\u0026q=85\u0026fm=jpg\u0026crop=entropy\u0026cs=srgb\u0026w=3600","permalink":"https://dumbnessrf.github.io/p/dependency_injection/","title":"Avalonia中使用依赖注入重构代码"},{"content":"WPF 中的 DataTemplateSelector：高级数据模板选择技巧与应用 在 WPF（Windows Presentation Foundation）开发中，DataTemplate 是我们用来定义如何显示绑定数据的重要工具。然而，有时候我们需要根据不同的数据对象动态地选择不同的 DataTemplate 来呈现 UI。这时，DataTemplateSelector 就派上用场了。\n本文将介绍：\n什么是 DataTemplateSelector 如何自定义一个 DataTemplateSelector 实际应用场景和代码示例 使用技巧与最佳实践 一、什么是 DataTemplateSelector？ DataTemplateSelector 是一个抽象类，它允许你根据绑定项的内容来决定使用哪个 DataTemplate。你可以继承这个类并重写它的 SelectTemplate 方法，从而实现自定义的模板选择逻辑。\n二、如何自定义一个 DataTemplateSelector？ 我们先来看一个简单的例子。\n示例场景：聊天消息列表 假设我们有一个聊天程序，每条消息可能是用户发送的，也可能是系统自动发送的。我们想对这两种消息应用不同的样式。\n1. 定义数据模型 1 2 3 4 5 6 7 8 9 10 11 public class Message { public string Content { get; set; } public MessageType Type { get; set; } } public enum MessageType { User, System } 2. 创建两个不同的 DataTemplate 在 XAML 中定义两种不同风格的消息模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;Window.Resources\u0026gt; \u0026lt;!-- 用户消息模板 --\u0026gt; \u0026lt;DataTemplate x:Key=\u0026#34;UserMessageTemplate\u0026#34;\u0026gt; \u0026lt;Border Background=\u0026#34;LightBlue\u0026#34; Padding=\u0026#34;10\u0026#34; Margin=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding Content}\u0026#34; /\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;!-- 系统消息模板 --\u0026gt; \u0026lt;DataTemplate x:Key=\u0026#34;SystemMessageTemplate\u0026#34;\u0026gt; \u0026lt;Border Background=\u0026#34;LightGray\u0026#34; Padding=\u0026#34;10\u0026#34; Margin=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding Content}\u0026#34; FontStyle=\u0026#34;Italic\u0026#34;/\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/Window.Resources\u0026gt; 3. 自定义 DataTemplateSelector 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class MessageTemplateSelector : DataTemplateSelector { public DataTemplate UserMessageTemplate { get; set; } public DataTemplate SystemMessageTemplate { get; set; } public override DataTemplate SelectTemplate(object item, DependencyObject container) { if (item is Message message) { switch (message.Type) { case MessageType.User: return UserMessageTemplate; case MessageType.System: return SystemMessageTemplate; } } return base.SelectTemplate(item, container); } } 4. 在 XAML 中注册并使用 TemplateSelector 1 2 3 4 5 6 7 8 \u0026lt;Window.Resources\u0026gt; \u0026lt;local:MessageTemplateSelector x:Key=\u0026#34;messageTemplateSelector\u0026#34; UserMessageTemplate=\u0026#34;{StaticResource UserMessageTemplate}\u0026#34; SystemMessageTemplate=\u0026#34;{StaticResource SystemMessageTemplate}\u0026#34; /\u0026gt; \u0026lt;/Window.Resources\u0026gt; \u0026lt;ListBox ItemsSource=\u0026#34;{Binding Messages}\u0026#34; ItemTemplateSelector=\u0026#34;{StaticResource messageTemplateSelector}\u0026#34; /\u0026gt; 注意：local 需要引用你的命名空间，例如：\n1 2 \u0026lt;Window xmlns:local=\u0026#34;clr-namespace:YourNamespace\u0026#34; ... 三、应用场景举例 场景 1：多类型列表展示（如新闻、通知、订单等混合展示） 你可以为不同类型的数据项选择不同的模板，使得同一个列表中能展示多种结构不同的信息。\n场景 2：UI 主题或状态变化 根据对象的状态（如“已读”、“未读”、“错误”等）切换不同的 UI 样式。\n场景 3：个性化内容展示 比如在一个论坛应用中，帖子作者、管理员、普通用户的发言需要不同颜色或图标标识。\n四、使用技巧与最佳实践 ✅ 技巧 1：保持 TemplateSelector 的可复用性 目标： 设计一个通用的 DataTemplateSelector，可以通过依赖属性传入模板，提高组件复用性。\n实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class ReusableTemplateSelector : DataTemplateSelector { public DataTemplate DefaultTemplate { get; set; } public DataTemplate AlternateTemplate { get; set; } public override DataTemplate SelectTemplate(object item, DependencyObject container) { if (item is ICustomType customItem \u0026amp;\u0026amp; customItem.IsSpecial) { return AlternateTemplate; } return DefaultTemplate ?? base.SelectTemplate(item, container); } } // 接口用于判断是否是“特殊类型” public interface ICustomType { bool IsSpecial { get; } } 使用 XAML： 1 2 3 \u0026lt;local:ReusableTemplateSelector x:Key=\u0026#34;reusableSelector\u0026#34; DefaultTemplate=\u0026#34;{StaticResource NormalTemplate}\u0026#34; AlternateTemplate=\u0026#34;{StaticResource SpecialTemplate}\u0026#34; /\u0026gt; 应用场景： 多个页面中重复使用同一个选择器。 不同业务逻辑下只需更换绑定的 DataTemplate。 ✅ 技巧 2：结合 MVVM 模式使用 目标： 在 MVVM 架构中使用 DataTemplateSelector，将 UI 展示与数据分离。\n实现： ViewModel 示例： 1 2 3 4 5 6 7 8 9 10 11 public class MessageViewModel : INotifyPropertyChanged { public string Content { get; set; } public MessageType Type { get; set; } // User / System } public enum MessageType { User, System } 自定义 Selector： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class MessageTypeSelector : DataTemplateSelector { public DataTemplate UserTemplate { get; set; } public DataTemplate SystemTemplate { get; set; } public override DataTemplate SelectTemplate(object item, DependencyObject container) { if (item is MessageViewModel msg) { return msg.Type == MessageType.User ? UserTemplate : SystemTemplate; } return base.SelectTemplate(item, container); } } XAML 中绑定： 1 2 \u0026lt;ListBox ItemsSource=\u0026#34;{Binding Messages}\u0026#34; ItemTemplateSelector=\u0026#34;{StaticResource messageTypeSelector}\u0026#34; /\u0026gt; 优势： 完全解耦 View 和 ViewModel。 易于维护和测试。 ✅ 技巧 3：避免过度复杂的逻辑 目标： 确保 SelectTemplate 方法逻辑简洁，不嵌套复杂判断。\n反面例子（不推荐）： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public override DataTemplate SelectTemplate(...) { if (item is Order o) { if (o.Status == \u0026#34;Pending\u0026#34;) { if (o.CustomerLevel == \u0026#34;VIP\u0026#34;) return VipPendingTemplate; else return PendingTemplate; } else if (o.Status == \u0026#34;Completed\u0026#34;) { ... } } } 改进方式： 使用策略模式或状态枚举映射 1 2 3 4 5 6 7 8 9 10 11 12 13 public class OrderTemplateSelector : DataTemplateSelector { public Dictionary\u0026lt;OrderState, DataTemplate\u0026gt; Templates { get; } = new(); public override DataTemplate SelectTemplate(object item, DependencyObject container) { if (item is Order order) { return Templates.GetValueOrDefault(order.State); } return base.SelectTemplate(item, container); } } XAML 配置： 1 2 3 4 5 6 \u0026lt;local:OrderTemplateSelector x:Key=\u0026#34;orderSelector\u0026#34;\u0026gt; \u0026lt;local:OrderTemplateSelector.Templates\u0026gt; \u0026lt;Component:TemplateMapEntry Key=\u0026#34;Pending\u0026#34; Value=\u0026#34;{StaticResource PendingTemplate}\u0026#34; /\u0026gt; \u0026lt;Component:TemplateMapEntry Key=\u0026#34;Completed\u0026#34; Value=\u0026#34;{StaticResource CompletedTemplate}\u0026#34; /\u0026gt; \u0026lt;/local:OrderTemplateSelector.Templates\u0026gt; \u0026lt;/local:OrderTemplateSelector\u0026gt; 💡 注：你可以自定义 TemplateMapEntry 类型来支持这种字典结构。\n✅ 技巧 4：调试时注意 Binding 上下文问题 常见错误： 在 SelectTemplate 中获取不到正确对象。 绑定路径错误导致无法识别类型。 解决方法： 确保绑定上下文正确 1 2 \u0026lt;ListBox ItemsSource=\u0026#34;{Binding MyItems}\u0026#34; ItemTemplateSelector=\u0026#34;{StaticResource mySelector}\u0026#34; /\u0026gt; 确保 MyItems 是 IEnumerable\u0026lt;T\u0026gt;，且每一项类型都能被识别。\n添加日志辅助调试： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public override DataTemplate SelectTemplate(object item, DependencyObject container) { if (item == null) { Debug.WriteLine(\u0026#34;Item is null\u0026#34;); return base.SelectTemplate(item, container); } Debug.WriteLine($\u0026#34;Item type: {item.GetType().Name}\u0026#34;); if (item is CustomType ct) { return ct.IsSpecial ? SpecialTemplate : NormalTemplate; } return base.SelectTemplate(item, container); } 五、总结 DataTemplateSelector 是 WPF 中非常强大且灵活的功能，它帮助我们实现了数据驱动的 UI 模板选择。无论是构建复杂的 UI 列表还是实现高度定制化的展示逻辑，DataTemplateSelector 都是一个值得掌握的技能。\n","date":"2025-05-30T14:46:48+08:00","image":"https://www.notion.so/images/page-cover/nasa_new_york_city_grid.jpg","permalink":"https://dumbnessrf.github.io/p/data-template-selector-tips/","title":"WPF技巧-数据模板动态选择"},{"content":"解锁.NET 新姿势：基于文件的程序特性深度解析与实战 在.NET 的世界里，新项目的创建和运行往往离不开.csproj项目文件，从编写代码到调试运行，需要一系列繁琐的步骤。但随着.NET 技术的不断演进，基于文件的程序（File-based programs） 这一新特性的出现，打破了这一传统模式，为开发者带来了更加便捷、高效的开发体验。\n基于文件的程序特性概述 基于文件的程序，简单来说，就是将部分 MSBuild 项目功能嵌入到 C# 代码中，允许开发者直接运行单个 C# 文件，就像运行一个完整的项目一样。在以往，运行 C# 代码通常需要先创建一个项目，编写 .csproj 文件来配置项目的各种属性，如引用的包、目标框架等。而基于文件的程序则无需这些复杂的操作，它通过在 C# 源文件中添加特殊的 #: 指令，在内存中生成一个 “虚拟项目”，然后将这个 “虚拟项目” 传递给 MSBuild 进行构建和运行。\n其背后的运行机制是：当使用 dotnet run 命令运行一个 C# 文件时，命令行会解析源文件中的 #: 指令，根据这些指令在内存中构建一个 C# 项目 XML 文档，这个文档就相当于一个常规项目的 .csproj 文件。随后，MSBuild 会基于这个内存中的项目文档进行编译和运行，使得单个文件能够像完整项目一样执行 。\n应用示例详解 示例 1：经典 Hello World 1 2 3 // HelloWorld.cs #:r \u0026#34;System.Net.Http\u0026#34; Console.WriteLine(\u0026#34;Hello, World!\u0026#34;); 在这个简单示例中，#:r \u0026quot;System.Net.Http\u0026quot; 是一个 #: 指令，它用于引用 System.Net.Http 程序集。虽然代码中没有传统的项目文件配置，但通过这条指令，我们为程序添加了所需的引用。在命令行中进入该文件所在目录，执行 dotnet run HelloWorld.cs，就能看到熟悉的 “Hello, World!” 输出。这展示了基于文件的程序最基础的运行方式，仅需一个 C# 文件和简单指令，即可快速运行代码。\n示例 2：引用外部 NuGet 包 1 2 3 4 5 6 7 8 9 10 11 12 13 // NewtonsoftJsonExample.cs #:package Newtonsoft.Json 13.0.1 using Newtonsoft.Json; class Program { static void Main() { var person = new { Name = \u0026#34;Alice\u0026#34;, Age = 30 }; var json = JsonConvert.SerializeObject(person); Console.WriteLine(json); } } 在这个示例中，#:package Newtonsoft.Json 13.0.1 指令用于引入 Newtonsoft.Json 包及其指定版本。引入后，代码中就能使用 Newtonsoft.Json 提供的功能，如将对象序列化为 JSON 字符串。运行时，dotnet run 命令会根据该指令自动下载并引用所需的 NuGet 包，无需手动在项目文件中添加包引用，极大地简化了使用外部包的流程 。\n示例 3：多文件协作 假设我们有一个简单的数学计算项目，包含两个文件：Calculator.cs 和 Program.cs。\nCalculator.cs 文件内容如下：\n1 2 3 4 5 6 7 8 9 10 11 // Calculator.cs namespace MathUtils { public static class Calculator { public static int Add(int a, int b) { return a + b; } } } Program.cs 文件内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 // Program.cs #:r \u0026#34;System.Net.Http\u0026#34; using MathUtils; class Program { static void Main() { int result = Calculator.Add(5, 3); Console.WriteLine($\u0026#34;The result of addition is: {result}\u0026#34;); } } 在基于文件的程序中，无需手动在项目文件中配置文件引用关系。当使用 dotnet run Program.cs 命令运行时，SDK CLI 会自动解析 Program.cs 所在目录树中的所有 .cs 文件，将 Calculator.cs 包含在编译过程中，使得不同文件之间能够顺利协作，实现复杂的功能 。\n与传统项目模式的对比优势 降低入门门槛\n对于初学者来说，传统的 .csproj 项目文件配置复杂，包含众多属性和节点，容易让新手感到困惑。而基于文件的程序模式，只需关注代码本身和简单的 #: 指令，无需深入了解项目文件配置，能够更快地编写和运行代码，降低了学习成本。\n快速原型开发\n在开发初期进行原型设计时，往往需要快速验证想法和功能。基于文件的程序无需创建完整项目结构，直接编写单个文件并运行，能够大大提高开发效率，快速迭代原型。\n简化小型工具开发\n对于一些简单的小型工具或脚本，使用传统项目模式显得过于繁琐。基于文件的程序可以用最少的配置和步骤实现功能，使代码更加简洁、轻便，便于维护和管理。\n使用注意事项 虽然基于文件的程序带来了诸多便利，但在使用过程中也有一些需要注意的地方：\n目前基于文件的程序在功能上还存在一定限制，例如对某些复杂的项目配置和构建自定义支持不够完善。 由于其依赖于 #: 指令来配置项目属性，指令的语法和使用规则需要开发者熟练掌握，否则可能会出现引用错误或构建失败等问题。 在团队协作开发中，基于文件的程序可能会因为成员使用不同版本的 .NET SDK 而导致运行结果不一致，需要统一开发环境。 以上就是对 .NET 基于文件的程序特性的详细介绍和应用示例。这一特性为开发者提供了更灵活高效的开发方式，无论是初学者快速上手，还是经验丰富的开发者进行快速开发，都能发挥重要作用。不妨亲自尝试，感受它带来的便捷！如果你在使用过程中有新的发现或遇到问题，欢迎一起交流探讨。\n","date":"2025-05-29T11:04:44+08:00","image":"https://www.notion.so/images/page-cover/rijksmuseum_mignons_1660.jpg","permalink":"https://dumbnessrf.github.io/p/single-file-run/","title":"单文件运行C#代码"}]