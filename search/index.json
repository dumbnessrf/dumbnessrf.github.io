[{"content":"TOML 文件在 C# 中的全面指南 适用于 .NET 开发者：从基础概念到实战应用，掌握现代配置文件格式 TOML 在 C# 项目中的使用方法。\n一、什么是 TOML？ TOML（Tom\u0026rsquo;s Obvious, Minimal Language）是一种语义明确、易于阅读和编写的配置文件格式，由 GitHub 联合创始人 Tom Preston-Werner 提出。其设计目标是成为比 JSON、YAML、INI 更直观、无歧义的配置语言。\n核心特点 ✅ 人类可读：语法简洁，结构清晰 ✅ 强类型支持：原生支持字符串、整数、布尔、日期、数组、嵌套表等 ✅ 标准化：有明确规范（toml.io），跨语言兼容 ✅ 支持注释：使用 # 添加说明 ✅ 层级结构：通过 [section] 和 [section.subsection] 实现嵌套 示例 TOML 文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 应用基本信息 title = \u0026#34;My C# Application\u0026#34; version = \u0026#34;1.0.0\u0026#34; [server] host = \u0026#34;localhost\u0026#34; port = 8080 ssl_enabled = true [database] server = \u0026#34;192.168.1.10\u0026#34; port = 5432 [database.credentials] username = \u0026#34;admin\u0026#34; password = \u0026#34;s3cr3t\u0026#34; 二、TOML 与其他配置格式对比 特性 TOML INI JSON YAML 人类可读性 ⭐⭐⭐⭐ ⭐⭐⭐ ⭐⭐ ⭐⭐⭐⭐ 支持注释 ✅（#） ✅（# 或 ;，不标准） ❌ ✅（#） 数据类型 原生支持多种类型 仅字符串 支持基本类型 支持但易出错 嵌套结构 ✅（通过表） ❌（需命名约定） ✅（对象） ✅（缩进） 标准规范 ✅（严格） ❌（各实现不一） ✅ ✅（但复杂） 缩进敏感 ❌ ❌ ❌ ✅（易错） 适合手写 ✅✅✅ ✅✅ ❌ ✅（但需小心缩进） 💡 结论：TOML 是 INI 的现代化升级版，兼具可读性与结构表达能力，特别适合应用程序配置文件。\n三、为什么在 C# 项目中使用 TOML？ 现代项目趋势：Rust（Cargo.toml）、Python（pyproject.toml）、Deno 等广泛采用 优于传统 appsettings.json：支持注释，结构更清晰，避免 JSON 的“无注释”痛点 比 XML 简洁：无需闭合标签，无命名空间复杂性 比 YAML 安全：无缩进陷阱，无类型自动推断风险 📌 典型应用场景：\n应用程序主配置文件（替代 appsettings.json） 插件/模块配置 构建脚本参数（如自定义构建工具） 游戏或桌面应用的用户设置 四、C# 中读写 TOML：使用 Tomlyn 库 .NET 官方未内置 TOML 支持，但社区库 Tomlyn 是目前最成熟、轻量、高性能的选择。\n1. 安装 通过 NuGet 安装：\n1 dotnet add package Tomlyn 或在 .csproj 中添加：\n1 \u0026lt;PackageReference Include=\u0026#34;Tomlyn\u0026#34; Version=\u0026#34;0.15.0\u0026#34; /\u0026gt; ✅ 支持 .NET Standard 2.0+，兼容 .NET Core、.NET 5/6/7/8 及 .NET Framework。\n2. 加载 TOML 文件 方式一：强类型反序列化（推荐） 适用于结构固定的配置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 using Tomlyn; public class AppConfig { public string Title { get; set; } = \u0026#34;\u0026#34;; public ServerConfig Server { get; set; } = new(); public DatabaseConfig Database { get; set; } = new(); } public class ServerConfig { public string Host { get; set; } = \u0026#34;localhost\u0026#34;; public int Port { get; set; } = 8080; public bool SslEnabled { get; set; } } public class DatabaseConfig { public string Server { get; set; } = \u0026#34;\u0026#34;; public int Port { get; set; } public DbCredentials Credentials { get; set; } = new(); } public class DbCredentials { public string Username { get; set; } = \u0026#34;\u0026#34;; public string Password { get; set; } = \u0026#34;\u0026#34;; } 加载代码：\n1 2 3 4 string toml = File.ReadAllText(\u0026#34;app.toml\u0026#34;); var config = Toml.ToObject\u0026lt;AppConfig\u0026gt;(toml); Console.WriteLine($\u0026#34;Server: {config.Server.Host}:{config.Server.Port}\u0026#34;); ✅ 自动类型转换：int、bool、嵌套对象等无需手动解析。\n方式二：动态解析（灵活但需手动处理） 适用于结构未知或临时解析。\n1 2 3 4 5 6 using Tomlyn.Model; var model = Toml.ToModel(File.ReadAllText(\u0026#34;config.toml\u0026#34;)); var server = (TomlTable)model[\u0026#34;server\u0026#34;]; string host = (string)server[\u0026#34;host\u0026#34;]; int port = (int)server[\u0026#34;port\u0026#34;]; ⚠️ 注意：需显式类型转换，嵌套需递归处理。\n3. 保存 TOML 文件 将 C# 对象序列化为 TOML 文本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 var config = new AppConfig { Title = \u0026#34;My App\u0026#34;, Server = new() { Host = \u0026#34;0.0.0.0\u0026#34;, Port = 9000, SslEnabled = false }, Database = new() { Server = \u0026#34;db.example.com\u0026#34;, Port = 5432, Credentials = new() { Username = \u0026#34;user\u0026#34;, Password = \u0026#34;pass\u0026#34; } } }; string tomlText = Toml.FromObject(config); File.WriteAllText(\u0026#34;app.toml\u0026#34;, tomlText); 输出示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 title = \u0026#34;My App\u0026#34; [server] host = \u0026#34;0.0.0.0\u0026#34; port = 9000 ssl_enabled = false [database] server = \u0026#34;db.example.com\u0026#34; port = 5432 [database.credentials] username = \u0026#34;user\u0026#34; password = \u0026#34;pass\u0026#34; 4. 高级特性 自定义字段名映射 当 TOML 键名与 C# 属性名不一致时，使用 [TomlProperty]：\n1 2 3 4 5 6 7 8 public class ServerConfig { [TomlProperty(\u0026#34;bind_address\u0026#34;)] public string Host { get; set; } = \u0026#34;\u0026#34;; [TomlProperty(\u0026#34;use_tls\u0026#34;)] public bool SslEnabled { get; set; } } 对应 TOML：\n1 2 3 [server] bind_address = \u0026#34;127.0.0.1\u0026#34; use_tls = true 数组支持 TOML：\n1 2 allowed_ips = [\u0026#34;192.168.1.1\u0026#34;, \u0026#34;10.0.0.5\u0026#34;] ports = [8080, 8081, 8082] C#：\n1 2 public List\u0026lt;string\u0026gt; AllowedIps { get; set; } = new(); public int[] Ports { get; set; } = Array.Empty\u0026lt;int\u0026gt;(); 日期时间 TOML 支持 RFC 3339 日期：\n1 created_at = 2025-10-30T14:30:00Z C#：\n1 public DateTime CreatedAt { get; set; } 五、完整工具类封装（推荐复用） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 using Tomlyn; using System.IO; /// \u0026lt;summary\u0026gt; /// TOML 配置文件读写工具类 /// \u0026lt;/summary\u0026gt; public static class TomlConfigHelper { /// \u0026lt;summary\u0026gt; /// 从文件加载 TOML 配置（强类型） /// \u0026lt;/summary\u0026gt; public static T Load\u0026lt;T\u0026gt;(string filePath) where T : new() { if (!File.Exists(filePath)) throw new FileNotFoundException($\u0026#34;TOML 配置文件不存在: {filePath}\u0026#34;); var content = File.ReadAllText(filePath); return Toml.ToObject\u0026lt;T\u0026gt;(content); } /// \u0026lt;summary\u0026gt; /// 保存配置对象到 TOML 文件 /// \u0026lt;/summary\u0026gt; public static void Save\u0026lt;T\u0026gt;(string filePath, T config) { var content = Toml.FromObject(config); Directory.CreateDirectory(Path.GetDirectoryName(filePath) ?? \u0026#34;.\u0026#34;); File.WriteAllText(filePath, content); } } 使用示例：\n1 2 3 4 5 6 7 8 9 // 首次运行：创建默认配置 if (!File.Exists(\u0026#34;config.toml\u0026#34;)) { var defaultConfig = new AppConfig { Title = \u0026#34;My App\u0026#34; }; TomlConfigHelper.Save(\u0026#34;config.toml\u0026#34;, defaultConfig); } // 加载配置 var config = TomlConfigHelper.Load\u0026lt;AppConfig\u0026gt;(\u0026#34;config.toml\u0026#34;); 六、常见问题与注意事项 问题 解决方案 属性未赋值 确保属性为 public 且有 set 访问器 类型转换异常 检查 TOML 值类型是否匹配（如 \u0026quot;8080\u0026quot; 是字符串，应写为 8080） 嵌套结构不匹配 C# 类的嵌套层级必须与 TOML 表结构一致 中文乱码 保存 TOML 文件时使用 UTF-8 编码（File.WriteAllText 默认 UTF-8） 注释丢失 Tomlyn 不保留注释（符合 TOML 规范），如需保留注释需用其他方案 ⚠️ TOML 规范要求：键名区分大小写，字符串建议用双引号（虽然部分值可无引号，但为安全起见推荐显式使用）。\n七、与其他 .NET 配置系统的集成（可选） 虽然 TOML 不能直接用于 Microsoft.Extensions.Configuration（如 ASP.NET Core 的 IConfiguration），但可通过自定义 ConfigurationProvider 实现集成。\n🔧 如有需要，可基于 Tomlyn 实现 TomlConfigurationProvider，将 TOML 文件纳入标准配置管道。\n八、总结 优势 说明 简洁直观 比 JSON 更易读，比 YAML 更安全 类型安全 原生支持多种数据类型，减少解析错误 现代标准 被 Rust、Python 等主流生态广泛采用 C# 支持完善 Tomlyn 库成熟、轻量、高性能 ✅ 推荐在以下场景使用 TOML：\n桌面应用、控制台工具、游戏等需要用户可编辑配置的项目 替代 appsettings.json 以支持注释和更清晰结构 构建系统、CI/CD 脚本中的参数配置 附录：参考资料 TOML 官方规范 Tomlyn GitHub 仓库 NuGet: Tomlyn 📝 作者建议：对于新项目，优先考虑 TOML 作为配置格式；对于现有项目，可在非核心模块中逐步引入，体验其简洁与强大。\n","date":"2025-10-30T09:49:41+08:00","image":"https://images.unsplash.com/photo-1563387852576-964bc31b73af?ixlib=rb-4.1.0\u0026q=85\u0026fm=jpg\u0026crop=entropy\u0026cs=srgb\u0026w=6000","permalink":"https://dumbnessrf.github.io/p/what_is_toml/","title":"什么是Toml"},{"content":"🚀 用 Channel 替代 BlockingCollection —— .NET 6+ 现代并发数据流 更轻量、更高效、更函数式、更现代化的生产者-消费者模型\n📌 为什么需要 Channel？ 虽然 BlockingCollection\u0026lt;T\u0026gt; 功能强大，但在 .NET 6+ 时代，微软推荐使用 System.Threading.Channels 中的 Channel\u0026lt;T\u0026gt; 来构建高性能、异步优先的生产者-消费者管道。\n❗ BlockingCollection\u0026lt;T\u0026gt; 的局限： 基于 Task + 阻塞 API（如 Take()），在高并发下可能阻塞线程 不原生支持 async/await 流式消费 无法与 IAsyncEnumerable\u0026lt;T\u0026gt; 无缝集成 无背压（backpressure）控制（除非手动配合信号量） ✅ Channel\u0026lt;T\u0026gt; 的优势： ✔️ 原生异步支持（ReadAsync / WaitToReadAsync） ✔️ 支持 IAsyncEnumerable\u0026lt;T\u0026gt;（channel.Reader.ReadAllAsync()） ✔️ 更细粒度的读写分离（ChannelReader\u0026lt;T\u0026gt; / ChannelWriter\u0026lt;T\u0026gt;） ✔️ 内置背压支持（Bounded Channel 自动阻塞写入） ✔️ 零分配优化、高性能、低延迟 ✔️ 与现代 .NET 生态（如 ASP.NET Core、Minimal API、BackgroundService）完美集成 🧩 一、Channel 基础用法 1. 创建 Channel 1 2 3 4 5 6 7 8 // 无界通道（类似 BlockingCollection 无容量限制） var channel = Channel.CreateUnbounded\u0026lt;int\u0026gt;(); // 有界通道（容量=10，写满自动阻塞/丢弃/覆盖 — 可配置） var boundedChannel = Channel.CreateBounded\u0026lt;int\u0026gt;(new BoundedChannelOptions(10) { FullMode = BoundedChannelFullMode.Wait // 默认行为：写满时等待 }); 2. 生产者写入 1 2 3 4 5 6 var writer = channel.Writer; await writer.WriteAsync(1); await writer.WriteAsync(2); writer.Complete(); // 标记完成写入 3. 消费者读取 1 2 3 4 5 6 7 8 9 var reader = channel.Reader; while (await reader.WaitToReadAsync()) { while (reader.TryRead(out var item)) { Console.WriteLine($\u0026#34;消费: {item}\u0026#34;); } } 或使用 IAsyncEnumerable\u0026lt;T\u0026gt;：\n1 2 3 4 await foreach (var item in channel.Reader.ReadAllAsync()) { Console.WriteLine($\u0026#34;消费: {item}\u0026#34;); } ✅ 完整示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 using System.Threading.Channels; var channel = Channel.CreateBounded\u0026lt;int\u0026gt;(10); // 生产者 _ = Task.Run(async () =\u0026gt; { for (int i = 1; i \u0026lt;= 20; i++) { await channel.Writer.WriteAsync(i); Console.WriteLine($\u0026#34;生产: {i}\u0026#34;); await Task.Delay(100); } channel.Writer.Complete(); }); // 消费者 await foreach (var item in channel.Reader.ReadAllAsync()) { Console.WriteLine($\u0026#34;消费: {item}\u0026#34;); await Task.Delay(200); } 🔄 二、Channel vs BlockingCollection 对比 特性 BlockingCollection\u0026lt;T\u0026gt; Channel\u0026lt;T\u0026gt; 异步支持 ❌（需包装 Task.Run） ✅ 原生异步 流式消费 ❌（foreach 阻塞） ✅ IAsyncEnumerable\u0026lt;T\u0026gt; 背压控制 ⚠️ 需手动配合信号量 ✅ 内置（BoundedChannel） 性能 ⚠️ 中等（有锁开销） ✅ 更高（优化无锁结构） 读写分离 ❌ ✅ ChannelReader/Writer 取消支持 ⚠️ 有限 ✅ 原生支持 CancellationToken .NET 现代生态集成 ⚠️ 旧式 ✅ 推荐（.NET 6+） 🎯 三、实战：用 Channel 改写任务调度器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 public class ChannelTaskScheduler\u0026lt;T\u0026gt; { private readonly Channel\u0026lt;Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt;\u0026gt; _channel; private readonly SemaphoreSlim _semaphore; private readonly ILogger _logger; public ChannelTaskScheduler(int maxConcurrency, int? boundedCapacity = null, ILogger logger = null) { _channel = boundedCapacity.HasValue ? Channel.CreateBounded\u0026lt;Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt;\u0026gt;(boundedCapacity.Value) : Channel.CreateUnbounded\u0026lt;Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt;\u0026gt;(); _semaphore = new SemaphoreSlim(maxConcurrency, maxConcurrency); _logger = logger; } public async ValueTask\u0026lt;bool\u0026gt; QueueTaskAsync(Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt; task, CancellationToken ct = default) { return await _channel.Writer.WriteAsync(task, ct); } public async Task StartAsync(CancellationToken ct = default) { await foreach (var workItem in _channel.Reader.ReadAllAsync(ct)) { _ = ExecuteWithLimit(workItem, ct); // 并发执行，不等待 } } private async Task ExecuteWithLimit(Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt; workItem, CancellationToken ct) { await _semaphore.WaitAsync(ct); try { await workItem(); } catch (Exception ex) { _logger?.LogError(ex, \u0026#34;任务执行异常\u0026#34;); } finally { _semaphore.Release(); } } public async Task CompleteAsync(CancellationToken ct = default) { _channel.Writer.Complete(); // 可选：等待所有任务完成 // await foreach (var _ in _channel.Reader.ReadAllAsync(ct)) { } } } 使用示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 var scheduler = new ChannelTaskScheduler\u0026lt;string\u0026gt;(maxConcurrency: 3, boundedCapacity: 10, logger); for (int i = 1; i \u0026lt;= 20; i++) { var taskId = i; await scheduler.QueueTaskAsync(() =\u0026gt; Task.Run(async () =\u0026gt; { await Task.Delay(500); return $\u0026#34;任务 {taskId} 完成\u0026#34;; })); } await scheduler.StartAsync(); ⚙️ 四、高级特性 1. 背压策略（BoundedChannelFullMode） 1 2 3 4 5 6 7 8 9 10 var options = new BoundedChannelOptions(10) { FullMode = BoundedChannelFullMode.Wait, // 默认：写满等待 // FullMode = BoundedChannelFullMode.DropWrite, // 丢弃最新写入 // FullMode = BoundedChannelFullMode.DropOldest, // 丢弃最旧数据 // FullMode = BoundedChannelFullMode.DropNewest, // 丢弃最新数据 AllowSynchronousContinuations = false, // 避免同步延续（推荐 false） SingleReader = false, // 是否单消费者 SingleWriter = false // 是否单生产者 }; 2. 单生产者/单消费者优化 如果你能保证只有一个线程写入或读取，启用 SingleWriter = true 或 SingleReader = true，性能更佳！\n3. 取消支持 1 2 3 4 5 6 CancellationTokenSource cts = new(TimeSpan.FromSeconds(5)); await foreach (var item in channel.Reader.ReadAllAsync(cts.Token)) { // ... } 📝 五、最佳实践 场景 推荐方案 新项目 / .NET 6+ ✅ 优先使用 Channel\u0026lt;T\u0026gt; 需要异步流 / IAsyncEnumerable ✅ Channel\u0026lt;T\u0026gt; 需要背压控制 ✅ BoundedChannel\u0026lt;T\u0026gt; 遗留系统兼容 ⚠️ 可继续使用 BlockingCollection\u0026lt;T\u0026gt; 高性能低延迟场景 ✅ Channel\u0026lt;T\u0026gt; + SingleWriter/Reader ✅ 结语 Channel\u0026lt;T\u0026gt; 是 .NET 现代并发编程的“标准答案”，它：\n更符合异步编程模型 性能更优 功能更丰富 生态更现代 是时候用 Channel\u0026lt;T\u0026gt; 替代 BlockingCollection\u0026lt;T\u0026gt; 了！\n","date":"2025-09-15T21:08:09+08:00","image":"https://www.notion.so/images/page-cover/rijksmuseum_rembrandt_1642.jpg","permalink":"https://dumbnessrf.github.io/p/parallel_programing_modern/","title":"Parallel Programing Modern"},{"content":" 🧠 深度学习模型超参数配置指南（分类：目标检测、语义分割、异常检测、Deep OCR） 本指南对主流深度学习任务中的关键超参数进行系统性总结与分析，涵盖目标检测、语义分割、通用异常检测（GC-AD）和 Deep OCR 四大类别，旨在帮助用户合理配置模型以平衡性能、速度与资源消耗。\n1️⃣ 目标检测（Object Detection） 目标检测模型通常基于特征金字塔网络（FPN），通过多尺度特征图检测不同尺寸物体。关键参数如下：\n参数 描述 建议与影响 容量\n（Capacity） 网络深层部分的参数数量 - 高：更强表达力，适合复杂场景\n- 中/低：提升推理速度，适合轻量部署\n- 注意：简单任务中“低容量”可能达到与“高容量”相当的精度 最小级别\n（Min Level） 特征金字塔最低层级（最小下采样倍数） - 0 = 原图大小特征图\n- 越小越能检测小物体\n- 增加低级别会显著↑内存与计算开销 最大级别\n（Max Level） 特征金字塔最高层级（最大下采样倍数） - 越大越能检测大物体\n- 通常与最小级别共同决定特征金字塔宽度：\n层数 = MaxLevel - MinLevel + 1 子尺度锚数量 每个特征级别上使用的锚框尺寸种类数 - 更多尺寸 → 更好适配物体形状\n- ↑锚数量 → ↑训练时间、内存、计算负载 锚长宽比\n（Aspect Ratio） 锚框高度:宽度比例（如 1:1, 1:2, 2:1） - 多种比例提升定位精度（尤其非正方形物体）\n- 比例越多 → 锚总数↑ → 训练更慢 锚角度 [°]\n（仅自由矩形） 锚框相对于水平轴的旋转角度 - 支持倾斜/旋转物体检测（如文字、车辆）\n- 角度范围：(-90°, 90°]\n- 增加角度多样性 → ↑锚数量 \u0026amp; ↑计算负担 忽略方向 是否将不同朝向的矩形视为同一类 - ✅选中：仅考虑位置，忽略旋转\n- ❌不选：区分不同朝向（需配合锚角度） 权重先验 (α)\n（Weight Prior） L2 正则化强度，防止过拟合 - 初始值建议：0.00001\n- 若出现过拟合（验证集性能下降）→ 逐步增大（如 0.0001, 0.001） 边界框头部权重 BBox 回归损失在总损失中的权重系数 - 控制定位精度 vs 分类精度的平衡\n- 若定位不准 → 增大此值 类别头部权重 分类损失在总损失中的权重系数 - 类别不平衡时可调高\n- 默认常设为 1.0，根据训练表现微调 冻结骨干级别 训练时冻结骨干网络的最高层级 - 0：不冻结任何层（全训练）\n- n：冻结第 n 层及以上（从输入端算起）\n- ✅适用场景：\n• 骨干未预训练\n• 输入通道变化（如红外图像）\n• 数据量少，避免过拟合 💡 提示：特征金字塔级别选择应匹配目标尺寸分布。例如：\n小物体为主 → 设 MinLevel=0, MaxLevel=4 大物体为主 → 设 MinLevel=2, MaxLevel=5 2️⃣ 语义分割（Semantic Segmentation） 语义分割模型通常使用 U-Net、DeepLab 等架构，输出像素级类别掩码。\n参数 描述 建议与影响 遮罩头部权重\n（Mask Head Weight） 掩码预测损失在总损失中的权重系数 - 控制分割精度 vs 分类精度的权衡\n- 若边缘模糊或分割不准确 → 增大该值\n- 通常与分类头权重协同调整 ⚠️ 注意：此处“分类头部权重”应为笔误，语义分割中应为“遮罩头部权重”。\n3️⃣ 通用异常检测（GC-AD, Generalized Anomaly Detection） GC-AD 是一种双分支异常检测框架，包含全局子网与局部子网，支持三种模式。\n模式 描述 应用场景 建议 GC-AD 全局 仅使用全局子网 检测大面积、整体性异常（如污渍、褪色、整体变形）\n擅长识别逻辑异常（如缺失部件、错误布局） ✅ 建议启用图像增强（如亮度、对比度扰动） GC-AD 本地 仅使用局部子网 检测局部缺陷（如划痕、孔洞、裂纹）\n擅长结构异常（纹理/形状变化） 补丁大小需覆盖典型缺陷区域 GC-AD 结合 同时使用全局 + 本地子网 最全面方案，兼顾全局逻辑异常与局部结构异常 ✅ 强烈推荐用于工业质检\n✅ 对全局子网启用增强 🔍 关键参数：补丁大小（Patch Size） 参数 描述 建议 补丁大小 局部子网处理的图像块尺寸（W×H） - 必须 ≤ 图像宽高\n- 应确保：有缺陷补丁 与 无缺陷补丁 在特征空间明显可分\n- 不需要完全覆盖缺陷，只需包含足够判别信息\n- 若图像尺寸变化，必须同步调整补丁大小 💡 示例：检测 PCB 上 5×5mm 的焊点缺失 → 补丁大小设为 64×64 像素（假设原图 1024×1024）\n4️⃣ Deep OCR（光学字符识别） Deep OCR 由两个独立模型组成，需分别训练与评估：\n组件 说明 检测模型 定位图像中文本区域（Bounding Box / Polygon）\n可自定义训练（如使用 DBNet、EAST） 识别模型 将检测到的文本区域转为字符序列\n⚠️ 仅提供预训练模型，不可自定义训练结构 📌 训练限制与注意事项 项目 说明 识别模型训练 ❌ 仅支持使用官方预训练模型\n✅ 不支持从头训练或微调结构 训练设备 识别模型必须在 GPU 上运行，CPU 不支持 训练流程 1. 训练检测模型 → 2. 使用检测结果生成裁剪文本图像 → 3. 使用预训练识别模型进行推理 数据要求 高质量标注文本框 + 字符标签，建议多样化字体、背景、光照条件 ✅ 推荐流程：\n原始图像 → 检测模型 → 文本裁剪 → 预训练识别模型 → 输出文本\n📊 通用建议：类别权重（Class Weights） 场景 建议 类别分布不均\n（如 95% 为正常，5% 为缺陷） ❌ 不推荐直接使用 自定义类别权重 平衡样本比例 ✅ 更优方案 ➤ 增加少数类样本采集\n➤ 数据增强（翻转、缩放、噪声注入）\n➤ 使用 Focal Loss 或 OHEM（在线难例挖掘） 仅在必要时使用类别权重 如无法增加数据量，且模型严重偏向多数类 → 可尝试设置 weight = 1 / class_freq ✅ 总结：参数调优策略速查表 目标 推荐操作 提升小物体检测能力 ↓ MinLevel，↑ 子尺度锚数量，↑ 锚长宽比 加速推理 ↓ 容量，↑ MinLevel，↓ 锚角度数量，↓ 特征级别数 减少过拟合 ↑ 权重先验 α，冻结骨干层，数据增强 改善分割边缘 ↑ 遮罩头部权重，使用 Dice Loss 或 IoU Loss 检测局部缺陷 使用 GC-AD 本地模式，优化补丁大小 检测全局异常 使用 GC-AD 全局 + 增强 OCR 项目 分离训练检测与识别；识别仅用预训练模型；GPU 必须 📘 参考资料 HALCON 算子参考：get_dl_model_param 相关论文：FPN (Lin et al., CVPR 2017), RetinaNet (Lin et al., ICCV 2017), DeepLabv3+, DBNet 实践建议：优先通过数据增强与样本扩充解决不平衡，而非依赖权重调整 🔍 目标检测超参数深度解析（逐项详解） 本节基于特征金字塔网络（FPN）架构，适用于如 RetinaNet、Faster R-CNN + FPN、YOLO-FPN 等多尺度检测模型。所有参数均围绕“锚框（Anchor）+ 多级特征图”机制展开。\n1. 容量（Capacity） ✅ 定义： 网络深层部分（通常指特征提取器后端、分类/回归头）的参数总量，反映模型的表达能力。\n📌 本质： 并非直接设置层数，而是控制“网络宽度”或“通道数”。 在 HALCON 或类似工具中，可能对应： backbone_type = \u0026quot;resnet50\u0026quot; vs \u0026quot;resnet101\u0026quot; head_channels = 256 vs 512 是否启用 dilated conv、SE block、CBAM 等增强模块 ⚙️ 工作机制： 容量等级 参数量估算（典型） 特征 低 ~1M–3M 轻量化头（如 64~128 通道），适合嵌入式设备 中 ~5M–10M 平衡方案，工业常用（如 YOLOv5s） 高 \u0026gt;15M 高分辨率特征、宽卷积核、密集连接，适合复杂背景 💡 实际影响： 场景 推荐容量 原因 工业质检（小目标、高精度） 中 → 高 需要强特征提取能力区分细微缺陷 实时视觉引导（机器人） 低 → 中 限制推理延迟（\u0026lt;50ms） 遥感图像（大场景、多类） 高 对象尺寸差异极大，需强大表征力 数据量少（\u0026lt;1k 图像） 低 防止过拟合 🔧 调优建议： 从“中”开始，观察验证集 mAP； 若 mAP 达到平台上限但速度慢 → 降为“低”； 若 mAP 不足且损失震荡 → 升为“高” + 加入正则化（Dropout、权重先验）； 注意：在简单任务（如仅检测红绿灯）中，“低容量”常可媲美“高容量”。 2. 最小级别（Min Level） ✅ 定义： 特征金字塔中最底层（最精细）的特征图层级编号，代表最小下采样倍数。\n📌 数学定义： 输入图像大小：H × W 第 l 级特征图尺寸：H / 2^l × W / 2^l Min Level = 0 → 特征图尺寸 = 原图（无下采样） Min Level = 2 → 特征图尺寸 = 原图 1/4 ⚙️ 工作机制： Min Level 特征图尺寸（原图 640×640） 检测对象尺度 内存开销 0 640×640 极小物体（\u0026lt;10px） ⚠️ 极高 1 320×320 小物体（10–30px） 高 2 160×160 中等物体（30–80px） 中 3 80×80 大物体（\u0026gt;80px） 低 💡 实际影响： 设为 0：能检测像素级目标（如芯片焊点、微小裂纹），但： 计算量剧增（特征图大） 易受噪声干扰 需要更强的骨干网络支持 设为 2 或更高：牺牲小物体检测能力，换取速度和稳定性。 🔧 调优建议： 应用场景 推荐 MinLevel 说明 微电子检测、细胞识别 0 或 1 必须保留原始分辨率信息 自动驾驶（车辆、行人） 2 主流选择，平衡性能与效率 大型工厂巡检（机械臂） 3 物体大，无需高分辨率 注意 ❗若 MinLevel=0，必须配合高容量 + 正则化，否则训练不稳定 3. 最大级别（Max Level） ✅ 定义： 特征金字塔中最顶层（最粗略）的特征图层级编号，代表最大下采样倍数。\n📌 数学定义： Max Level = 5 → 特征图尺寸 = 原图 1/32 通常与 Min Level 共同决定金字塔层数：\nL = MaxLevel - MinLevel + 1 ⚙️ 工作机制： Max Level 特征图尺寸（640×640） 检测对象尺度 适用性 3 80×80 ≤ 256px 一般场景 4 40×40 ≤ 512px 大型物体（卡车、建筑） 5 20×20 ≤ 1024px 航拍、遥感图像 💡 实际影响： 过高（如 MaxLevel=6）： 可检测超大目标（如整栋楼） 但特征过于稀疏 → 小物体丢失、定位不准 内存占用翻倍，训练变慢 过低（如 MaxLevel=3）： 大物体被压缩成几个像素 → 检测失败（漏检） 🔧 调优建议： 应用场景 推荐 MaxLevel 说明 手机屏幕缺陷检测 3 物体小，无需高层 无人机航拍作物监测 5 检测大面积农田、道路 工业流水线（产品尺寸固定） 4 根据产品最大尺寸设定 通用建议 MaxLevel - MinLevel ∈ [3, 5] 层数太少 → 多尺度不足；太多 → 无效冗余 ✅ 最佳实践：MinLevel 和 MaxLevel 的差值应 ≥ 3，以保证至少 4 级特征用于多尺度检测。\n4. 子尺度锚数量（Number of Scales per Level） ✅ 定义： 在每个特征层级上，生成的不同尺寸锚框（anchor scales）的数量。\n📌 示例： 设置为 3 → 每个位置生成 3 个不同面积的锚框： scale = [0.5, 1.0, 2.0] × 基础面积 常见基础面积：32², 64², 128²（取决于特征图 stride） ⚙️ 工作机制： 锚数量 锚尺寸分布 效果 1 固定尺寸 快，但适配性差（如只检测正方形） 3 小、中、大 ✅ 标准配置，覆盖大多数形状 5+ 细粒度缩放 更好适配不规则物体（如长条形、扭曲目标） 💡 实际影响： ↑ 锚数量 → ↑ 匹配率 → ↑ 召回率（Recall） 但同时： 锚总数 = L × H × W × N_scales × N_ratios 训练时间 ↑，显存消耗 ↑，负样本激增 → 需更强难例挖掘 🔧 调优建议： 场景 推荐值 说明 标准目标（人、车、动物） 3 默认推荐 异形物体（电路板走线、文字、细长零件） 5 提升对极端长宽比的覆盖 实时系统（嵌入式） 2 减少计算负担 注意 若使用 自适应锚框（如 K-Means 聚类）→ 可省略此参数 ✅ 建议结合“锚长宽比”共同优化：\n如：scales=[0.5,1,2] + ratios=[0.5,1,2] → 总锚数 = 3×3=9 个/位置\n5. 锚长宽比（Aspect Ratio） ✅ 定义： 锚框的高度与宽度之比（Height:Width），决定锚的形状。\n📌 常见值： [1.0] → 正方形 [0.5, 1.0, 2.0] → 竖长、正方、横长 [0.3, 0.5, 1.0, 2.0, 3.0] → 极端比例（用于文字、电线、裂缝） ⚙️ 工作机制： 每个锚框由 (scale, ratio) 组合生成 若 scales=3, ratios=5 → 每个特征点生成 3×5=15 个锚框 💡 实际影响： 比例多样性 优点 缺点 少（1~2种） 快速、稳定 对非正方形物体召回率低 多（≥4种） 高召回率，尤其对细长目标 训练慢、易产生大量无效负样本 🔧 调优建议： 目标类型 推荐 Aspect Ratios 说明 人脸、车辆 [0.7, 1.0, 1.3] 接近正方形 文字行、导线、裂缝 [0.2, 0.5, 1.0, 2.0, 5.0] 必须覆盖极长形状 PCB 元件 [0.4, 0.8, 1.0, 1.5, 2.5] 长方形 IC、电容、电阻 通用建议 使用 K-Means 聚类你的标注框，得到最优 ratio 分布 👉 推荐工具：coco_anchors.py 或 labelme2kmeans ✅ 技巧：在训练前可视化真实框的长宽比分布，匹配锚比例！\n6. 锚角度 [°]（Anchor Angle）——仅限自由矩形（Oriented Bounding Box） ✅ 定义： 锚框相对于水平轴的旋转角度（数学正方向，逆时针），用于检测倾斜目标。\n📌 范围： 合法范围：(-90°, 90°] 常见离散取值：[-45°, 0°, 45°] 或 [-60°, -30°, 0°, 30°, 60°] ⚙️ 工作机制： 传统锚是轴对齐矩形（Axis-Aligned） 自由矩形锚 是旋转矩形（RBox），有中心点 (x,y)、宽 w、高 h、角度 θ 每个角度值独立生成一组锚框 💡 实际影响： 角度数量 优势 劣势 1（0°） 快，稳定 无法检测斜向文字、倾斜车辆 3（-45°, 0°, 45°） 覆盖常见倾斜 仍漏检 ±75° 目标 5~9 极高召回率（如 OCR、航空影像） 计算量 ×5~9，训练极慢 🔧 调优建议： 应用 推荐角度集合 说明 文字检测（自然场景） [-45°, 0°, 45°] 90% 文本在此范围内 无人机航拍车辆 [-60°, -30°, 0°, 30°, 60°] 车辆朝向多样 PCB 元件放置 [-15°, 0°, 15°] 精度要求高，角度变化小 注意 ✅ 启用角度时，必须关闭“忽略方向” ❌ 否则角度失去意义 ⚠️ 重要：锚角度 ≠ 模型预测角度\n锚角度是“先验”，用于匹配真实框 模型最终输出的是偏移量 Δθ，通过回归学习修正 7. 忽略方向（Ignore Orientation） ✅ 定义： 是否将不同旋转角度的矩形视为同一个目标（即不区分朝向）。\n⚙️ 工作机制： 开启（✅）：无论锚框角度是多少，只要中心、宽高一致 → 视为同一候选框 关闭（❌）：每个角度独立匹配真实框，训练更复杂 💡 实际影响： 开启 关闭 ✅ 减少锚数量（提升速度） ❌ 增加锚数量（降低速度） ✅ 适用于轴对齐目标（如普通矩形） ❌ 必须用于倾斜目标（如旋转文字、飞机） ✅ 可与“锚角度”共存，但角度无意义 ❌ 必须启用锚角度才有意义 🔧 调优建议： 场景 推荐设置 检测书本、包装盒、标准零件 ✅ 开启 检测倾斜文字、旋转车牌、风力叶片 ❌ 关闭 + 设置多个锚角度 不确定？ 先关闭，训练观察是否出现大量“错位检测” → 再决定是否开启 ✅ 最佳实践：如果真实标注框包含角度字段（θ），则必须关闭“忽略方向”。\n8. 权重先验（Weight Prior, α） ✅ 定义： L2 正则化系数（λ），用于惩罚模型权重过大，防止过拟合。\n📌 数学形式： 1 Loss_total = Loss_detection + α * ||W||₂² 其中 W 是网络所有可训练参数。\n⚙️ 工作机制： α 越大 → 权重越趋近于 0 → 模型越“简单” 类似于“模型压缩”或“早停”的正则化手段 💡 实际影响： α 值 效果 0.00001 极弱正则 → 易过拟合（数据少时明显） 0.0001 标准值，推荐起点 0.001 强正则 → 模型欠拟合风险 ↑ 0.01 极强 → 模型几乎无法学习 🔧 调优建议： 数据情况 推荐 α 行动 数据量 \u0026gt; 5k 图像 0.0001 默认 数据量 \u0026lt; 1k 图像 0.0005 ~ 0.001 防止记忆噪声 验证 loss 下降但 mAP 不升 ↑ α（尝试 0.0003 → 0.001） 训练 loss 高、收敛慢 ↓ α（尝试 0.00001） 使用预训练骨干 可适当降低 α（如 0.00005） ✅ 技巧：监控 weight_norm 曲线 —— 若权重持续增大且 loss 波动 → 增大 α\n9. 边界框头部权重（BBox Head Weight） ✅ 定义： 在总损失函数中，边界框回归损失所占的比重。\n📌 总损失公式示例： 1 Total Loss = λ_cls * Loss_cls + λ_bbox * Loss_bbox ⚙️ 工作机制： Loss_bbox 通常是 Smooth L1 或 IoU Loss 若 λ_bbox 太小 → 模型只关心分类，定位不准 若 λ_bbox 太大 → 模型过度拟合框坐标，忽略类别 💡 实际影响： λ_bbox 模型行为 0.1 分类主导，框很粗糙 1.0 平衡（默认） 2.0 框非常精准，但可能误检（置信度低的框被激活） 5.0 过拟合边界，泛化差 🔧 调优建议： 问题现象 解决方案 检测框偏移严重 ↑ λ_bbox（如 1.5 → 2.0） 检测框很准但漏检多 ↓ λ_bbox，↑ λ_cls 分类准确但框不准 ↑ λ_bbox 框准但分类错乱 ↓ λ_bbox，检查类别权重 ✅ 建议：优先使用 IoU-based Loss（GIoU/DIoU），其天然与位置相关，可减少对 λ_bbox 的依赖。\n10. 类别头部权重（Class Head Weight） ✅ 定义： 在总损失函数中，分类损失所占的比重。\n📌 与上一项协同工作： 控制“分类 vs 定位”的训练优先级 💡 实际影响： λ_cls 效果 0.1 模型不关心类别，全判为一类（退化为分割） 1.0 默认均衡 2.0 模型努力分清类别，但可能忽略定位 5.0 过拟合类别，导致高置信度误检 🔧 调优建议： 问题现象 解决方案 分类错误多（把猫当狗） ↑ λ_cls 检测框准但标签错 ↑ λ_cls 类别不平衡（90% 正常） 结合 自定义类别权重，而非单纯调 λ_cls 注意 λ_cls 与 自定义类别权重 是两个独立机制：\n• λ_cls：控制分类损失的整体权重\n• 类别权重：控制每个类别的损失贡献 11. 冻结骨干级别（Freeze Backbone Level） ✅ 定义： 在训练过程中，从输入端起，冻结骨干网络（Backbone）的最高层级编号。\n📌 举例： 骨干结构：conv1 → layer1 → layer2 → layer3 → layer4 Freeze Backbone Level = 2 → 冻结 layer2 及以上层（即 layer2, layer3, layer4） Freeze Backbone Level = 0 → 不冻结任何层（全训练） ⚙️ 工作机制： 冻结层：权重不变，梯度不反传 未冻结层：正常更新 💡 实际影响： 设置 适用场景 风险 0 数据充足、从零训练、输入通道变化 易过拟合、训练慢 1~3 预训练模型 + 微调、数据量中等 ✅ 推荐！ 4+（接近顶层） 仅训练检测头 模型表达力受限，性能下降 全部冻结 推理阶段 训练时不可用 🔧 调优建议： 场景 推荐冻结级别 说明 使用 ImageNet 预训练模型 2 或 3 保留高层语义，微调浅层适应新数据 输入通道不同（如红外图） 0 必须重新训练全部权重 数据极少（\u0026lt;500 图） 3 仅训练检测头，避免灾难性遗忘 预训练模型与当前任务差异大 0 重新初始化并训练 注意 ❗冻结后，必须使用更低的学习率（如 1e-5）训练检测头 ✅ 最佳实践：\n“冻结骨干 + 检测头单独学习率” 是工业界标准做法！\n✅ 总结：目标检测参数调优终极 Checklist 参数 推荐初始值 调优方向 关键影响 容量 中 ↑ 用于复杂/小目标，↓ 用于实时 表达能力 Min Level 2 ↓ 用于小物体，↑ 用于加速 小物体检测能力 Max Level 5 ↑ 用于大物体，↓ 用于轻量 大物体覆盖 子尺度锚数 3 ↑ 用于异形目标 锚覆盖密度 锚长宽比 [0.5,1,2] 根据真实框聚类调整 形状适配性 锚角度 [-45°, 0°, 45°] 仅用于倾斜目标 旋转鲁棒性 忽略方向 ❌ 关闭 仅当目标无朝向时开启 锚数量控制 权重先验 α 0.0001 ↑ 防过拟合，↓ 防欠拟合 正则强度 BBox 权重 1.0 ↑ 如果框不准 定位精度 Class 权重 1.0 ↑ 如果分类错多 分类准确性 冻结骨干 2（预训练） 数据少时 ↑，数据多时 0 训练稳定性 📌 附：调试流程建议（实战指南） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 graph TD A[开始训练] --\u0026gt; B{验证集 mAP 是否达标？} B -- 否 --\u0026gt; C[检查 Min/Max Level 是否覆盖目标尺寸] C --\u0026gt; D[增加子尺度锚或长宽比] D --\u0026gt; E[检查是否漏检小/大物体] E --\u0026gt; F[调整 MinLevel/MaxLevel] F --\u0026gt; B B -- 是 --\u0026gt; G{是否够快？} G -- 否 --\u0026gt; H[降低容量 / 增大 MinLevel / 减少锚数] H --\u0026gt; I[重新评估 mAP] I --\u0026gt; B G -- 是 --\u0026gt; J{是否有过拟合？} J -- 是 --\u0026gt; K[增大权重先验 α / 冻结骨干] K --\u0026gt; L[降低学习率] L --\u0026gt; B J -- 否 --\u0026gt; M[完成！部署] 🔍 锚（Anchor）到底是什么？——深度详解 ✅ 一句话定义：\n锚（Anchor）是目标检测模型在特征图上预设的、固定大小和形状的“参考框”，用于指导模型预测真实物体的位置与类别。\n它不是真实存在的物体边界框，而是模型学习的“先验假设” —— 像是给模型提供一组“候选模板”，让模型只需学习“如何调整这些模板”，而不是从零开始猜一个框。\n🧩 一、锚的起源：为什么需要 Anchor？ ❓ 问题背景： 在目标检测中，模型需要输出图像中每个目标的：\n位置：矩形框 (x, y, w, h) 类别：如“人”、“车”、“缺陷” 但直接预测任意位置、任意尺寸的矩形框是极其困难的，因为：\n挑战 说明 空间巨大 一张 640×640 图像，可能的矩形数量 ≈ 10⁹ 个 尺寸多样 物体可大可小（从几像素到整图） 形状各异 正方形、长条形、倾斜的…… → 如果让模型直接回归任意框，训练会不稳定、收敛慢、精度差。\n✅ 解决方案：引入 Anchor 让模型不要从零生成框，而是基于一组预设的“模板框”做微调。\n就像你给一个孩子看 10 种不同大小和形状的“盒子样板”，然后说：“你看到的东西，一定是这 10 种之一的变形。”\n这就是 Anchor 的思想。\n📐 二、Anchor 的结构组成 一个 Anchor 是一个轴对齐的矩形（除非使用旋转锚），由以下参数定义：\n参数 含义 示例值 中心点 (cx, cy) 在特征图上的位置坐标 如 (50, 70) 宽度 (w) 锚框的宽（像素或相对尺度） 32px 高度 (h) 锚框的高 32px 长宽比 (aspect ratio) h : w 1:1, 1:2, 2:1 尺度 (scale) 相对于基础尺寸的缩放倍数 0.5×, 1.0×, 2.0× 角度 (θ) （仅自由矩形）相对于水平轴的旋转角 -45°, 0°, +45° 💡 注意：Anchor 不是图像中的真实框，它是在特征图网格上密集生成的虚拟框。\n🌐 三、Anchor 如何生成？——以 FPN 为例 我们以典型的 RetinaNet + FPN 架构为例：\n步骤 1：提取多级特征图 输入图像 → 骨干网络（如 ResNet）→ 输出多个层级的特征图：\n特征级别 下采样倍数 特征图尺寸（640×640 输入） P3 ×8 80 × 80 P4 ×16 40 × 40 P5 ×32 20 × 20 每一层对应不同尺度的目标：P3 检测小物体，P5 检测大物体。\n步骤 2：在每个特征点上生成多个 Anchor 每个特征图单元（cell）代表原图的一个区域（如 P3 上每个 cell = 8×8 像素） 在每个 cell 中，生成 N_scales × N_ratios 个 Anchor ✅ 示例配置： 1 2 3 scales = [0.5, 1.0, 2.0] # 3 种尺寸 ratios = [0.5, 1.0, 2.0] # 3 种长宽比 → 每个特征点生成 3 × 3 = 9 个 Anchor 🖼️ 可视化效果（一个特征点）： 1 2 3 4 5 6 7 ▲ │ ■■■■■■ ← 宽高比=2:1（横向长） │ ■■■■■■■■ ← 宽高比=1:1（正方形） │ ■■■■ ← 宽高比=1:2（竖向长） │ └───────────────► 三种尺度（小、中、大）各一套 每个 Anchor 都有一个对应的“基尺寸”（比如 32×32），再乘以 scale 和 ratio 得到最终尺寸。\n步骤 3：Anchor 总数惊人！ 特征层 尺寸 每点锚数 总锚数 P3 80×80 9 80×80×9 = 57,600 P4 40×40 9 40×40×9 = 14,400 P5 20×20 9 20×20×9 = 3,600 总计 — — 75,600 个 Anchor 👉 也就是说，模型在一张图上一次性考虑了超过 7 万个候选框！\n但不用担心：后续通过 非极大值抑制（NMS） 和 IoU 匹配机制，只保留最可能的几十个结果。\n⚙️ 四、Anchor 的作用机制：如何工作？ ✅ 模型输出不是直接预测框，而是预测偏移量 模型为每个 Anchor 输出：\nΔcx, Δcy → 中心点偏移 Δw, Δh → 宽度和高度的缩放因子 Δθ → 旋转角度（若启用） 这些偏移量是相对于 Anchor 的修正值！\n📌 公式示例（经典 RPN / RetinaNet）： 1 2 3 4 predicted_x = anchor_cx + Δcx * anchor_w predicted_y = anchor_cy + Δcy * anchor_h predicted_w = anchor_w * exp(Δw) predicted_h = anchor_h * exp(Δh) 所以模型学的是：“这个 Anchor 应该往哪移动、放大多少”，而不是“从头画一个框”。\n✅ 匹配过程（Training）： 对每个真实标注框（Ground Truth），找到与其 IoU 最大的 Anchor； 若 IoU \u0026gt; 阈值（如 0.7）→ 标记为 正样本（Positive）； 若 IoU \u0026lt; 阈值（如 0.3）→ 标记为 负样本（Negative）； 模型学习： 正样本：预测正确的偏移量 负样本：预测“无目标”（背景） 👉 这就是为什么 Anchor 是“先验”的意义：它把无限空间搜索变成有限局部优化！\n🔄 五、Anchor vs Anchor-Free：对比总结 维度 Anchor-Based 方法 Anchor-Free 方法 代表模型 Faster R-CNN、SSD、RetinaNet FCOS、CenterNet、YOLOv8（部分）、DETR 是否预设框 ✅ 是 ❌ 否 预测内容 Anchor 的偏移量 特征点到边界的距离 / 中心点热力图 计算复杂度 高（数万 Anchor） 低（仅特征点） 训练稳定性 高（有明确匹配） 低（需精心设计损失函数） 小物体检测 ✅ 更好（密集锚覆盖） ⚠️ 较难（依赖分辨率） 部署速度 慢（需 NMS） 快（无 NMS 或轻量 NMS） 适用场景 工业质检、精准定位 实时系统、移动端、简单目标 ✅ 结论：\nAnchor 是“稳而重”，适合对精度要求高的工业场景；\nAnchor-Free 是“轻而快”，适合实时或资源受限环境。\n🎯 六、Anchor 的优缺点总结 ✅ 优点 ❌ 缺点 ✅ 训练稳定，收敛快 ❌ 生成大量冗余 Anchor（浪费显存） ✅ 对小物体检测效果好 ❌ 超参数敏感（scale/ratio/level 需仔细调） ✅ 易于解释和可视化 ❌ 难以适应极端形状（如不规则轮廓） ✅ 与传统方法兼容性好 ❌ 需要手动设计或聚类锚框分布 ✅ 支持旋转锚（OBB） ❌ 无法处理“无固定形状”目标（如云、烟雾） 🧠 七、类比理解：Anchor 就像“地图上的网格标记” 想象你在找一个丢失的手机：\nAnchor-Free 方法：你站在街上，凭感觉说：“它大概在这片区域。” → 然后慢慢搜。 Anchor-Based 方法：你提前在地图上画了 100 个方格子（每个 1m×1m），然后说：“我的手机要么在第 3 行第 5 列那个格子里，稍微偏左一点。” → 你不需要遍历整个城市，只需要检查那 100 个格子，再微调位置。\n这就是 Anchor 的智慧：用先验缩小搜索空间，提升效率和精度。\n📌 八、实战建议：如何选择合适的 Anchor？ 场景 推荐策略 工业缺陷检测 使用多尺度 + 多长宽比（如 scales=[0.5,1,2], ratios=[0.3,0.5,1,2,3]）+ 关闭忽略方向 文字检测 使用锚角度 [-45°, 0°, 45°] + 高长宽比（如 1:5） 行人/车辆检测 标准设置：scales=[1.0], ratios=[0.5,1,2]，MinLevel=2，MaxLevel=5 数据少 使用预训练 Anchor（COCO 聚类）+ 冻结骨干 想提速 减少锚数量（如只用 3 个/点）或改用 Anchor-Free（如 YOLOv8） 不确定怎么设 用 K-Means 聚类你的标注框！这是业界最佳实践 ","date":"2025-09-15T10:21:49+08:00","image":"https://www.notion.so/images/page-cover/webb2.jpg","permalink":"https://dumbnessrf.github.io/p/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E5%BF%B5/","title":"深度学习的一些理念"},{"content":"🧵 .NET 并发编程利器详解 附：volatile 与 Interlocked 在并发控制中的关键作用\n📌 引言：为什么需要并发集合？ 在多线程编程中，我们经常需要多个线程安全地共享数据 —— 比如生产者消费者模型、任务队列、缓存字典、限流控制等。如果使用普通集合（如 List\u0026lt;T\u0026gt;、Queue\u0026lt;T\u0026gt;、Dictionary\u0026lt;TKey, TValue\u0026gt;），在并发读写时极易引发：\n❌ 数据竞争（Race Condition） ❌ 集合内部结构损坏（如哈希表 rehash 时被多线程修改） ❌ 程序崩溃或数据不一致 .NET 提供了 System.Collections.Concurrent 命名空间下的线程安全集合类，专为高并发场景设计，无需手动加锁即可安全使用。\n本文将深入讲解：\n✅ ConcurrentQueue\u0026lt;T\u0026gt;、ConcurrentStack\u0026lt;T\u0026gt;、ConcurrentDictionary\u0026lt;TKey, TValue\u0026gt; ✅ BlockingCollection\u0026lt;T\u0026gt; 与它们的关系 ✅ SemaphoreSlim 如何控制并发度 ✅ volatile 与 Interlocked 在并发编程中的关键作用 ✅ 实战示例 + 最佳实践 🧩 一、三大基础并发集合 1. ConcurrentQueue\u0026lt;T\u0026gt; —— 线程安全的先进先出队列 特点：\nFIFO（First In, First Out） 无锁或细粒度锁实现，高性能 支持多生产者多消费者 常用方法：\nEnqueue(T item) — 入队 TryDequeue(out T result) — 出队（线程安全） IsEmpty — 是否为空（注意：可能瞬时不准，仅作参考） 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 var queue = new ConcurrentQueue\u0026lt;int\u0026gt;(); // 生产者线程 Task.Run(() =\u0026gt; { for (int i = 1; i \u0026lt;= 5; i++) { queue.Enqueue(i); Console.WriteLine($\u0026#34;生产: {i}\u0026#34;); Thread.Sleep(100); } }); // 消费者线程 Task.Run(() =\u0026gt; { while (true) { if (queue.TryDequeue(out var item)) { Console.WriteLine($\u0026#34;消费: {item}\u0026#34;); } else if (queue.IsEmpty) break; // 注意：此处可能有竞态，仅演示 Thread.Sleep(50); } }); Thread.Sleep(2000); ✅ 适用场景：任务队列、消息缓冲、日志收集等\n2. ConcurrentStack\u0026lt;T\u0026gt; —— 线程安全的后进先出栈 特点：\nLIFO（Last In, First Out） 同样支持多生产者多消费者 常用方法：\nPush(T item) — 压栈 TryPop(out T result) — 弹栈 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var stack = new ConcurrentStack\u0026lt;int\u0026gt;(); Task.Run(() =\u0026gt; { for (int i = 1; i \u0026lt;= 3; i++) { stack.Push(i); Console.WriteLine($\u0026#34;压栈: {i}\u0026#34;); } }); Task.Run(() =\u0026gt; { while (stack.TryPop(out var item)) { Console.WriteLine($\u0026#34;弹栈: {item}\u0026#34;); Thread.Sleep(100); } }); Thread.Sleep(1000); ✅ 适用场景：撤销操作栈、对象池、深度优先遍历缓冲\n3. ConcurrentDictionary\u0026lt;TKey, TValue\u0026gt; —— 线程安全字典 特点：\n内部使用分段锁或无锁结构（.NET Core 后优化极佳） 支持原子操作：AddOrUpdate, GetOrAdd 常用方法：\n1 2 3 4 5 6 7 var cache = new ConcurrentDictionary\u0026lt;string, string\u0026gt;(); // 线程安全添加或获取 var value = cache.GetOrAdd(\u0026#34;key\u0026#34;, k =\u0026gt; ComputeExpensiveValue(k)); // 线程安全更新 cache.AddOrUpdate(\u0026#34;counter\u0026#34;, 1, (key, oldValue) =\u0026gt; oldValue + 1); 完整示例：\n1 2 3 4 5 6 7 8 9 var dict = new ConcurrentDictionary\u0026lt;string, int\u0026gt;(); Parallel.For(0, 1000, i =\u0026gt; { dict.AddOrUpdate(\u0026#34;count\u0026#34;, 1, (key, old) =\u0026gt; old + 1); }); Console.WriteLine($\u0026#34;最终计数: {dict[\u0026#34;count\u0026#34;]}\u0026#34;); // 输出：1000（线程安全累加） ✅ 适用场景：缓存、计数器、共享状态存储\n🚦 二、BlockingCollection —— 并发集合的“增强包装器” ▶ 它是什么？ BlockingCollection\u0026lt;T\u0026gt; 不是一个新的集合，而是一个包装器，它为 IProducerConsumerCollection\u0026lt;T\u0026gt;（如 ConcurrentQueue\u0026lt;T\u0026gt;）添加了：\n✅ 阻塞操作（Take() 会阻塞直到有数据） ✅ 限界容量（Bounded Capacity） ✅ 完成标记（CompleteAdding()） ✅ 枚举支持（GetConsumingEnumerable()） ▶ 与三大集合的关系 底层集合 行为 ConcurrentQueue\u0026lt;T\u0026gt; FIFO 阻塞队列（默认） ConcurrentStack\u0026lt;T\u0026gt; LIFO 阻塞栈 ConcurrentBag\u0026lt;T\u0026gt; 无序高性能阻塞包 ▶ 示例：生产者-消费者模型（推荐写法） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 var blockingCollection = new BlockingCollection\u0026lt;int\u0026gt;(new ConcurrentQueue\u0026lt;int\u0026gt;(), 10); // 最大容量10 // 生产者 Task.Run(() =\u0026gt; { for (int i = 1; i \u0026lt;= 20; i++) { blockingCollection.Add(i); // 如果满了，会阻塞 Console.WriteLine($\u0026#34;生产: {i}\u0026#34;); Thread.Sleep(100); } blockingCollection.CompleteAdding(); // 标记完成 }); // 消费者 Task.Run(() =\u0026gt; { foreach (var item in blockingCollection.GetConsumingEnumerable()) { Console.WriteLine($\u0026#34;消费: {item}\u0026#34;); Thread.Sleep(200); // 模拟处理时间 } }); Thread.Sleep(5000); ✅ 适用场景：任务调度、数据流水线、限流缓冲区\n💡 BlockingCollection\u0026lt;T\u0026gt; 默认有序（FIFO），因为默认包装 ConcurrentQueue\u0026lt;T\u0026gt;\n🚧 三、SemaphoreSlim —— 控制并发访问数量 ▶ 它是什么？ SemaphoreSlim 是一个轻量级信号量，用于限制同时访问某资源的线程数量。\n不是集合，而是并发控制原语。\n▶ 常用方法： Wait() / WaitAsync() — 获取许可证 Release() — 释放许可证 CurrentCount — 剩余许可证数 ▶ 示例：限制最多3个并发下载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var semaphore = new SemaphoreSlim(3, 3); // 最多3个并发 var tasks = Enumerable.Range(1, 10).Select(async i =\u0026gt; { await semaphore.WaitAsync(); try { Console.WriteLine($\u0026#34;开始下载文件 {i}，当前并发: {3 - semaphore.CurrentCount}\u0026#34;); await Task.Delay(1000); // 模拟下载 Console.WriteLine($\u0026#34;完成下载文件 {i}\u0026#34;); } finally { semaphore.Release(); } }); await Task.WhenAll(tasks); ✅ 适用场景：限流、数据库连接池、API调用限频、资源池\n⚙️ 四、volatile 与 Interlocked —— 并发编程的基石 1. volatile 关键字 用于修饰字段，确保多线程环境下对该字段的读写不被编译器/CPU重排序或缓存。\n适用场景：标志位、状态变量、引用替换\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Worker { private volatile bool _shouldStop = false; public void DoWork() { while (!_shouldStop) { // 工作逻辑 } } public void RequestStop() { _shouldStop = true; // 其他线程能立即看到 } } ⚠️ volatile 不能替代锁！它只保证可见性和禁止重排序，不保证原子性。\n2. Interlocked 类 提供原子操作，如自增、自减、交换、比较交换（CAS）\n常用方法：\nInterlocked.Increment(ref variable) Interlocked.Exchange(ref location, value) — 原子替换 Interlocked.CompareExchange(ref location, newValue, comparand) — CAS 示例 1：线程安全计数器\n1 2 3 4 5 6 7 8 private long _counter = 0; Parallel.For(0, 10000, _ =\u0026gt; { Interlocked.Increment(ref _counter); }); Console.WriteLine(_counter); // 10000 示例 2：原子替换（用于动态替换 SemaphoreSlim）\n1 2 3 4 5 6 7 8 private volatile SemaphoreSlim _semaphore = new(4); public void SetMaxConcurrency(int newMax) { var newSemaphore = new SemaphoreSlim(newMax); var old = Interlocked.Exchange(ref _semaphore, newSemaphore); old?.Dispose(); } ✅ 适用场景：计数器、状态机、无锁数据结构、动态资源替换\n🔄 五、它们之间的关系图谱 1 2 3 4 5 6 7 8 graph TD A[ConcurrentQueue\u0026lt;T\u0026gt;] --\u0026gt;|包装| B(BlockingCollection\u0026lt;T\u0026gt;) C[ConcurrentStack\u0026lt;T\u0026gt;] --\u0026gt;|包装| B D[ConcurrentBag\u0026lt;T\u0026gt;] --\u0026gt;|包装| B E[SemaphoreSlim] --\u0026gt;|控制| F[并发任务数/资源访问数] G[volatile + Interlocked] --\u0026gt;|支撑| H[无锁编程、动态替换、状态同步] B --\u0026gt;|常与| E F --\u0026gt;|依赖| G BlockingCollection\u0026lt;T\u0026gt; 依赖底层并发集合\nSemaphoreSlim 常用于控制 BlockingCollection 消费者或任务并发数\nvolatile + Interlocked 是实现无锁替换、状态同步的基础\n🎯 六、实战：构建一个带并发限制的任务调度器 结合以上所有知识点：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class LimitedTaskScheduler\u0026lt;T\u0026gt; { private readonly BlockingCollection\u0026lt;Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt;\u0026gt; _taskQueue; private readonly SemaphoreSlim _semaphore; private readonly ILogger _logger; public LimitedTaskScheduler(int maxConcurrency, ILogger logger) { _taskQueue = new BlockingCollection\u0026lt;Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt;\u0026gt;(new ConcurrentQueue\u0026lt;Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt;\u0026gt;()); _semaphore = new SemaphoreSlim(maxConcurrency, maxConcurrency); _logger = logger; } public void QueueTask(Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt; task) { _taskQueue.Add(task); } public async Task StartAsync() { var tasks = new List\u0026lt;Task\u0026gt;(); foreach (var workItem in _taskQueue.GetConsumingEnumerable()) { tasks.Add(ExecuteWithLimit(workItem)); } await Task.WhenAll(tasks); } private async Task ExecuteWithLimit(Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt; workItem) { await _semaphore.WaitAsync(); try { await workItem(); } finally { _semaphore.Release(); } } public void CompleteAdding() =\u0026gt; _taskQueue.CompleteAdding(); } 使用：\n1 2 3 4 5 6 7 8 9 10 11 12 var scheduler = new LimitedTaskScheduler\u0026lt;string\u0026gt;(3, logger); scheduler.QueueTask(() =\u0026gt; Task.Run(async () =\u0026gt; { await Task.Delay(1000); return \u0026#34;Task1 Result\u0026#34;; })); scheduler.QueueTask(/* ... */); scheduler.CompleteAdding(); await scheduler.StartAsync(); 📝 七、最佳实践总结 组件 使用建议 ConcurrentQueue 默认首选，FIFO，适合任务队列 ConcurrentStack 适合撤销栈、对象池 ConcurrentDictionary 缓存、计数器首选，用 GetOrAdd / AddOrUpdate 避免竞态 BlockingCollection 需要阻塞/限界/完成通知时使用，包装 ConcurrentQueue 最常用 SemaphoreSlim 控制并发数，配合 using 或 try/finally 确保 Release volatile 用于布尔标志、引用替换，确保可见性 Interlocked 计数器、无锁状态切换、原子替换（如动态调整并发数） 🧭 八、常见误区 ❌ “ConcurrentBag 是无序的，性能最好，所以我所有地方都用它”\n→ 仅在顺序无关、频繁增删时使用，否则用 ConcurrentQueue\n❌ “BlockingCollection.Take() 是非阻塞的”\n→ 默认是阻塞的！除非用 TryTake\n❌ “volatile 能保证原子性”\n→ 不能！i++ 即使是 volatile 也不是原子的，要用 Interlocked.Increment\n❌ “SemaphoreSlim 是集合”\n→ 它是同步原语，不是数据容器\n✅ 结语 .NET 的并发集合与同步原语构成了强大而易用的并发编程基础设施。掌握：\nConcurrentQueue / ConcurrentStack / ConcurrentDictionary BlockingCollection\u0026lt;T\u0026gt; 的阻塞与包装能力 SemaphoreSlim 的并发控制 volatile 与 Interlocked 的无锁支撑 你就能在多线程世界中游刃有余，写出高性能、高可靠性的并发程序。\n📌 源码示例已全部测试通过，可直接复制到项目中运行。\n📌 建议收藏 + 实践 + 分享给团队，提升整体并发编程能力！\n🔖 附录：命名空间引用 确保项目中引用：\n1 2 3 4 5 using System; using System.Collections.Concurrent; using System.Threading; using System.Threading.Tasks; using System.Linq; 🎉 感谢阅读！如果你觉得有帮助，欢迎点赞、收藏、转发！\n下期预告：《用 Channel 替代 BlockingCollection —— .NET 6+ 现代并发数据流》\n","date":"2025-09-11T21:08:09+08:00","image":"https://www.notion.so/images/page-cover/met_joseph_hidley_1870.jpg","permalink":"https://dumbnessrf.github.io/p/meet_parallel_programing/","title":"Meet Parallel Programing"},{"content":"🎯 SharpBoxesCore.Wpf.PropertyGrid 一个功能强大、高度可扩展的 WPF 属性编辑器（PropertyGrid），专为现代 MVVM 应用设计。支持自动 UI 生成、属性分组、描述显示、范围验证、滑块调节、自定义按钮、命令绑定、复合类型嵌套、集合编辑、动态刷新、防抖优化等高级功能，开箱即用，适用于配置面板、调试工具、设计器、参数设置等场景。\n✨ 核心特性 功能 说明 🔹 自动属性发现 扫描对象的公共可读写属性 🔹 属性分组（Category） 支持 [Category(\u0026quot;分组名\u0026quot;)] 分类显示 🔹 属性排序 支持 [PropertyOrder(1)] 自定义排序 🔹 描述显示 鼠标悬停或聚焦时显示 [Description] 内容 🔹 显示名称 支持 [DisplayName(\u0026quot;别名\u0026quot;)] 自定义名称 🔹 枚举支持 显示 [Description] 文本，支持可空枚举 🔹 数值范围验证 支持 [Range(0, 100)] 输入限制 🔹 滑块调节 配合 [ShowSlider] 显示 Slider 控件 🔹 自定义按钮 支持 [AddButton] 添加操作按钮 🔹 命令绑定 按钮可绑定 ICommand，支持参数传递 🔹 降级机制 命令不存在时 fallback 到 ButtonClicked 事件 🔹 折叠面板 每个 Category 支持 Expander 折叠/展开 🔹 事件回调 支持 ButtonClicked 和 PropertyValueChanged 事件 🔹 错误提示 边框变红，显示错误提示，不更新数据源 🔹 文件/文件夹选择 支持 [SelectFilePath] / [SelectFolder] 对话框 🔹 下拉框编辑 支持 [EnumerableProperty] 绑定数据源 🔹 复合类型嵌套 支持类属性展开为子属性面板 🔹 集合编辑 支持 List\u0026lt;T\u0026gt; / Dictionary\u0026lt;K,V\u0026gt; 弹窗编辑 🔹 动态刷新 数据源变化自动更新 UI 🔹 类型安全 编辑时保留原始类型，支持自动解析 🔹 防抖机制 高频更新时自动合并刷新，提升性能 🔹 高度自适应 支持滚动条，内容展开自动拉伸 🔹 搜索属性字段 支持搜索指定名称属性编辑 🔹 一键展开、折叠 支持一键展开、折叠所有属性 🚀 快速开始 1. 安装引用 .NET CLI 1 dotnet add package SharpBoxesCore.Wpf --version 1.1.2 PackageReference 1 \u0026lt;PackageReference Include=\u0026#34;SharpBoxesCore.Wpf\u0026#34; Version=\u0026#34;1.1.2\u0026#34; /\u0026gt; CPM Directory.Packages.props\n1 \u0026lt;PackageVersion Include=\u0026#34;SharpBoxesCore.Wpf\u0026#34; Version=\u0026#34;1.1.2\u0026#34; /\u0026gt; Project file\n1 \u0026lt;PackageReference Include=\u0026#34;SharpBoxesCore.Wpf\u0026#34; /\u0026gt; 2. 在 XAML 中使用 1 2 3 4 5 6 7 \u0026lt;Window x:Class=\u0026#34;YourApp.MainWindow\u0026#34; xmlns:local=\u0026#34;clr-namespace:SharpBoxesCore.Wpf.PropertyGrid\u0026#34; ...\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;local:PropertyGrid x:Name=\u0026#34;propertyGrid\u0026#34; Padding=\u0026#34;10\u0026#34; /\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Window\u0026gt; 3. 绑定数据对象 1 2 3 4 5 6 7 8 9 10 11 12 public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); propertyGrid.SelectedObject = new SampleObject(); // 订阅事件 propertyGrid.ButtonClicked += OnButtonClicked; propertyGrid.PropertyValueChanged += OnPropertyValueChanged; } } 📦 示例：完整数据模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 public class SampleObject : INotifyPropertyChanged { [Category(\u0026#34;基本信息\u0026#34;)] [DisplayName(\u0026#34;姓名\u0026#34;)] [Description(\u0026#34;用户的全名\u0026#34;)] [EnumerableProperty(\u0026#34;AvaliableNames\u0026#34;, true)] public string Name { get; set; } = \u0026#34;张三\u0026#34;; [Category(\u0026#34;数值设置\u0026#34;)] [DisplayName(\u0026#34;音量\u0026#34;)] [Description(\u0026#34;调节音量大小\u0026#34;)] [Range(0, 100)] [ShowSlider(10, true)] public int Volume { get; set; } = 75; [Category(\u0026#34;高级\u0026#34;)] [DisplayName(\u0026#34;数据模式\u0026#34;)] public DataMode Mode { get; set; } = DataMode.Development; [Category(\u0026#34;文件\u0026#34;)] [DisplayName(\u0026#34;配置文件\u0026#34;)] [SelectFilePath(Title = \u0026#34;选择配置文件\u0026#34;, Filter = \u0026#34;JSON Files|*.json\u0026#34;)] public string ConfigFile { get; set; } = \u0026#34;\u0026#34;; [Category(\u0026#34;路径\u0026#34;)] [DisplayName(\u0026#34;工作目录\u0026#34;)] [SelectFolder(Title = \u0026#34;选择工作目录\u0026#34;)] public string WorkDir { get; set; } = \u0026#34;\u0026#34;; [Category(\u0026#34;集合\u0026#34;)] public List\u0026lt;string\u0026gt; Hobbies { get; set; } = new() { \u0026#34;阅读\u0026#34;, \u0026#34;音乐\u0026#34; }; [Category(\u0026#34;字典\u0026#34;)] public Dictionary\u0026lt;string, int\u0026gt; Scores { get; set; } = new() { [\u0026#34;数学\u0026#34;] = 90, [\u0026#34;英语\u0026#34;] = 85 }; [Category(\u0026#34;嵌套对象\u0026#34;)] public Address HomeAddress { get; set; } = new(); [Category(\u0026#34;操作\u0026#34;)] [AddButton(\u0026#34;ResetCommand\u0026#34;, \u0026#34;重置\u0026#34;)] [AddButton(\u0026#34;LogCommand\u0026#34;, \u0026#34;记录当前值\u0026#34;)] public int RetryCount { get; set; } = 3; // 命令定义 public ICommand ResetCommand =\u0026gt; new RelayCommand\u0026lt;string\u0026gt;(_ =\u0026gt; RetryCount = 0); public ICommand LogCommand =\u0026gt; new RelayCommand\u0026lt;string\u0026gt;(action =\u0026gt; Debug.WriteLine($\u0026#34;日志: {action}, Count={RetryCount}\u0026#34;)); // 下拉数据源 public ObservableCollection\u0026lt;string\u0026gt; AvaliableNames { get; } = new() { \u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charlie\u0026#34; }; public event PropertyChangedEventHandler PropertyChanged; protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null) =\u0026gt; PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } 🎨 UI 效果预览 分组折叠/展开 滑块与文本框联动 按钮自动布局 错误输入红色提示 描述信息实时显示 复合对象嵌套展开 集合点击“编辑\u0026hellip;”弹窗 滚动条支持长内容 🔧 高级功能详解 1. 枚举显示 [Description] 1 2 3 4 5 6 7 8 public enum DataMode { [Description(\u0026#34;开发模式\u0026#34;)] Development, [Description(\u0026#34;生产模式\u0026#34;)] Production } ✅ 显示为“开发模式”而非 Development\n2. 滑块调节 [ShowSlider] 1 2 3 [Range(0, 100)] [ShowSlider(5, true)] public int Brightness { get; set; } ✅ 自动生成 Slider + TextBox 联动控件\n3. 自定义按钮与命令绑定 1 2 3 [AddButton(\u0026#34;SaveCommand\u0026#34;, \u0026#34;保存\u0026#34;, \u0026#34;另存为\u0026#34;)] [AddButton(\u0026#34;DeleteCommand\u0026#34;, \u0026#34;删除\u0026#34;)] public string FileName { get; set; } ✅ 存在命令 → 绑定执行 ❌ 不存在 → 触发 ButtonClicked 事件 1 2 3 4 propertyGrid.ButtonClicked += (s, e) =\u0026gt; { MessageBox.Show($\u0026#34;按钮点击: {e.PropertyName} - {e.ButtonText}\u0026#34;); }; 4. 数值范围验证 1 2 [Range(1, 1000)] public int Count { get; set; } ✅ 输入非法时：\n边框变红 显示错误提示 不更新数据源 5. 下拉框 [EnumerableProperty] 1 2 [EnumerableProperty(\u0026#34;AvaliableNames\u0026#34;, true)] public string Theme { get; set; } ✅ 显示下拉框，支持自定义输入，数据源动态刷新\n6. 文件/文件夹选择 1 2 3 4 5 [SelectFilePath(Title = \u0026#34;选择日志\u0026#34;)] public string LogFile { get; set; } [SelectFolder] public string BackupDir { get; set; } ✅ 使用 Ookii.Dialogs.Wpf 提供专业对话框\n7. 复合类型（嵌套对象） 1 2 3 4 5 6 7 8 public class Address { public string Street { get; set; } public string City { get; set; } } [DisplayName(\u0026#34;家庭地址\u0026#34;)] public Address HomeAddress { get; set; } ✅ 自动展开为子属性面板，支持 INotifyPropertyChanged 动态刷新\n8. 集合编辑（List / Dictionary） 1 2 public List\u0026lt;string\u0026gt; Hobbies { get; set; } public Dictionary\u0026lt;string, int\u0026gt; Scores { get; set; } ✅ 点击“编辑\u0026hellip;”弹出 ListEditor / DictEditor，支持类型保留编辑\n🧩 事件系统 PropertyValueChanged — 属性更改事件 1 2 3 4 5 6 7 propertyGrid.PropertyValueChanged += (s, e) =\u0026gt; { Console.WriteLine($\u0026#34;属性更改: {e.PropertyName}\u0026#34;); Console.WriteLine($\u0026#34; 类型: {e.PropertyType.Name}\u0026#34;); Console.WriteLine($\u0026#34; 旧值: {e.OldValue}\u0026#34;); Console.WriteLine($\u0026#34; 新值: {e.NewValue}\u0026#34;); }; ✅ 所有编辑操作（包括集合、文件选择）均触发此事件\nButtonClicked — 按钮点击事件（fallback） 1 2 3 4 propertyGrid.ButtonClicked += (s, e) =\u0026gt; { if (e.ButtonText == \u0026#34;重置\u0026#34;) ResetLogic(); }; ✅ 用于未绑定 ICommand 的按钮\n🛠️ 自定义 Attribute 说明 Attribute 用途 示例 [Category(\u0026quot;分组\u0026quot;)] 属性分组 Category(\u0026quot;网络\u0026quot;) [DisplayName(\u0026quot;别名\u0026quot;)] 自定义显示名 DisplayName(\u0026quot;IP地址\u0026quot;) [Description(\u0026quot;说明\u0026quot;)] 描述信息 Description(\u0026quot;服务器IP\u0026quot;) [PropertyOrder(1)] 排序优先级 数字越小越靠前 [Range(0,100)] 数值范围 支持 int/double/float [ShowSlider(10)] 显示滑块 TickFrequency=10 [AddButton(\u0026quot;Cmd\u0026quot;, \u0026quot;按钮\u0026quot;)] 添加操作按钮 支持多标签 [EnumerableProperty(\u0026quot;Source\u0026quot;, true)] 下拉框 绑定数据源 [SelectFilePath] 文件选择 打开 OpenFileDialog [SelectFolder] 文件夹选择 打开 FolderBrowserDialog ⚙️ 高级配置 防抖机制（Debounce） 默认启用，防止高频刷新：\n1 propertyGrid.DebounceEnabled = true; // 默认 true 可调整延迟时间（内部使用 DispatcherTimer）\n手动触发属性更改 1 propertyGrid.RaisePropertyValueChanged(\u0026#34;Name\u0026#34;, \u0026#34;旧值\u0026#34;, \u0026#34;新值\u0026#34;); 用于代码修改属性后通知外部系统\n📚 已知限制 限制 说明 ❌ 不支持集合增删项 ListEditor 仅支持修改值 ❌ 不支持复杂对象列表编辑 仅支持简单类型列表 ❌ 不支持 DateTime 专用控件 可用 TextBox 输入 ✅ 后续计划支持：DatePicker、ColorPicker、IEditableObject 撤销\n如果你喜欢这篇文章，欢迎点赞、收藏、分享！\n也可以关注我的博客，获取更多 WPF / .NET 技术干货 😊\n","date":"2025-09-02T23:01:03+08:00","image":"https://www.notion.so/images/page-cover/met_winslow_homer_maine_coast.jpg","permalink":"https://dumbnessrf.github.io/p/propertygrid/","title":"PropertyGrid"},{"content":"🚀 在 WPF 中使用 Microsoft.Xaml.Behaviors：行为（Behaviors）的优雅解决方案 ✅ 什么是 Microsoft.Xaml.Behaviors？ Microsoft.Xaml.Behaviors 是一个开源库，最初由 Expression Blend 团队开发，后来被微软官方维护并托管在 GitHub 上。这个库允许开发者通过 XAML 行为（Behaviors） 和 触发器（Triggers） 来扩展 UI 控件的功能，而无需编写复杂的代码或修改控件本身。\n💡 核心概念 Behavior（行为）：一种可重用的组件，附加到某个 UI 元素上，并为其添加额外的行为。 Trigger（触发器）：根据某些条件或事件执行特定的操作。 Action（动作）：触发器执行的具体操作，如调用方法、改变属性等。 GitHub 地址：https://github.com/microsoft/XamlBehaviors\n📦 安装 Microsoft.Xaml.Behaviors 你可以通过 NuGet 包管理器轻松地将 Microsoft.Xaml.Behaviors.Wpf 添加到你的 WPF 项目中。\n使用 NuGet 安装命令： 1 Install-Package Microsoft.Xaml.Behaviors.Wpf 或者通过 Visual Studio 的 NuGet 包管理器搜索并安装：\n打开菜单：工具 \u0026gt; NuGet 包管理器 \u0026gt; 管理解决方案的 NuGet 包 搜索关键词：Microsoft.Xaml.Behaviors.Wpf 安装最新版本 🛠️ XAML 命名空间引用 在 XAML 文件顶部添加以下命名空间引用，以便使用 Behaviors：\n1 xmlns:i=\u0026#34;http://schemas.microsoft.com/expression/2010/interactivity\u0026#34; 🎯 使用示例与应用场景 下面我们将通过几个典型的使用场景来展示 Microsoft.Xaml.Behaviors 的强大之处。\n示例 1：点击按钮时弹出消息框（不使用代码） 场景说明： 你希望点击按钮时显示一个简单的消息框，但不想在代码后台写任何逻辑。\n实现方式： 1 2 3 4 5 6 7 \u0026lt;Button Content=\u0026#34;点击我\u0026#34;\u0026gt; \u0026lt;i:Interaction.Triggers\u0026gt; \u0026lt;i:EventTrigger EventName=\u0026#34;Click\u0026#34;\u0026gt; \u0026lt;i:InvokeCommandAction Command=\u0026#34;{Binding ShowMessageCommand}\u0026#34; /\u0026gt; \u0026lt;/i:EventTrigger\u0026gt; \u0026lt;/i:Interaction.Triggers\u0026gt; \u0026lt;/Button\u0026gt; ViewModel 中定义命令： 1 2 3 4 5 6 7 public ICommand ShowMessageCommand { get; } public MyViewModel() { ShowMessageCommand = new RelayCommand(() =\u0026gt; MessageBox.Show(\u0026#34;你好，世界！\u0026#34;)); } 示例 2：文本框内容变化时更新绑定值（实时验证） 场景说明： 用户在输入框中输入内容时，自动触发验证逻辑。\n实现方式： 1 2 3 4 5 6 7 \u0026lt;TextBox Text=\u0026#34;{Binding Name}\u0026#34;\u0026gt; \u0026lt;i:Interaction.Triggers\u0026gt; \u0026lt;i:EventTrigger EventName=\u0026#34;TextChanged\u0026#34;\u0026gt; \u0026lt;i:InvokeCommandAction Command=\u0026#34;{Binding ValidateNameCommand}\u0026#34; /\u0026gt; \u0026lt;/i:EventTrigger\u0026gt; \u0026lt;/i:Interaction.Triggers\u0026gt; \u0026lt;/TextBox\u0026gt; 示例 3：鼠标悬停时高亮元素 场景说明： 当鼠标悬停在一个按钮上时，改变其背景颜色。\n实现方式： 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;Button Content=\u0026#34;悬停试试看\u0026#34;\u0026gt; \u0026lt;i:Interaction.Triggers\u0026gt; \u0026lt;i:EventTrigger EventName=\u0026#34;MouseEnter\u0026#34;\u0026gt; \u0026lt;i:ChangePropertyAction TargetObject=\u0026#34;{Binding ElementName=MyButton}\u0026#34; PropertyName=\u0026#34;Background\u0026#34; Value=\u0026#34;LightBlue\u0026#34;/\u0026gt; \u0026lt;/i:EventTrigger\u0026gt; \u0026lt;i:EventTrigger EventName=\u0026#34;MouseLeave\u0026#34;\u0026gt; \u0026lt;i:ChangePropertyAction TargetObject=\u0026#34;{Binding ElementName=MyButton}\u0026#34; PropertyName=\u0026#34;Background\u0026#34; Value=\u0026#34;White\u0026#34;/\u0026gt; \u0026lt;/i:EventTrigger\u0026gt; \u0026lt;/i:Interaction.Triggers\u0026gt; \u0026lt;/Button\u0026gt; 示例 4：自定义行为 —— 右键菜单 场景说明： 为任意控件添加右键菜单功能。\n自定义行为类（C#）： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class RightClickMenuBehavior : Behavior\u0026lt;FrameworkElement\u0026gt; { public static readonly DependencyProperty ContextMenuProperty = DependencyProperty.Register(\u0026#34;ContextMenu\u0026#34;, typeof(ContextMenu), typeof(RightClickMenuBehavior)); public ContextMenu ContextMenu { get { return (ContextMenu)GetValue(ContextMenuProperty); } set { SetValue(ContextMenuProperty, value); } } protected override void OnAttached() { AssociatedObject.MouseRightButtonDown += OnMouseRightButtonDown; } protected override void OnDetaching() { AssociatedObject.MouseRightButtonDown -= OnMouseRightButtonDown; } private void OnMouseRightButtonDown(object sender, MouseButtonEventArgs e) { if (ContextMenu != null) { ContextMenu.PlacementTarget = AssociatedObject; ContextMenu.IsOpen = true; } } } XAML 使用方式： 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;Button Content=\u0026#34;右键点击我\u0026#34;\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;local:RightClickMenuBehavior\u0026gt; \u0026lt;local:RightClickMenuBehavior.ContextMenu\u0026gt; \u0026lt;ContextMenu\u0026gt; \u0026lt;MenuItem Header=\u0026#34;复制\u0026#34; /\u0026gt; \u0026lt;MenuItem Header=\u0026#34;粘贴\u0026#34; /\u0026gt; \u0026lt;/ContextMenu\u0026gt; \u0026lt;/local:RightClickMenuBehavior.ContextMenu\u0026gt; \u0026lt;/local:RightClickMenuBehavior\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; \u0026lt;/Button\u0026gt; 🧩 应用场景总结 场景 描述 ⚙️ 事件绑定 将 UI 事件绑定到 ViewModel 中的命令，实现 MVVM 解耦 🔍 输入验证 实时验证用户输入内容，提升用户体验 🖱️ 鼠标交互 处理鼠标悬停、单击、拖拽等交互逻辑 🔄 动态样式 根据状态动态更改控件外观 🧪 单元测试 减少代码耦合，提高可测试性 🧱 自定义行为 快速构建可复用的 UI 行为模块 🧠 总结 Microsoft.Xaml.Behaviors 是 WPF 开发中非常强大的辅助工具。它不仅简化了 UI 与逻辑之间的绑定，还提升了代码的可维护性和可测试性。通过使用行为和触发器，我们可以实现更加灵活、解耦的 UI 设计，特别适合 MVVM 架构下的开发。\n如果你正在寻找一种更优雅的方式来处理 UI 交互逻辑，那么 Microsoft.Xaml.Behaviors 绝对值得一试！\n📚 参考资料 GitHub - Microsoft.Xaml.Behaviors NuGet - Microsoft.Xaml.Behaviors.Wpf MSDN - Interactivity Library 如果你喜欢这篇文章，欢迎点赞、收藏、分享！\n也可以关注我的博客，获取更多 WPF / .NET 技术干货 😊\n","date":"2025-07-23T23:01:03+08:00","image":"https://www.notion.so/images/page-cover/met_horace_pippin.jpg","permalink":"https://dumbnessrf.github.io/p/xaml_behaviors/","title":"Xaml Behaviors"},{"content":"在 WPF、Xamarin.Forms 和 .NET MAUI 开发中，数据绑定（Data Binding） 是 MVVM 架构的核心机制。但有时我们希望对绑定的数据进行转换、格式化或逻辑处理，这时候就需要使用 IValueConverter 接口实现值转换器。\nValueConverters.NET 是一个由 Thomas Galliker 维护的开源项目，它提供了一组常用的 IValueConverter 实现，帮助开发者快速构建强大的数据绑定逻辑。\n📦 安装方法 你可以通过 NuGet 包安装适用于不同平台的版本：\n平台 命令 WPF / WinForms / UWP / Avalonia 等 Install-Package ValueConverters Xamarin.Forms Install-Package ValueConverters.Forms .NET MAUI Install-Package ValueConverters.MAUI ✅ 如何使用 ValueConverters.NET？ 步骤一：在 XAML 中定义资源 1 2 3 4 \u0026lt;Window.Resources\u0026gt; \u0026lt;converters:DateTimeConverter x:Key=\u0026#34;DateTimeConverter\u0026#34; Format=\u0026#34;d\u0026#34; MinValueString=\u0026#34;-\u0026#34;/\u0026gt; \u0026lt;converters:BooleanToVisibilityConverter x:Key=\u0026#34;BooleanToVisibilityConverter\u0026#34;/\u0026gt; \u0026lt;/Window.Resources\u0026gt; 步骤二：在绑定中使用 Converter 1 2 \u0026lt;TextBlock Text=\u0026#34;{Binding BirthDate, Converter={StaticResource DateTimeConverter}}\u0026#34; /\u0026gt; \u0026lt;TextBox Visibility=\u0026#34;{Binding IsVisible, Converter={StaticResource BooleanToVisibilityConverter}}\u0026#34; /\u0026gt; 🧩 核心 Converters 及其示例 下面介绍几个最常用且实用的转换器及其应用场景。\n1. DateTimeConverter：日期格式化 示例代码： 1 2 // ViewModel public DateTime BirthDate { get; set; } = new DateTime(1990, 5, 20); 1 2 \u0026lt;!-- XAML --\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding BirthDate, Converter={StaticResource DateTimeConverter}, ConverterParameter=\u0026#39;yyyy-MM-dd\u0026#39;}\u0026#34; /\u0026gt; 支持参数： Format: 指定格式字符串（如 \u0026quot;yyyy-MM-dd\u0026quot;） MinValueString: 当值为 DateTime.MinValue 时显示替代文本 应用场景： 显示生日、创建时间等日期字段 处理空日期显示为 - 或 N/A 2. BooleanToVisibilityConverter：布尔值转可见性 示例代码： 1 2 // ViewModel public bool IsBusy { get; set; } = true; 1 2 \u0026lt;!-- XAML --\u0026gt; \u0026lt;ProgressBar Visibility=\u0026#34;{Binding IsBusy, Converter={StaticResource BooleanToVisibilityConverter}}\u0026#34; /\u0026gt; 支持参数： TrueValue: true 时返回的值（默认 Visibility.Visible） FalseValue: false 时返回的值（默认 Visibility.Collapsed） 应用场景： 控制按钮、进度条、加载动画的显示隐藏 动态切换控件状态 3. EnumWrapperConverter：枚举本地化展示 示例代码： 1 2 3 4 5 6 7 8 // 枚举定义 public enum PartyMode { [Display(Name = \u0026#34;PartyMode_Off\u0026#34;, ResourceType = typeof(PartyModeResources))] Off, [Display(Name = \u0026#34;PartyMode_On\u0026#34;, ResourceType = typeof(PartyModeResources))] On } 1 2 // ViewModel public PartyMode Mode { get; set; } = PartyMode.On; 1 2 \u0026lt;!-- XAML --\u0026gt; \u0026lt;Label Content=\u0026#34;{Binding Mode, Converter={StaticResource EnumWrapperConverter}}\u0026#34; /\u0026gt; 支持特性： 使用 [Display] 注解配合 .resx 资源文件实现多语言支持 自动识别当前 CurrentUICulture 应用场景： 国际化应用中的下拉菜单、状态标签 将枚举值以用户友好的方式展示 4. InvertBooleanConverter：取反布尔值 示例代码： 1 2 // ViewModel public bool IsLoggedIn { get; set; } = false; 1 2 \u0026lt;!-- XAML --\u0026gt; \u0026lt;Button Content=\u0026#34;登录\u0026#34; Visibility=\u0026#34;{Binding IsLoggedIn, Converter={StaticResource InvertBooleanConverter}}\u0026#34; /\u0026gt; 特点： 直接将 true 变为 false，反之亦然 应用场景： 控制“登录”和“登出”的切换显示 快速反转控件状态 5. NullToVisibilityConverter：空值控制可见性 示例代码： 1 2 // ViewModel public string UserName { get; set; } = null; 1 2 3 \u0026lt;!-- XAML --\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding UserName}\u0026#34; Visibility=\u0026#34;{Binding UserName, Converter={StaticResource NullToVisibilityConverter}}\u0026#34; /\u0026gt; 支持参数： WhenNull: 设置为 Visibility.Collapsed 或 Visibility.Hidden WhenNotNull: 同上 应用场景： 隐藏空字段 控制非空内容的显示 6. EnumToBooleanConverter：枚举匹配判断布尔值 示例代码： 1 2 3 4 5 6 7 8 9 10 // 枚举 public enum UserLevel { Guest, Member, Admin } // ViewModel public UserLevel Level { get; set; } = UserLevel.Admin; 1 2 3 \u0026lt;!-- XAML --\u0026gt; \u0026lt;Button Content=\u0026#34;删除用户\u0026#34; Visibility=\u0026#34;{Binding Level, Converter={StaticResource EnumToBooleanConverter}, ConverterParameter=Admin}\u0026#34; /\u0026gt; 应用场景： 根据角色权限显示/隐藏按钮 枚举匹配时启用某些操作 7. MultiBindingConverters：多个绑定值组合转换 示例：根据两个布尔值决定是否启用按钮 1 2 3 4 5 6 7 8 \u0026lt;Button Content=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;Button.Visibility\u0026gt; \u0026lt;MultiBinding Converter=\u0026#34;{StaticResource BooleanAndToVisibilityConverter}\u0026#34;\u0026gt; \u0026lt;Binding Path=\u0026#34;IsFormValid\u0026#34; /\u0026gt; \u0026lt;Binding Path=\u0026#34;IsNetworkAvailable\u0026#34; /\u0026gt; \u0026lt;/MultiBinding\u0026gt; \u0026lt;/Button.Visibility\u0026gt; \u0026lt;/Button\u0026gt; 支持的 MultiConverter： BooleanAndConverter BooleanOrConverter BooleanXorConverter BooleanAndToVisibilityConverter BooleanOrToVisibilityConverter 应用场景： 多条件判断控件状态 表单验证联动控制 8. ImageSourceConverter：图像路径转 ImageSource 示例代码： 1 2 // ViewModel public string AvatarPath { get; set; } = \u0026#34;Images/avatar.png\u0026#34;; 1 2 \u0026lt;!-- XAML --\u0026gt; \u0026lt;Image Source=\u0026#34;{Binding AvatarPath, Converter={StaticResource ImageSourceConverter}}\u0026#34; /\u0026gt; 支持参数： 支持相对路径、绝对路径、Base64 图像等 应用场景： 数据绑定图像地址 动态加载头像、图标等 9. FileSizeToStringConverter：字节大小自动转 KB/MB/GB 示例代码： 1 2 // ViewModel public long FileSize { get; set; } = 1024 * 1024 * 10; // 10 MB 1 2 \u0026lt;!-- XAML --\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding FileSize, Converter={StaticResource FileSizeToStringConverter}}\u0026#34; /\u0026gt; 输出结果：10.00 MB\n应用场景： 文件管理器、磁盘清理工具等显示文件大小 日志系统、监控系统中显示内存占用 10. StringFormatConverter：自定义字符串格式化 示例代码： 1 2 // ViewModel public decimal Price { get; set; } = 99.99m; 1 2 \u0026lt;!-- XAML --\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding Price, Converter={StaticResource StringFormatConverter}, ConverterParameter=\u0026#39;{}{0:C}\u0026#39;}\u0026#34; /\u0026gt; 输出结果：$99.99（根据文化设置）\n应用场景： 货币、百分比、数字格式化显示 支持动态格式模板 🌍 文化敏感支持（Culture Awareness） 所有转换器都支持文化感知：\n1 2 // 在 App.xaml.cs 或初始化时配置 ValueConvertersConfig.DefaultPreferredCulture = ConverterCulture.CurrentUICulture; 你也可以在运行时更改语言并刷新界面：\n1 Thread.CurrentThread.CurrentUICulture = new CultureInfo(\u0026#34;zh-CN\u0026#34;); 📦 总结 转换器名称 功能 应用场景 DateTimeConverter 日期格式化 时间戳展示 BooleanToVisibilityConverter 布尔转可视性 控件显示隐藏 EnumWrapperConverter 枚举本地化 下拉框、状态栏 InvertBooleanConverter 布尔取反 控件状态反转 NullToVisibilityConverter 空值控制可视性 隐藏空字段 EnumToBooleanConverter 枚举匹配布尔 权限控制 ImageSourceConverter 字符串路径转图像源 图像绑定 FileSizeToStringConverter 字节数大小转易读格式 文件信息展示 StringFormatConverter 字符串格式化 货币、百分比 BooleanAndConverter, BooleanOrConverter 多个布尔值逻辑运算 表单验证 🧩 结语：为什么推荐使用 ValueConverters.NET？ ✅ 提供了常见场景下的高质量 IValueConverter 实现 ✅ 支持多语言、文化敏感 ✅ 支持 WPF、Xamarin.Forms、MAUI 等主流 UI 框架 ✅ 可扩展性强，易于封装复用 ✅ 减少 Code-Behind，增强 MVVM 解耦能力 📦 推荐使用方式 安装包： 1 PM\u0026gt; Install-Package ValueConverters 全局注册（App.xaml）： 1 2 3 4 \u0026lt;Application.Resources\u0026gt; \u0026lt;converters:BooleanToVisibilityConverter x:Key=\u0026#34;BoolToVisConverter\u0026#34;/\u0026gt; \u0026lt;converters:DateTimeConverter x:Key=\u0026#34;DateTimeConverter\u0026#34; Format=\u0026#34;yyyy-MM-dd\u0026#34;/\u0026gt; \u0026lt;/Application.Resources\u0026gt; 📚 参考资料 GitHub 仓库：https://github.com/thomasgalliker/ValueConverters.NET NuGet 地址： WPF / WinForms / UWP Xamarin.Forms .NET MAUI ","date":"2025-06-24T17:39:03+08:00","image":"https://www.notion.so/images/page-cover/webb3.jpg","permalink":"https://dumbnessrf.github.io/p/value_converters/","title":"Value Converters"},{"content":"CalcBinding 是一个 WPF 第三方绑定增强库，它允许你在 XAML 中使用表达式进行数据绑定计算，而无需在 ViewModel 中写额外的属性或转换器（Converter）。\u0026ndash;它非常适合用于简单的数学运算、字符串拼接、条件判断等场景。\n📦 一、简介 GitHub 地址：https://github.com/Alex198711/CalcBinding 功能：支持类似 {calcBinding Path=Width*2+Height} 的表达式绑定 不依赖 IValueConverter 支持多绑定、条件语句、函数调用等 🧩 二、安装方式 你可以通过 NuGet 安装：\n1 Install-Package CalcBinding 然后在 XAML 中添加命名空间引用：\n1 xmlns:calc=\u0026#34;clr-namespace:CalcBinding;assembly=CalcBinding\u0026#34; 📘 三、常见用法与示例 ✅ 示例 1：基本数学运算 1 \u0026lt;TextBlock Text=\u0026#34;{calc:Binding Path=Width * 2 + Height}\u0026#34; /\u0026gt; 将 Width 乘以 2 再加上 Height，结果作为 TextBlock.Text\n✅ 示例 2：字符串拼接 1 \u0026lt;TextBlock Text=\u0026#34;{calc:Binding Path=FirstName + \u0026#39; \u0026#39; + LastName}\u0026#34; /\u0026gt; 把两个字段拼接成完整姓名\n✅ 示例 3：布尔值转可见性（Visibility） 1 2 \u0026lt;Button Content=\u0026#34;Submit\u0026#34; Visibility=\u0026#34;{calc:Binding Path=IsEnabled ? Visible : Collapsed}\u0026#34; /\u0026gt; 使用三元运算符实现 Visibility 控制，无需 Converter\n✅ 示例 4：绑定多个属性并做计算 1 \u0026lt;TextBlock Text=\u0026#34;{calc:MultiBinding Path1=Value1, Path2=Value2, Expression=Path1 + Path2}\u0026#34; /\u0026gt; 多绑定支持最多 5 个路径（Path1~Path5），可以组合任意表达式\n✅ 示例 5：使用 Math 函数（如 Max、Min、Round） 1 \u0026lt;TextBlock Text=\u0026#34;{calc:Binding Path=Math.Max(Width, Height)}\u0026#34; /\u0026gt; 显示 Width 和 Height 中较大的那个\n支持的函数包括：\nMath.Abs Math.Round Math.Min Math.Max Math.Ceiling Math.Floor Math.Pow(x, y) Math.Sqrt(x) ✅ 示例 6：条件判断结合绑定 1 \u0026lt;TextBlock Text=\u0026#34;{calc:Binding Path=Value \u0026gt; 0 ? Value : 0}\u0026#34; /\u0026gt; 如果 Value 大于 0，则显示 Value，否则显示 0\n✅ 示例 7：绑定集合元素 1 \u0026lt;TextBlock Text=\u0026#34;{calc:Binding Path=Items[0].Price * Items[0].Quantity}\u0026#34; /\u0026gt; 绑定集合中第一个元素的属性并进行计算\n✅ 示例 8：绑定资源中的静态值 1 2 3 4 5 \u0026lt;Window.Resources\u0026gt; \u0026lt;sys:Double x:Key=\u0026#34;ScaleFactor\u0026#34;\u0026gt;1.5\u0026lt;/sys:Double\u0026gt; \u0026lt;/Window.Resources\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{calc:Binding Path=Width * {StaticResource ScaleFactor}}\u0026#34; /\u0026gt; 可以在表达式中嵌入静态资源\n✅ 示例 9：使用方法调用（需要注册） 你可以在代码中注册自定义函数，例如：\n1 CalcBindingHelper.RegisterFunction(\u0026#34;Format\u0026#34;, (string format, object arg) =\u0026gt; string.Format(format, arg)); 然后在 XAML 中使用：\n1 \u0026lt;TextBlock Text=\u0026#34;{calc:Binding Path=Format(\u0026#39;{0:C}\u0026#39;, Price)}\u0026#34; /\u0026gt; 类似格式化货币输出，替代 StringFormat\n✅ 示例 10：绑定依赖属性（如控件尺寸） 1 2 3 4 5 \u0026lt;Canvas\u0026gt; \u0026lt;Ellipse Width=\u0026#34;50\u0026#34; Height=\u0026#34;50\u0026#34; Canvas.Left=\u0026#34;{calc:Binding ElementName=canvas, Path=ActualWidth / 2 - 25}\u0026#34; Canvas.Top=\u0026#34;{calc:Binding ElementName=canvas, Path=ActualHeight / 2 - 25}\u0026#34; /\u0026gt; \u0026lt;/Canvas\u0026gt; 计算控件居中位置，不需要在后台代码中设置布局逻辑\n🧪 四、性能与注意事项 注意点 说明 表达式复杂度 避免过于复杂的嵌套表达式，影响可读性和调试 调试困难 表达式错误不会抛出异常，只会显示为空或默认值 性能 相比普通绑定稍慢，但对 UI 影响不大 兼容性 支持 WPF，不支持 UWP 或 .NET MAUI 🎯 五、适合使用的场景 简单的数学计算绑定 字符串拼接 条件控制（Visible/Collapsed） 布局调整（基于控件大小） 替代简单 Converter 的场景 🧩 六、替代方案对比 方案 优点 缺点 CalcBinding 快速编写表达式，无需 Converter 不易调试，不适合复杂逻辑 IValueConverter 更强类型安全和逻辑控制 需要编写额外类 MultiBinding + IMultiValueConverter 支持多值绑定 实现繁琐 XAML Binding.StringFormat 简单格式化 不支持表达式计算 ","date":"2025-06-06T14:46:48+08:00","image":"https://www.notion.so/images/page-cover/rijksmuseum_mignons_1660.jpg","permalink":"https://dumbnessrf.github.io/p/calcbinding/","title":"WPF技巧-XAML中使用表达式进行数据绑定计算"},{"content":"ReactiveUI 基础用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 using System; using System.Reactive.Linq; using ReactiveUI; namespace AvaloniaApplication1.ViewModels; public partial class MainWindowViewModel : ViewModelBase { [ObservableProperty] public partial string Text1 { get; set; } [ObservableProperty] public partial string Text2 { get; set; } [ObservableProperty] public partial string Result { get; set; } public MainWindowViewModel() { this.WhenAnyValue(s =\u0026gt; s.Text1, s =\u0026gt; s.Text2) .Where(s =\u0026gt; double.TryParse(s.Item1, out _) \u0026amp;\u0026amp; double.TryParse(s.Item2, out _)) .Subscribe(s =\u0026gt; Calculate()); this.WhenAnyValue(s =\u0026gt; s.Text1, s =\u0026gt; s.Text2) .Where(s =\u0026gt; !double.TryParse(s.Item1, out _) || !double.TryParse(s.Item2, out _)) .Subscribe(s =\u0026gt; Clear()); } void Calculate() { Result = (double.Parse(Text1) + double.Parse(Text2)).ToString(); } void Clear() { Result = string.Empty; } } 只有当Text1和Text2发生变化且不为空时才订阅Calculate事件，为空时订阅Clear事件\nWhenAny、WhenAnyValue、WhenAnyObservable WhenAny 是一组扩展方法，每个方法都以前缀 WhenAny 开头，可用于在对象的属性发生更改时获取通知。\n在可能的情况下，WhenAnyValue 应该优先于 WhenAny，并且您不需要知道Sender或Expression\nWhenAny 变体支持多种属性更改通知。例如，它可以支持视图模型的 INotifyPropertyChanged 、基于 Windows 的 XAML 平台上的 DependencyProperty 以及 Apple 平台上的 NSObject 属性更改通知。要获取值更改通知，您的对象必须实现这些已知的属性更改通知机制之一。 如果其中一个不支持，您将只能获取属性的初始值，而不会收到任何更新通知。此外，运行时还会发出警告（请确保您已注册 ILogger 服务以便查看此警告）。\nWhenAnyValue IObservable\u0026lt;TRet\u0026gt; WhenAnyValue\u0026lt;TSender, TRet\u0026gt;( this TSender? sender, Expression\u0026lt;Func\u0026lt;TSender, TRet\u0026gt;\u0026gt; property1)\n由于表达式尚不支持此功能，因此 WhenAnyValue 不能直接执行空传播。 你可以通过将 WhenAnyValue() 调用链接到每个属性来模拟对空值传播的支持。以下是示例：\n1 2 this.WhenAnyValue(x =\u0026gt; x.Foo, x =\u0026gt; x.Foo.Bar, x =\u0026gt; x.Foo.Bar.Baz, (foo, bar, baz) =\u0026gt; foo?.Bar?.Baz) .Subscribe(x =\u0026gt; Console.WriteLine(x)); WhenAny WhenAny 允许您获取传递到 WhenAny 中的表达式和表达式。这对于一些场景是很有用的，比如在视图中，你需要知道调用属性改变的控件。\nWhenAny 仅告知您输入表达式的最终值何时发生变化。即使最终的变化是由于表达式链中的中间值引起的，也是如此。以下是一个解释性示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 this.WhenAny(x =\u0026gt; x.Foo.Bar.Baz, _ =\u0026gt; \u0026#34;Hello!\u0026#34;) .Subscribe(x =\u0026gt; Console.WriteLine(x)); // Example 1 this.Foo.Bar.Baz = \u0026#34;Something\u0026#34;; \u0026gt;\u0026gt;\u0026gt; Hello! // Example 2: Nothing printed! Because the string value does not change this.Foo.Bar.Baz = \u0026#34;Something\u0026#34;; // Example 3: Still nothing！Because the expression is Foo.Bar.Baz，not Foo.Bar this.Foo.Bar = new Bar() { Baz = \u0026#34;Something\u0026#34; }; // Example 4: The result changes, so we print this.Foo.Bar = new Bar() { Baz = \u0026#34;Else\u0026#34; }; \u0026gt;\u0026gt;\u0026gt; Hello! WhenAny 仅在读取给定表达式不会抛出 NullReferenceException 时才会发送通知。请考虑以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 this.WhenAny(x =\u0026gt; x.Foo.Bar.Baz, _ =\u0026gt; \u0026#34;Hello!\u0026#34;) .Subscribe(x =\u0026gt; Console.WriteLine(x)); // Example 1 this.Foo.Bar.Baz = null; \u0026gt;\u0026gt;\u0026gt; Hello! // Example 2: Nothing printed! this.Foo.Bar = null; // Example 3 this.Foo.Bar = new Bar() { Baz = \u0026#34;Something\u0026#34; }; \u0026gt;\u0026gt;\u0026gt; Hello! WhenAnyObservable WhenAnyObservable 会观察一个或多个可观察对象并提供最新的可观察值，处理新可观察对象的自动订阅以及 WhenAnyObservable 可观察对象的处理。WhenAnyObservable 默认为惰性订阅，这意味着在订阅之前不会获得任何值(其他的When在Ctor完成时就会通知，这个只有在更改时才会通知)。\n每当文档保存时，它都会打印来自 IsSaved 可观察变量的值。当 Document 属性发生更改时，它将自动取消订阅并重新订阅。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class MyViewModel { [Reactive] public Document Document { get; set; } public MyViewModel() { this.WhenAnyObservable(x =\u0026gt; x.Document.IsSaved).Subscribe(x =\u0026gt; Console.WriteLine($\u0026#34;Document Saved: {x}\u0026#34;)); } } public class Document { public IObservable\u0026lt;bool\u0026gt; IsSaved { get; } } Where 仅从 Observable 中发出那些通过谓词测试的项 IObservable\u0026lt;TSource\u0026gt; Where\u0026lt;TSource\u0026gt;(this IObservable\u0026lt;TSource\u0026gt; source, Func\u0026lt;TSource, bool\u0026gt; predicate)\nSubscribe 根据事件源的发出的事件或通知进行操作\n注意：该操作符之后将返回IDisposable，而不是IObservable\nIDisposable Subscribe\u0026lt;T\u0026gt;(this IObservable\u0026lt;T\u0026gt; source, Action\u0026lt;T\u0026gt; onNext)\nSubscribeOn 指定事件源在订阅时应使用的调度器\nSubscribeOn 运算符指定 Observable 将开始在哪个线程上运行，而不管该运算符在运算符链中的哪个点被调用。另一方面，ObserveOn 会影响 Observable 将使用的线程， 该线程位于该运算符出现的位置下方。 因此，您可以调用 在 Observable 链中的不同点多次进行 ObserveOn 运算符，以便更改某些运算符在哪些线程上进行作。\nIObservable\u0026lt;TSource\u0026gt; SubscribeOn\u0026lt;TSource\u0026gt;(this IObservable\u0026lt;TSource\u0026gt; source, IScheduler scheduler)\n📢 1 2 3 4 this.WhenAnyValue(s =\u0026gt; s.Text1, s =\u0026gt; s.Text2) .SubscribeOn(RxApp.MainThreadScheduler) .SubscribeOn(RxApp.TaskpoolScheduler) .SubscribeOn(SynchronizationContext.Current) 📢 RxApp.MainThreadScheduler\n获取或设置一个调度器，该调度器用于对那些应在 “用户界面 (UI) 线程上” 运行的工作项进行调度。在正常模式下，这将是 DispatcherScheduler（分发器调度器），而在单元测试模式下，这将是 Immediate（即时调度器），以便简化常见单元测试的编写工作。\nRxApp.TaskpoolScheduler\n获取或设置用于调度工作项以在后台线程中运行的调度器。在两种模式下，这些工作项都将在 TPL（任务并行库）任务池中运行。\nSynchronizationContext.Current Thread.CurrentThread._synchronizationContext\nThrottle 此操作符会对源序列进行限流，具体做法是对每个元素保留 dueTime（指定时长）。若在这个时间窗口内又产生了另一个元素，那么前一个元素会被丢弃，并且会为当前元素启动一个新的计时器，如此循环往复。对于元素间间隔从不大于或等于 dueTime 的流，经过处理后的流将不会产生任何元素。若要在保证元素周期性产生的同时减少流的数据量，可考虑使用 Observable.Sample 系列操作符。\n1 2 3 this.WhenAnyValue(s =\u0026gt; s.Text1) .Throttle(TimeSpan.FromSeconds(1)) .Subscribe(s =\u0026gt; Calculate()); Sample、Interval 1 2 3 4 5 6 var sub = Observable .Interval(TimeSpan.FromSeconds(0.01)) .Sample(TimeSpan.FromMilliseconds(500)) .Subscribe(s =\u0026gt; Result=s.ToString()); await Task.Delay(TimeSpan.FromSeconds(2)); sub.Dispose(); 每 10 毫秒发出一个值的可观察序列，每 500 毫秒对这个序列进行一次采样，将采样得到的值转换为字符串并赋值给 Result 变量，持续执行 2 秒后取消订阅并释放资源；尽管2s内通过Interval产生了200个，但是由于Sample，我只采样到了4个\nTimer、Amb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 using System.Reactive.Linq; var observable1 = Observable.Timer(TimeSpan.FromMilliseconds(200)) .Select(_ =\u0026gt; \u0026#34;Observable 1\u0026#34;); // 创建第二个可观测序列，延迟 100 毫秒后发射元素 var observable2 = Observable.Timer(TimeSpan.FromMilliseconds(100)) .Select(_ =\u0026gt; \u0026#34;Observable 2\u0026#34;); // 使用 Amb 操作符选择第一个产生元素的序列 var result = observable1.Amb(observable2); // 订阅结果序列 result.Subscribe( value =\u0026gt; Console.WriteLine($\u0026#34;Received: {value}\u0026#34;), error =\u0026gt; Console.WriteLine($\u0026#34;Error: {error}\u0026#34;), () =\u0026gt; Console.WriteLine(\u0026#34;Completed\u0026#34;) ); 借助 Observable.Timer 来创建两个可观测序列 observable1 和 observable2，它们会在特定延迟后发射元素。\n在这个示例中，由于 observable2 延迟 100 毫秒，比 observable1 的 200 毫秒延迟要短，所以 observable2 会率先产生元素，Amb 操作符会选择 observable2 并忽略 observable1。\nReceived: Observable 2\nCompleted\nRetry、Catch Retry允许在发生错误时或抛出错误时重新订阅源序列。例如，以下代码创建一个会抛出异常的序列，并通过Retry(2)最多重试2次：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 using System; using System.Reactive.Disposables; using System.Reactive.Linq; var source = Observable.Create\u0026lt;int\u0026gt;(observer =\u0026gt; { Console.WriteLine(\u0026#34;Doing work...\u0026#34;); // throw new Exception(\u0026#34;Initial failure\u0026#34;); observer.OnError(new Exception(\u0026#34;Initial failure\u0026#34;)); return Disposable.Empty; }); source .Retry(2) // 发生错误时重新订阅源序列，最多尝试2次 .Subscribe( x =\u0026gt; Console.WriteLine(\u0026#34;OnNext: \u0026#34; + x), ex =\u0026gt; Console.WriteLine(\u0026#34;OnError: \u0026#34; + ex.Message), () =\u0026gt; Console.WriteLine(\u0026#34;OnCompleted\u0026#34;) ); 输出\nDoing work\u0026hellip;\nDoing work\u0026hellip;\nOnError: Initial failure\n**Catch**用于捕获异常并替换为新的序列。例如，以下代码在发生错误后返回一个备用值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 using System; using System.Reactive.Disposables; using System.Reactive.Linq; var source = Observable.Create\u0026lt;int\u0026gt;(observer =\u0026gt; { observer.OnError(new Exception(\u0026#34;Primary error\u0026#34;)); return Disposable.Empty; }); source .Catch(Observable.Return(42)) // 捕获异常并替换为值42 .Subscribe( x =\u0026gt; Console.WriteLine(\u0026#34;OnNext: \u0026#34; + x), ex =\u0026gt; Console.WriteLine(\u0026#34;OnError: \u0026#34; + ex.Message), () =\u0026gt; Console.WriteLine(\u0026#34;OnCompleted\u0026#34;) ); OnNext: 42\nOnCompleted\nScan、Buffer Scan 用于对序列中的每个元素连续应用累积函数，并输出中间结果。类似于LINQ的 Aggregate，但会发射所有中间值\n1 2 3 4 5 6 7 using System.Reactive.Linq; var source = Observable.Range(1, 5); // 生成1到5的序列 source .Scan(0, (acc, val) =\u0026gt; acc + val) // 初始值0，累加当前值 .Subscribe(x =\u0026gt; Console.WriteLine(\u0026#34;Scan Result: \u0026#34; + x)); Scan Result: 1\nScan Result: 3\nScan Result: 6\nScan Result: 10\nScan Result: 15\nBuffer 将事件流按时间或数量分组，输出批量数据。常见用法包括按时间窗口或元素数量缓冲。\n1 2 3 4 5 6 7 8 9 using System.Reactive.Linq; var source = Observable.Interval(TimeSpan.FromSeconds(1)) // 每秒发射递增数 .Take(10); // 限制总发射次数 // 按时间窗口（5秒）和最大数量（3个元素）缓冲 source .Buffer(TimeSpan.FromSeconds(5), 3) .Subscribe(buffer =\u0026gt; Console.WriteLine($\u0026#34;Buffered Count: {buffer.Count}\u0026#34;)); Buffered Count: 3 // 第1-3秒的数据\nBuffered Count: 3 // 第4-5秒的数据（可能触发时间窗口）\nBuffered Count: 3 // 下一个窗口\nBuffered Count: 1 // 剩余1个元素\n📢 Buffer 支持多种分组策略，如纯时间窗口（Buffer(TimeSpan)）、纯数量（Buffer(count)）或两者结合\nDistinct、DistinctUntilChanged Distinct：过滤序列中所有重复的元素，仅保留首次出现的元素。\n1 2 3 4 var source = new[] { 1, 2, 2, 3, 3, 3 }; source.ToObservable() .Distinct() .Subscribe(x =\u0026gt; Console.WriteLine(x)); 输出 ：1, 2, 3\nDistinctUntilChanged：仅过滤连续重复 的元素，保留第一个，后续连续相同的元素被丢弃。\n1 2 3 4 var source = new[] { 1, 2, 2, 3, 2, 2 }; source.ToObservable() .DistinctUntilChanged() .Subscribe(x =\u0026gt; Console.WriteLine(x)); 输出 ：1, 2, 3, 2\nZip Zip 用于合并两个序列，逐个配对元素并生成结果。在 Rx 中，它常用于组合多个异步数据流。\n1 2 3 4 5 6 7 using System.Reactive.Linq; var numbers = Observable.Range(1, 3); // 1, 2, 3 var letters = Observable.Return(\u0026#34;A\u0026#34;).Concat(Observable.Return(\u0026#34;B\u0026#34;)); // A, B numbers.Zip(letters, (n, l) =\u0026gt; $\u0026#34;{n}{l}\u0026#34;) .Subscribe(result =\u0026gt; Console.WriteLine(result)); 1A\n2B\nDelay、Do、TimeInterval 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 using System; using System.Reactive.Linq; using System.Reactive.Concurrency; class Program { static void Main() { var source = Observable.Interval(TimeSpan.FromSeconds(1)) // 每秒发射递增数 .Take(5); // 限制发射次数为5次 source .Delay(TimeSpan.FromSeconds(0.5)) // 延迟0.5秒后发射元素 [[4]] .Do(x =\u0026gt; Console.WriteLine($\u0026#34;Do: 被延迟的值 = {x}\u0026#34;)) // 记录中间状态 [[6]] .TimeInterval() // 测量连续事件的时间间隔 [[1]] .Subscribe( interval =\u0026gt; Console.WriteLine($\u0026#34;TimeInterval: 值={interval.Value}, 间隔={interval.Interval.TotalSeconds}秒\u0026#34;), ex =\u0026gt; Console.WriteLine($\u0026#34;OnError: {ex.Message}\u0026#34;), () =\u0026gt; Console.WriteLine(\u0026#34;OnCompleted\u0026#34;) // 序列结束 [[10]] ); // 确保主线程等待足够时间以观察输出 Console.ReadLine(); } } 流程 ： 每秒生成一个数字（Interval）。 延迟0.5秒后发射（Delay）。 记录延迟后的值（Do）。 计算相邻值的发射时间间隔（TimeInterval）。 序列结束时自动触发 OnCompleted。 Do: 被延迟的值 = 0\nTimeInterval: 值=0, 间隔=1.5369618秒\nDo: 被延迟的值 = 1\nTimeInterval: 值=1, 间隔=0.9820277秒\nDo: 被延迟的值 = 2\nTimeInterval: 值=2, 间隔=0.9995484秒\nDo: 被延迟的值 = 3\nTimeInterval: 值=3, 间隔=1.0001499秒\nDo: 被延迟的值 = 4\nTimeInterval: 值=4, 间隔=1.0005686秒\nOnCompleted\nAverage、Concat、Count、Max、Min、Aggregate、Sum 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 using System; using System.Reactive.Linq; class Program { static void Main() { // 创建第一个序列 var source1 = Observable.Range(1, 3); // 发射 1, 2, 3 // 创建第二个序列 var source2 = Observable.Range(4, 2); // 发射 4, 5 // 使用 Concat 合并两个序列 [[3]] var concatenated = source1.Concat(source2); // 应用聚合操作符 concatenated .Count() // 计算总项数 [[1]] .Subscribe(count =\u0026gt; Console.WriteLine($\u0026#34;Total Count: {count}\u0026#34;)); concatenated .Sum() // 计算总和 [[9]] .Subscribe(sum =\u0026gt; Console.WriteLine($\u0026#34;Total Sum: {sum}\u0026#34;)); concatenated .Average() // 计算平均值 [[9]] .Subscribe(avg =\u0026gt; Console.WriteLine($\u0026#34;Average: {avg}\u0026#34;)); concatenated .Min() // 查找最小值 .Subscribe(min =\u0026gt; Console.WriteLine($\u0026#34;Min: {min}\u0026#34;)); concatenated .Max() // 查找最大值 .Subscribe(max =\u0026gt; Console.WriteLine($\u0026#34;Max: {max}\u0026#34;)); // 使用 Aggregate 自定义聚合逻辑（类似 Sum） concatenated .Aggregate((acc, val) =\u0026gt; acc + val) // 累积求和 [[9]] .Subscribe(total =\u0026gt; Console.WriteLine($\u0026#34;Reduce (Custom Sum): {total}\u0026#34;)); Console.ReadLine(); // 防止控制台退出 } } Total Count: 5\nTotal Sum: 15\nAverage: 3\nMin: 1\nMax: 5\nReduce (Custom Sum): 15\nAll、Contains、TakeUntil、StartWith 、Join 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 using System; using System.Reactive.Linq; class Program { static void Main() { // 示例序列1：数字序列 [1, 2, 3, 4, 5] var numbers = Observable.Range(1, 5); // 示例序列2：字符串序列 [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;] var letters = Observable.Range(0, 3).Select(x =\u0026gt; ((char)(\u0026#39;A\u0026#39; + x)).ToString()); // StartWith: 在序列开始前添加元素 [0, 1, 2, 3, 4, 5] var startWithExample = numbers.StartWith(0); startWithExample.Subscribe(x =\u0026gt; Console.WriteLine($\u0026#34;StartWith: {x}\u0026#34;)); // All: 检查所有元素是否大于0 numbers.All(x =\u0026gt; x \u0026gt; 0) .Subscribe(result =\u0026gt; Console.WriteLine($\u0026#34;All \u0026gt; 0: {result}\u0026#34;)); // 输出 true // Contains: 判断序列是否包含元素 3 numbers.Contains(3) .Subscribe(result =\u0026gt; Console.WriteLine($\u0026#34;Contains 3: {result}\u0026#34;)); // 输出 true // TakeUntil: 当另一个序列（如定时器）触发时停止 var takeUntilExample = numbers.TakeUntil(Observable.Timer(TimeSpan.FromSeconds(2))); takeUntilExample.Subscribe( x =\u0026gt; Console.WriteLine($\u0026#34;TakeUntil: {x}\u0026#34;), () =\u0026gt; Console.WriteLine(\u0026#34;TakeUntil Completed\u0026#34;)); // Join: 合并两个序列（基于时间窗口） var now = DateTime.Now; var source1 = Observable.Interval(TimeSpan.FromSeconds(1)).Take(3).Select(x =\u0026gt; $\u0026#34;N{x}\u0026#34;); var source2 = Observable.Interval(TimeSpan.FromSeconds(1.5)).Take(3).Select(x =\u0026gt; $\u0026#34;L{x}\u0026#34;); source1.Join( source2, _ =\u0026gt; Observable.Timer(TimeSpan.FromSeconds(2)), // 左侧元素存活时间 _ =\u0026gt; Observable.Timer(TimeSpan.FromSeconds(2)), // 右侧元素存活时间 (n, l) =\u0026gt; $\u0026#34;{n}+{l}\u0026#34; ).Subscribe(result =\u0026gt; Console.WriteLine($\u0026#34;Join Result: {result}\u0026#34;)); Console.ReadLine(); // 防止控制台退出 } } 应用StartWith添加初始元素。 使用All检查条件。 使用Contains判断是否存在元素。 使用TakeUntil在另一个序列触发后停止。 使用Join合并两个序列。 每个操作符后订阅结果并输出。 添加必要的引用标注。 StartWith: 0\nStartWith: 1\nStartWith: 2\nStartWith: 3\nStartWith: 4\nStartWith: 5\nAll \u0026gt; 0: True\nContains 3: True\nTakeUntil: 1\nTakeUntil: 2\nTakeUntil: 3\nTakeUntil: 4\nTakeUntil: 5\nTakeUntil Completed\nJoin Result: N0+L0\nJoin Result: N1+L0\nJoin Result: N0+L1\nJoin Result: N1+L1\nJoin Result: N2+L0\nJoin Result: N2+L1\nJoin Result: N2+L2\n","date":"2025-06-06T11:04:44+08:00","image":"https://www.notion.so/images/page-cover/woodcuts_6.jpg","permalink":"https://dumbnessrf.github.io/p/reactive_programing/","title":"ReactiveUI 与 Rx 常用方法总结"},{"content":"什么是依赖注入（Dependency Injection） 📌 概念 依赖注入（Dependency Injection，简称 DI）是一种常见的软件设计模式，主要用于解耦组件之间的依赖关系，提高代码的可维护性和可测试性。\n在 C# 开发中，如果不使用依赖注入，类 A 可能会在内部直接实例化类 B，导致两个类之间形成强耦合。而通过依赖注入的方式，可以将类 B 的实例从外部传递给类 A（通常通过构造函数、属性或方法参数），从而实现松耦合的设计。\n✅ 主要作用 提升可维护性\n当系统规模变大时，如果各个组件之间紧密耦合，修改一个组件可能会引发连锁反应。通过依赖注入，可以使依赖关系更加清晰明了，便于后期维护。\n简化单元测试\n在编写单元测试时，可以轻松地模拟（Mock）依赖对象，而不是依赖真实的复杂对象，使测试更简单、更精准。\n🛠 常用依赖注入框架及示例 1. Microsoft.Extensions.DependencyInjection 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 using Microsoft.Extensions.DependencyInjection; class MyClassA { private readonly MyClassB _dependency; public MyClassA(MyClassB dependency) =\u0026gt; _dependency = dependency; public void DoSomething() =\u0026gt; _dependency.SomeMethod(); } class MyClassB { public void SomeMethod() =\u0026gt; Console.WriteLine(\u0026#34;MyClassB\u0026#39;s method is called.\u0026#34;); } class Program { static void Main() { var serviceCollection = new ServiceCollection(); serviceCollection.AddTransient\u0026lt;MyClassB\u0026gt;(); serviceCollection.AddTransient\u0026lt;MyClassA\u0026gt;(); var serviceProvider = serviceCollection.BuildServiceProvider(); var a = serviceProvider.GetService\u0026lt;MyClassA\u0026gt;(); a.DoSomething(); } } 2. Autofac 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 using Autofac; class MyClassA { private readonly MyClassB _dependency; public MyClassA(MyClassB dependency) =\u0026gt; _dependency = dependency; public void DoSomething() =\u0026gt; _dependency.SomeMethod(); } class MyClassB { public void SomeMethod() =\u0026gt; Console.WriteLine(\u0026#34;MyClassB\u0026#39;s method is called.\u0026#34;); } class Program { static void Main() { var builder = new ContainerBuilder(); builder.RegisterType\u0026lt;MyClassB\u0026gt;().AsSelf(); builder.RegisterType\u0026lt;MyClassA\u0026gt;().AsSelf(); var container = builder.Build(); var a = container.Resolve\u0026lt;MyClassA\u0026gt;(); a.DoSomething(); } } 什么是动态加载程序集（Dynamic Assembly Loading） 📌 定义 在 C# 中，动态加载程序集允许程序在运行时加载并使用 DLL 文件，而不是在编译时静态引用它们。这种方式提供了更高的灵活性，例如：\n根据不同的条件或用户需求加载不同的功能模块。 在程序运行过程中更新某些功能模块，而无需重新编译整个项目。 🧪 示例：动态加载 DLL 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 using System.Reflection; class Program { static void Main() { // 加载程序集 Assembly assembly = Assembly.Load(\u0026#34;xxx.dll\u0026#34;); // 获取类型 Type type = assembly.GetType(\u0026#34;MyNamespace.MyClass\u0026#34;); // 创建实例 object instance = Activator.CreateInstance(type); // 调用方法 MethodInfo method = type.GetMethod(\u0026#34;DoSomething\u0026#34;); method.Invoke(instance, null); } } ⚠️ 注意：使用 Assembly.Load(\u0026quot;xxx.dll\u0026quot;) 加载的程序集会一直占用该 DLL 文件。若需要卸载或更新 DLL，建议使用如下方式：\n1 2 byte[] rawAssembly = File.ReadAllBytes(dllPath); Assembly assembly = Assembly.Load(rawAssembly); 🔄 将动态加载的 DLL 注入到依赖容器中（以 Autofac 为例） 我们以 Autofac 作为依赖注入容器，演示如何对动态加载的 DLL 进行服务注册与解析。\n步骤 1：加载程序集 1 2 byte[] rawAssembly = File.ReadAllBytes(dllPath); Assembly assembly = Assembly.Load(rawAssembly); 步骤 2：定义注入特性（Attribute） 为了筛选需要注册的服务类型，我们可以自定义一个 [Inject] 特性：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)] public class InjectAttribute(string name, string category) : Attribute { public string Name { get; } = name; public string Category { get; } = category; } public interface ITool { void DoWork(); void ShowDialog(); } // 示例类 [Inject(\u0026#34;工具2\u0026#34;, \u0026#34;类别1\u0026#34;)] public class MainFrame : ITool { public void DoWork() { /* 实现逻辑 */ } public void ShowDialog() { /* 实现逻辑 */ } } 步骤 3：注册服务到 Autofac 容器 1 2 3 4 5 6 7 8 9 10 11 12 13 var builder = new ContainerBuilder(); var types = assembly.DefinedTypes.ToList().Where(IsToolType).ToList(); foreach (var type in types) { var attr = type.CustomAttributes.First(a =\u0026gt; a.AttributeType == typeof(InjectAttribute)); var name = attr.ConstructorArguments[0].Value?.ToString(); var category = attr.ConstructorArguments[1].Value?.ToString(); string key = $\u0026#34;{category}_{name}\u0026#34;; builder.RegisterType(type).Named\u0026lt;ITool\u0026gt;(key); } 步骤 4：构建容器并解析服务 1 2 3 4 5 6 7 8 9 10 var container = builder.Build(); var tool1 = container.ResolveNamed\u0026lt;ITool\u0026gt;(\u0026#34;类别1_工具1\u0026#34;); tool1.DoWork(); var tool2 = container.ResolveNamed\u0026lt;ITool\u0026gt;(\u0026#34;类别1_工具2\u0026#34;); tool2.ShowDialog(); var tool3 = container.ResolveNamed\u0026lt;ITool\u0026gt;(\u0026#34;类别2_工具1\u0026#34;); tool3.ShowDialog(); 🧩 依赖自动解析能力 当被注入的类型存在其他依赖项时，如日志 (ILogger) 或数据库 (IDatabase) 接口，依赖注入容器会自动完成这些依赖的解析。\n1 2 3 4 5 6 7 8 9 10 public interface ILogger { void Log(string message); } public interface IDatabase { List\u0026lt;string\u0026gt; Select(); void Insert\u0026lt;T\u0026gt;(T entity); } 示例：单例注入 1 2 builder.RegisterType\u0026lt;ConsoleLogger\u0026gt;().SingleInstance().As\u0026lt;ILogger\u0026gt;(); builder.RegisterType\u0026lt;MysqlMocker\u0026gt;().SingleInstance().As\u0026lt;IDatabase\u0026gt;(); 使用示例类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 [Inject(\u0026#34;工具1\u0026#34;, \u0026#34;类别1\u0026#34;)] public class Tool1 : ITool { private readonly ILogger _logger; private readonly IDatabase _database; public Tool1(ILogger logger, IDatabase database) { _logger = logger; _database = database; } public void DoWork() { _logger.Log(\u0026#34;This is a log message from Tool1\u0026#34;); _logger.Log(\u0026#34;Doing work in MainFrame\u0026#34;); var data = _database.Select(); var str = JsonConvert.SerializeObject(data); _logger.Log($\u0026#34;Data from database: {str}\u0026#34;); } public void ShowDialog() { } } ✅ 总结 功能 描述 依赖注入 解耦组件，提升可维护性和可测试性 动态加载 灵活加载 DLL，支持热插拔和运行时扩展 结合使用 可以将动态加载的 DLL 类型注册为服务，并由 DI 容器管理其生命周期和依赖关系 通过上述方式，你可以实现一个高度模块化、易于扩展和维护的 C# 应用架构，适用于插件式系统、微服务架构等场景。\n","date":"2025-06-04T14:04:44+08:00","image":"https://www.notion.so/images/page-cover/met_william_morris_1877_willow.jpg","permalink":"https://dumbnessrf.github.io/p/dependency_injection_with_dynamic_loaded_dll.md/","title":"C#对动态加载的DLL依赖注入"},{"content":"🧩 Avalonia 框架概览 🔍 简介 Avalonia 是一个 跨平台的 .NET 用户界面框架，支持使用 C# 和 XAML 构建桌面、移动和 Web 应用程序。其设计灵感来源于 WPF 和 UWP，但具有更强的跨平台兼容性。\n✅ 主要特点： 使用熟悉的 XAML 语法 支持多种 UI 控件和样式 可运行于多个操作系统 支持 MVVM 模式及依赖注入 🌐 平台支持 Avalonia 支持以下平台：\n平台 支持情况 Windows 完全支持 Linux 完全支持 macOS 完全支持 Android/iOS 实验性支持（需额外适配） WebAssembly 支持（通过 WASM 渲染器） 💡 Avalonia 提供了真正的跨平台开发能力，适用于需要统一多端体验的应用场景。\n⚙️ 性能表现 Avalonia 的渲染引擎经过优化，具备高效的绘制能力和良好的硬件加速支持，尤其在处理复杂图形与数据可视化时表现出色。\n高效的渲染管道 支持 GPU 加速 低延迟响应用户交互 例如：当应用中存在大量动态图表或动画元素时，Avalonia 能保持流畅的帧率，避免卡顿现象。\n🔄 Microsoft.Extensions.DependencyInjection 详解 📦 概述 Microsoft.Extensions.DependencyInjection 是 .NET 中的一个 轻量级依赖注入（DI）容器，它提供了一种灵活的方式来管理应用程序中的对象及其依赖关系。\n💡 为什么使用 DI？ 解耦业务逻辑与具体实现 提高代码可测试性和可维护性 支持模块化开发 🕒 服务生命周期（Service Lifecycle） 生命周期类型 描述 Transient（瞬态） 每次请求都会创建新实例，适合无状态服务 Scoped（作用域） 同一作用域内共享同一个实例，常用于 Web 请求上下文 Singleton（单例） 整个应用程序周期内共享唯一实例，适合全局资源管理 示例说明： Transient：每次调用 IDataProcessor 都会返回一个新的实例。 Scoped：在一次 HTTP 请求中，所有对 IDatabaseContext 的请求都返回同一个实例。 Singleton：如 IAppSettings，在整个应用程序中始终为同一实例。 🧪 示例：在 Avalonia 中集成依赖注入 📝以下示例将添加Redis和第三方Avalonia样式库SukiUI作为参考\n1️⃣ 安装依赖注入包 1 install-package Microsoft.Extensions.DependencyInjection 2️⃣ 初始化服务容器 在 App.xaml.cs 中重写 OnFrameworkInitializationCompleted() 方法以注册并构建服务容器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public override void OnFrameworkInitializationCompleted() { var collection = new ServiceCollection(); collection.AddCommonServices(); collection.AddDistributedCache(); _services = collection.BuildServiceProvider(); var vm = _services.GetRequiredService\u0026lt;MainWindowViewModel\u0026gt;(); var toastService = _services.GetRequiredService\u0026lt;ISukiToastManager\u0026gt;(); var dialogService = _services.GetRequiredService\u0026lt;ISukiDialogManager\u0026gt;(); if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop) { desktop.MainWindow = _services.GetRequiredService\u0026lt;MainWindow\u0026gt;(); } else if (ApplicationLifetime is ISingleViewApplicationLifetime singleViewPlatform) { singleViewPlatform.MainView = new MainWindow(toastService, dialogService) { DataContext = vm, }; } base.OnFrameworkInitializationCompleted(); } 3️⃣ 注册服务 自定义扩展方法注册常用服务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static void AddCommonServices(this IServiceCollection collection) { collection.AddSingleton\u0026lt;MainWindowViewModel\u0026gt;(); collection.AddSingleton\u0026lt;MainWindow\u0026gt;(s =\u0026gt; new MainWindow( s.GetRequiredService\u0026lt;ISukiToastManager\u0026gt;(), s.GetRequiredService\u0026lt;ISukiDialogManager\u0026gt;() ) { DataContext = s.GetRequiredService\u0026lt;MainWindowViewModel\u0026gt;(), }); collection.AddSingleton\u0026lt;ISukiToastManager\u0026gt;(s =\u0026gt; DialogExManager.GetToastManager()); collection.AddSingleton\u0026lt;ISukiDialogManager\u0026gt;(s =\u0026gt; DialogExManager.GetDialogManager()); } 注册 Redis 缓存服务 1 2 3 4 5 6 7 8 9 10 11 12 public static void AddDistributedCache(this IServiceCollection collection) { var connection = ConnectionMultiplexer.Connect(\u0026#34;127.0.0.1:6379\u0026#34;); var redis = connection.GetDatabase(); collection.AddSingleton(redis); collection.AddSingleton(connection); collection.AddSingleton\u0026lt;IDistributedCache, RedisCache\u0026gt;(s =\u0026gt; { return new RedisCache(s.GetRequiredService\u0026lt;IDatabase\u0026gt;()); }); } 4️⃣ 辅助类：对话框与 Toast 管理器 1 2 3 4 5 6 7 8 public static class DialogExManager { private static readonly ISukiToastManager ToastManager = new SukiToastManager(); private static readonly ISukiDialogManager DialogManager = new SukiDialogManager(); public static ISukiToastManager GetToastManager() =\u0026gt; ToastManager; public static ISukiDialogManager GetDialogManager() =\u0026gt; DialogManager; } 5️⃣ 视图定位器（ViewLocator） 如果启用了 ViewLocator，则 ViewModel 与 View 将自动绑定。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class ViewLocator : IDataTemplate { public Control? Build(object? param) { if (param is null) return null; var name = param.GetType().FullName!.Replace(\u0026#34;ViewModel\u0026#34;, \u0026#34;View\u0026#34;, StringComparison.Ordinal); var type = Type.GetType(name); return type != null ? (Control)Activator.CreateInstance(type)! : new TextBlock { Text = \u0026#34;Not Found: \u0026#34; + name }; } public bool Match(object? data) { return data is ViewModelBase; } } 📝 如果未启用 ViewLocator，则需要手动设置 DataContext。\n✅ 总结 Avalonia 是一个强大的跨平台 UI 框架，结合 Microsoft.Extensions.DependencyInjection 可实现高度解耦和模块化的应用程序架构。通过合理配置服务生命周期和使用视图定位器等机制，可以显著提升开发效率和代码质量。\n","date":"2025-06-04T11:04:44+08:00","image":"https://images.unsplash.com/photo-1649972904349-6e44c42644a7?ixlib=rb-4.0.3\u0026q=85\u0026fm=jpg\u0026crop=entropy\u0026cs=srgb\u0026w=3600","permalink":"https://dumbnessrf.github.io/p/dependency_injection/","title":"Avalonia中使用依赖注入重构代码"},{"content":"Converter 类型详解与使用示例 目录 Normal Converter IMultiValueConverter FuncValueConverter 为了提高 Converter 的利用率，可以将其实例定义为静态资源，避免重复创建实例。例如：\n1 2 3 4 /// \u0026lt;summary\u0026gt; /// 获取 MathAddConverter 的静态实例 /// \u0026lt;/summary\u0026gt; public static MathAddConverter AddConverter { get; } = new MathAddConverter(); 在 XAML 中调用该静态资源的方式如下：\n1 2 \u0026lt;NumericUpDown Grid.Row=\u0026#34;1\u0026#34; Grid.Column=\u0026#34;1\u0026#34; Value=\u0026#34;{Binding Number1, Converter={x:Static MathAddConverter.AddConverter}, ConverterParameter={StaticResource MyConverterParameter}}\u0026#34; /\u0026gt; Normal Converter 普通值转换器（IValueConverter）：用于单个绑定值的转换，但 ConverterParameter 不支持动态绑定。\n示例：AddConverter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class AddConverter : IValueConverter { public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture) { if (value is decimal d1 \u0026amp;\u0026amp; parameter is decimal d2) { return d1 + d2; } return null; } public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture) { if (value is decimal d1 \u0026amp;\u0026amp; parameter is decimal d2) { return d1 - d2; } return null; } } XAML 资源定义 1 2 3 4 \u0026lt;Window.Resources\u0026gt; \u0026lt;conv:AddConverter x:Key=\u0026#34;AddConverter\u0026#34; /\u0026gt; \u0026lt;x:Decimal x:Key=\u0026#34;inputAddValue\u0026#34;\u0026gt;2\u0026lt;/x:Decimal\u0026gt; \u0026lt;/Window.Resources\u0026gt; 使用示例 1 2 3 4 5 6 7 8 9 10 \u0026lt;StackPanel Orientation=\u0026#34;Horizontal\u0026#34;\u0026gt; \u0026lt;TextBlock Classes=\u0026#34;Header\u0026#34; Text=\u0026#34;NormalConverter\u0026#34; /\u0026gt; \u0026lt;TextBlock Text=\u0026#34;Input a number to sum\u0026#34; /\u0026gt; \u0026lt;NumericUpDown Increment=\u0026#34;0.1\u0026#34; Value=\u0026#34;{Binding Number}\u0026#34; /\u0026gt; \u0026lt;TextBlock Text=\u0026#34;Sum\u0026#34; /\u0026gt; \u0026lt;NumericUpDown Value=\u0026#34;{Binding Number, Converter={StaticResource AddConverter}, ConverterParameter={StaticResource inputAddValue}}\u0026#34; /\u0026gt; \u0026lt;/StackPanel\u0026gt; IMultiValueConverter 多值转换器（IMultiValueConverter）：支持多个绑定值输入，ConverterParameter 支持绑定。\n示例：MultiValueAddConverter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class MultiValueAddConverter : IMultiValueConverter { public object? Convert(IList\u0026lt;object?\u0026gt; values, Type targetType, object? parameter, CultureInfo culture) { if (values.Any(s =\u0026gt; s is not decimal)) { return new BindingNotification( new InvalidOperationException( \u0026#34;Not all input parameter type is decimal, this converter only support decimal type\u0026#34; ), BindingErrorType.Error ); } return values.Sum(s =\u0026gt; (decimal)s); } } 使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;StackPanel Orientation=\u0026#34;Horizontal\u0026#34;\u0026gt; \u0026lt;TextBlock Classes=\u0026#34;Header\u0026#34; Text=\u0026#34;MultiValueConverter\u0026#34; /\u0026gt; \u0026lt;TextBlock Text=\u0026#34;Input numbers to sum\u0026#34; /\u0026gt; \u0026lt;NumericUpDown Increment=\u0026#34;0.1\u0026#34; Value=\u0026#34;{Binding Number1}\u0026#34; /\u0026gt; \u0026lt;NumericUpDown Increment=\u0026#34;0.1\u0026#34; Value=\u0026#34;{Binding Number2}\u0026#34; /\u0026gt; \u0026lt;NumericUpDown Increment=\u0026#34;0.1\u0026#34; Value=\u0026#34;{Binding Number3}\u0026#34; /\u0026gt; \u0026lt;TextBlock Text=\u0026#34;Sum\u0026#34; /\u0026gt; \u0026lt;NumericUpDown IsReadOnly=\u0026#34;True\u0026#34;\u0026gt; \u0026lt;NumericUpDown.Value\u0026gt; \u0026lt;MultiBinding Converter=\u0026#34;{StaticResource MultiValueAddConverter}\u0026#34; Mode=\u0026#34;OneWay\u0026#34;\u0026gt; \u0026lt;Binding Path=\u0026#34;Number1\u0026#34; /\u0026gt; \u0026lt;Binding Path=\u0026#34;Number2\u0026#34; /\u0026gt; \u0026lt;Binding Path=\u0026#34;Number3\u0026#34; /\u0026gt; \u0026lt;/MultiBinding\u0026gt; \u0026lt;/NumericUpDown.Value\u0026gt; \u0026lt;/NumericUpDown\u0026gt; \u0026lt;/StackPanel\u0026gt; FuncValueConverter 函数式转换器（FuncValueConverter）：通过委托方式定义转换逻辑，适用于类型明确、逻辑简单的场景。\n示例：字符串转画刷 1 2 3 4 5 6 7 8 9 10 11 12 13 public class FuncValueConverters { public static FuncValueConverter\u0026lt;string?, Brush?\u0026gt; StringToBrushFuncConverter { get; } = new(s =\u0026gt; { Color color; if (Color.TryParse(s, out color) || Color.TryParse($\u0026#34;#{s}\u0026#34;, out color)) { return new SolidColorBrush(color); } return null; }); } 使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;StackPanel Orientation=\u0026#34;Horizontal\u0026#34;\u0026gt; \u0026lt;TextBlock Classes=\u0026#34;Header\u0026#34; Text=\u0026#34;FuncValueConverter\u0026#34; /\u0026gt; \u0026lt;TextBox Text=\u0026#34;red\u0026#34; UseFloatingWatermark=\u0026#34;True\u0026#34; Watermark=\u0026#34;Type the color to parse (e.g.: red, green, blue, #FF112233)\u0026#34;\u0026gt; \u0026lt;TextBox.InnerLeftContent\u0026gt; \u0026lt;Ellipse Fill=\u0026#34;{Binding $parent[TextBox].Text, Converter={x:Static conv:FuncValueConverters.StringToBrushFuncConverter}}\u0026#34; Height=\u0026#34;20\u0026#34; Margin=\u0026#34;5,0,0,0\u0026#34; Stroke=\u0026#34;Gray\u0026#34; StrokeThickness=\u0026#34;1\u0026#34; Width=\u0026#34;20\u0026#34; /\u0026gt; \u0026lt;/TextBox.InnerLeftContent\u0026gt; \u0026lt;/TextBox\u0026gt; \u0026lt;/StackPanel\u0026gt; 如需扩展更多转换逻辑，可以继续添加新的 Converter 或使用 FuncValueConverter 快速实现轻量级转换逻辑。\n","date":"2025-06-04T11:04:44+08:00","image":"https://www.notion.so/images/page-cover/rijksmuseum_jansz_1637.jpg","permalink":"https://dumbnessrf.github.io/p/converter-in-avalonia/","title":"Avalonia中的各种Converter使用"},{"content":"WPF 中的 DataTemplateSelector：高级数据模板选择技巧与应用 在 WPF（Windows Presentation Foundation）开发中，DataTemplate 是我们用来定义如何显示绑定数据的重要工具。然而，有时候我们需要根据不同的数据对象动态地选择不同的 DataTemplate 来呈现 UI。这时，DataTemplateSelector 就派上用场了。\n本文将介绍：\n什么是 DataTemplateSelector 如何自定义一个 DataTemplateSelector 实际应用场景和代码示例 使用技巧与最佳实践 一、什么是 DataTemplateSelector？ DataTemplateSelector 是一个抽象类，它允许你根据绑定项的内容来决定使用哪个 DataTemplate。你可以继承这个类并重写它的 SelectTemplate 方法，从而实现自定义的模板选择逻辑。\n二、如何自定义一个 DataTemplateSelector？ 我们先来看一个简单的例子。\n示例场景：聊天消息列表 假设我们有一个聊天程序，每条消息可能是用户发送的，也可能是系统自动发送的。我们想对这两种消息应用不同的样式。\n1. 定义数据模型 1 2 3 4 5 6 7 8 9 10 11 public class Message { public string Content { get; set; } public MessageType Type { get; set; } } public enum MessageType { User, System } 2. 创建两个不同的 DataTemplate 在 XAML 中定义两种不同风格的消息模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;Window.Resources\u0026gt; \u0026lt;!-- 用户消息模板 --\u0026gt; \u0026lt;DataTemplate x:Key=\u0026#34;UserMessageTemplate\u0026#34;\u0026gt; \u0026lt;Border Background=\u0026#34;LightBlue\u0026#34; Padding=\u0026#34;10\u0026#34; Margin=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding Content}\u0026#34; /\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;!-- 系统消息模板 --\u0026gt; \u0026lt;DataTemplate x:Key=\u0026#34;SystemMessageTemplate\u0026#34;\u0026gt; \u0026lt;Border Background=\u0026#34;LightGray\u0026#34; Padding=\u0026#34;10\u0026#34; Margin=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding Content}\u0026#34; FontStyle=\u0026#34;Italic\u0026#34;/\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/Window.Resources\u0026gt; 3. 自定义 DataTemplateSelector 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class MessageTemplateSelector : DataTemplateSelector { public DataTemplate UserMessageTemplate { get; set; } public DataTemplate SystemMessageTemplate { get; set; } public override DataTemplate SelectTemplate(object item, DependencyObject container) { if (item is Message message) { switch (message.Type) { case MessageType.User: return UserMessageTemplate; case MessageType.System: return SystemMessageTemplate; } } return base.SelectTemplate(item, container); } } 4. 在 XAML 中注册并使用 TemplateSelector 1 2 3 4 5 6 7 8 \u0026lt;Window.Resources\u0026gt; \u0026lt;local:MessageTemplateSelector x:Key=\u0026#34;messageTemplateSelector\u0026#34; UserMessageTemplate=\u0026#34;{StaticResource UserMessageTemplate}\u0026#34; SystemMessageTemplate=\u0026#34;{StaticResource SystemMessageTemplate}\u0026#34; /\u0026gt; \u0026lt;/Window.Resources\u0026gt; \u0026lt;ListBox ItemsSource=\u0026#34;{Binding Messages}\u0026#34; ItemTemplateSelector=\u0026#34;{StaticResource messageTemplateSelector}\u0026#34; /\u0026gt; 注意：local 需要引用你的命名空间，例如：\n1 2 \u0026lt;Window xmlns:local=\u0026#34;clr-namespace:YourNamespace\u0026#34; ... 三、应用场景举例 场景 1：多类型列表展示（如新闻、通知、订单等混合展示） 你可以为不同类型的数据项选择不同的模板，使得同一个列表中能展示多种结构不同的信息。\n场景 2：UI 主题或状态变化 根据对象的状态（如“已读”、“未读”、“错误”等）切换不同的 UI 样式。\n场景 3：个性化内容展示 比如在一个论坛应用中，帖子作者、管理员、普通用户的发言需要不同颜色或图标标识。\n四、使用技巧与最佳实践 ✅ 技巧 1：保持 TemplateSelector 的可复用性 目标： 设计一个通用的 DataTemplateSelector，可以通过依赖属性传入模板，提高组件复用性。\n实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class ReusableTemplateSelector : DataTemplateSelector { public DataTemplate DefaultTemplate { get; set; } public DataTemplate AlternateTemplate { get; set; } public override DataTemplate SelectTemplate(object item, DependencyObject container) { if (item is ICustomType customItem \u0026amp;\u0026amp; customItem.IsSpecial) { return AlternateTemplate; } return DefaultTemplate ?? base.SelectTemplate(item, container); } } // 接口用于判断是否是“特殊类型” public interface ICustomType { bool IsSpecial { get; } } 使用 XAML： 1 2 3 \u0026lt;local:ReusableTemplateSelector x:Key=\u0026#34;reusableSelector\u0026#34; DefaultTemplate=\u0026#34;{StaticResource NormalTemplate}\u0026#34; AlternateTemplate=\u0026#34;{StaticResource SpecialTemplate}\u0026#34; /\u0026gt; 应用场景： 多个页面中重复使用同一个选择器。 不同业务逻辑下只需更换绑定的 DataTemplate。 ✅ 技巧 2：结合 MVVM 模式使用 目标： 在 MVVM 架构中使用 DataTemplateSelector，将 UI 展示与数据分离。\n实现： ViewModel 示例： 1 2 3 4 5 6 7 8 9 10 11 public class MessageViewModel : INotifyPropertyChanged { public string Content { get; set; } public MessageType Type { get; set; } // User / System } public enum MessageType { User, System } 自定义 Selector： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class MessageTypeSelector : DataTemplateSelector { public DataTemplate UserTemplate { get; set; } public DataTemplate SystemTemplate { get; set; } public override DataTemplate SelectTemplate(object item, DependencyObject container) { if (item is MessageViewModel msg) { return msg.Type == MessageType.User ? UserTemplate : SystemTemplate; } return base.SelectTemplate(item, container); } } XAML 中绑定： 1 2 \u0026lt;ListBox ItemsSource=\u0026#34;{Binding Messages}\u0026#34; ItemTemplateSelector=\u0026#34;{StaticResource messageTypeSelector}\u0026#34; /\u0026gt; 优势： 完全解耦 View 和 ViewModel。 易于维护和测试。 ✅ 技巧 3：避免过度复杂的逻辑 目标： 确保 SelectTemplate 方法逻辑简洁，不嵌套复杂判断。\n反面例子（不推荐）： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public override DataTemplate SelectTemplate(...) { if (item is Order o) { if (o.Status == \u0026#34;Pending\u0026#34;) { if (o.CustomerLevel == \u0026#34;VIP\u0026#34;) return VipPendingTemplate; else return PendingTemplate; } else if (o.Status == \u0026#34;Completed\u0026#34;) { ... } } } 改进方式： 使用策略模式或状态枚举映射 1 2 3 4 5 6 7 8 9 10 11 12 13 public class OrderTemplateSelector : DataTemplateSelector { public Dictionary\u0026lt;OrderState, DataTemplate\u0026gt; Templates { get; } = new(); public override DataTemplate SelectTemplate(object item, DependencyObject container) { if (item is Order order) { return Templates.GetValueOrDefault(order.State); } return base.SelectTemplate(item, container); } } XAML 配置： 1 2 3 4 5 6 \u0026lt;local:OrderTemplateSelector x:Key=\u0026#34;orderSelector\u0026#34;\u0026gt; \u0026lt;local:OrderTemplateSelector.Templates\u0026gt; \u0026lt;Component:TemplateMapEntry Key=\u0026#34;Pending\u0026#34; Value=\u0026#34;{StaticResource PendingTemplate}\u0026#34; /\u0026gt; \u0026lt;Component:TemplateMapEntry Key=\u0026#34;Completed\u0026#34; Value=\u0026#34;{StaticResource CompletedTemplate}\u0026#34; /\u0026gt; \u0026lt;/local:OrderTemplateSelector.Templates\u0026gt; \u0026lt;/local:OrderTemplateSelector\u0026gt; 💡 注：你可以自定义 TemplateMapEntry 类型来支持这种字典结构。\n✅ 技巧 4：调试时注意 Binding 上下文问题 常见错误： 在 SelectTemplate 中获取不到正确对象。 绑定路径错误导致无法识别类型。 解决方法： 确保绑定上下文正确 1 2 \u0026lt;ListBox ItemsSource=\u0026#34;{Binding MyItems}\u0026#34; ItemTemplateSelector=\u0026#34;{StaticResource mySelector}\u0026#34; /\u0026gt; 确保 MyItems 是 IEnumerable\u0026lt;T\u0026gt;，且每一项类型都能被识别。\n添加日志辅助调试： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public override DataTemplate SelectTemplate(object item, DependencyObject container) { if (item == null) { Debug.WriteLine(\u0026#34;Item is null\u0026#34;); return base.SelectTemplate(item, container); } Debug.WriteLine($\u0026#34;Item type: {item.GetType().Name}\u0026#34;); if (item is CustomType ct) { return ct.IsSpecial ? SpecialTemplate : NormalTemplate; } return base.SelectTemplate(item, container); } 五、总结 DataTemplateSelector 是 WPF 中非常强大且灵活的功能，它帮助我们实现了数据驱动的 UI 模板选择。无论是构建复杂的 UI 列表还是实现高度定制化的展示逻辑，DataTemplateSelector 都是一个值得掌握的技能。\n","date":"2025-05-30T14:46:48+08:00","image":"https://www.notion.so/images/page-cover/nasa_new_york_city_grid.jpg","permalink":"https://dumbnessrf.github.io/p/data-template-selector-tips/","title":"WPF技巧-数据模板动态选择"},{"content":"解锁.NET 新姿势：基于文件的程序特性深度解析与实战 在.NET 的世界里，新项目的创建和运行往往离不开.csproj项目文件，从编写代码到调试运行，需要一系列繁琐的步骤。但随着.NET 技术的不断演进，基于文件的程序（File-based programs） 这一新特性的出现，打破了这一传统模式，为开发者带来了更加便捷、高效的开发体验。\n基于文件的程序特性概述 基于文件的程序，简单来说，就是将部分 MSBuild 项目功能嵌入到 C# 代码中，允许开发者直接运行单个 C# 文件，就像运行一个完整的项目一样。在以往，运行 C# 代码通常需要先创建一个项目，编写 .csproj 文件来配置项目的各种属性，如引用的包、目标框架等。而基于文件的程序则无需这些复杂的操作，它通过在 C# 源文件中添加特殊的 #: 指令，在内存中生成一个 “虚拟项目”，然后将这个 “虚拟项目” 传递给 MSBuild 进行构建和运行。\n其背后的运行机制是：当使用 dotnet run 命令运行一个 C# 文件时，命令行会解析源文件中的 #: 指令，根据这些指令在内存中构建一个 C# 项目 XML 文档，这个文档就相当于一个常规项目的 .csproj 文件。随后，MSBuild 会基于这个内存中的项目文档进行编译和运行，使得单个文件能够像完整项目一样执行 。\n应用示例详解 示例 1：经典 Hello World 1 2 3 // HelloWorld.cs #:r \u0026#34;System.Net.Http\u0026#34; Console.WriteLine(\u0026#34;Hello, World!\u0026#34;); 在这个简单示例中，#:r \u0026quot;System.Net.Http\u0026quot; 是一个 #: 指令，它用于引用 System.Net.Http 程序集。虽然代码中没有传统的项目文件配置，但通过这条指令，我们为程序添加了所需的引用。在命令行中进入该文件所在目录，执行 dotnet run HelloWorld.cs，就能看到熟悉的 “Hello, World!” 输出。这展示了基于文件的程序最基础的运行方式，仅需一个 C# 文件和简单指令，即可快速运行代码。\n示例 2：引用外部 NuGet 包 1 2 3 4 5 6 7 8 9 10 11 12 13 // NewtonsoftJsonExample.cs #:package Newtonsoft.Json 13.0.1 using Newtonsoft.Json; class Program { static void Main() { var person = new { Name = \u0026#34;Alice\u0026#34;, Age = 30 }; var json = JsonConvert.SerializeObject(person); Console.WriteLine(json); } } 在这个示例中，#:package Newtonsoft.Json 13.0.1 指令用于引入 Newtonsoft.Json 包及其指定版本。引入后，代码中就能使用 Newtonsoft.Json 提供的功能，如将对象序列化为 JSON 字符串。运行时，dotnet run 命令会根据该指令自动下载并引用所需的 NuGet 包，无需手动在项目文件中添加包引用，极大地简化了使用外部包的流程 。\n示例 3：多文件协作 假设我们有一个简单的数学计算项目，包含两个文件：Calculator.cs 和 Program.cs。\nCalculator.cs 文件内容如下：\n1 2 3 4 5 6 7 8 9 10 11 // Calculator.cs namespace MathUtils { public static class Calculator { public static int Add(int a, int b) { return a + b; } } } Program.cs 文件内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 // Program.cs #:r \u0026#34;System.Net.Http\u0026#34; using MathUtils; class Program { static void Main() { int result = Calculator.Add(5, 3); Console.WriteLine($\u0026#34;The result of addition is: {result}\u0026#34;); } } 在基于文件的程序中，无需手动在项目文件中配置文件引用关系。当使用 dotnet run Program.cs 命令运行时，SDK CLI 会自动解析 Program.cs 所在目录树中的所有 .cs 文件，将 Calculator.cs 包含在编译过程中，使得不同文件之间能够顺利协作，实现复杂的功能 。\n与传统项目模式的对比优势 降低入门门槛\n对于初学者来说，传统的 .csproj 项目文件配置复杂，包含众多属性和节点，容易让新手感到困惑。而基于文件的程序模式，只需关注代码本身和简单的 #: 指令，无需深入了解项目文件配置，能够更快地编写和运行代码，降低了学习成本。\n快速原型开发\n在开发初期进行原型设计时，往往需要快速验证想法和功能。基于文件的程序无需创建完整项目结构，直接编写单个文件并运行，能够大大提高开发效率，快速迭代原型。\n简化小型工具开发\n对于一些简单的小型工具或脚本，使用传统项目模式显得过于繁琐。基于文件的程序可以用最少的配置和步骤实现功能，使代码更加简洁、轻便，便于维护和管理。\n使用注意事项 虽然基于文件的程序带来了诸多便利，但在使用过程中也有一些需要注意的地方：\n目前基于文件的程序在功能上还存在一定限制，例如对某些复杂的项目配置和构建自定义支持不够完善。 由于其依赖于 #: 指令来配置项目属性，指令的语法和使用规则需要开发者熟练掌握，否则可能会出现引用错误或构建失败等问题。 在团队协作开发中，基于文件的程序可能会因为成员使用不同版本的 .NET SDK 而导致运行结果不一致，需要统一开发环境。 以上就是对 .NET 基于文件的程序特性的详细介绍和应用示例。这一特性为开发者提供了更灵活高效的开发方式，无论是初学者快速上手，还是经验丰富的开发者进行快速开发，都能发挥重要作用。不妨亲自尝试，感受它带来的便捷！如果你在使用过程中有新的发现或遇到问题，欢迎一起交流探讨。\n","date":"2025-05-29T11:04:44+08:00","image":"https://www.notion.so/images/page-cover/rijksmuseum_mignons_1660.jpg","permalink":"https://dumbnessrf.github.io/p/single-file-run/","title":"单文件运行C#代码"}]