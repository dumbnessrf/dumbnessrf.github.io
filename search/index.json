[{"content":"🧵 .NET 并发编程利器详解 附：volatile 与 Interlocked 在并发控制中的关键作用\n📌 引言：为什么需要并发集合？ 在多线程编程中，我们经常需要多个线程安全地共享数据 —— 比如生产者消费者模型、任务队列、缓存字典、限流控制等。如果使用普通集合（如 List\u0026lt;T\u0026gt;、Queue\u0026lt;T\u0026gt;、Dictionary\u0026lt;TKey, TValue\u0026gt;），在并发读写时极易引发：\n❌ 数据竞争（Race Condition） ❌ 集合内部结构损坏（如哈希表 rehash 时被多线程修改） ❌ 程序崩溃或数据不一致 .NET 提供了 System.Collections.Concurrent 命名空间下的线程安全集合类，专为高并发场景设计，无需手动加锁即可安全使用。\n本文将深入讲解：\n✅ ConcurrentQueue\u0026lt;T\u0026gt;、ConcurrentStack\u0026lt;T\u0026gt;、ConcurrentDictionary\u0026lt;TKey, TValue\u0026gt; ✅ BlockingCollection\u0026lt;T\u0026gt; 与它们的关系 ✅ SemaphoreSlim 如何控制并发度 ✅ volatile 与 Interlocked 在并发编程中的关键作用 ✅ 实战示例 + 最佳实践 🧩 一、三大基础并发集合 1. ConcurrentQueue\u0026lt;T\u0026gt; —— 线程安全的先进先出队列 特点：\nFIFO（First In, First Out） 无锁或细粒度锁实现，高性能 支持多生产者多消费者 常用方法：\nEnqueue(T item) — 入队 TryDequeue(out T result) — 出队（线程安全） IsEmpty — 是否为空（注意：可能瞬时不准，仅作参考） 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 var queue = new ConcurrentQueue\u0026lt;int\u0026gt;(); // 生产者线程 Task.Run(() =\u0026gt; { for (int i = 1; i \u0026lt;= 5; i++) { queue.Enqueue(i); Console.WriteLine($\u0026#34;生产: {i}\u0026#34;); Thread.Sleep(100); } }); // 消费者线程 Task.Run(() =\u0026gt; { while (true) { if (queue.TryDequeue(out var item)) { Console.WriteLine($\u0026#34;消费: {item}\u0026#34;); } else if (queue.IsEmpty) break; // 注意：此处可能有竞态，仅演示 Thread.Sleep(50); } }); Thread.Sleep(2000); ✅ 适用场景：任务队列、消息缓冲、日志收集等\n2. ConcurrentStack\u0026lt;T\u0026gt; —— 线程安全的后进先出栈 特点：\nLIFO（Last In, First Out） 同样支持多生产者多消费者 常用方法：\nPush(T item) — 压栈 TryPop(out T result) — 弹栈 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var stack = new ConcurrentStack\u0026lt;int\u0026gt;(); Task.Run(() =\u0026gt; { for (int i = 1; i \u0026lt;= 3; i++) { stack.Push(i); Console.WriteLine($\u0026#34;压栈: {i}\u0026#34;); } }); Task.Run(() =\u0026gt; { while (stack.TryPop(out var item)) { Console.WriteLine($\u0026#34;弹栈: {item}\u0026#34;); Thread.Sleep(100); } }); Thread.Sleep(1000); ✅ 适用场景：撤销操作栈、对象池、深度优先遍历缓冲\n3. ConcurrentDictionary\u0026lt;TKey, TValue\u0026gt; —— 线程安全字典 特点：\n内部使用分段锁或无锁结构（.NET Core 后优化极佳） 支持原子操作：AddOrUpdate, GetOrAdd 常用方法：\n1 2 3 4 5 6 7 var cache = new ConcurrentDictionary\u0026lt;string, string\u0026gt;(); // 线程安全添加或获取 var value = cache.GetOrAdd(\u0026#34;key\u0026#34;, k =\u0026gt; ComputeExpensiveValue(k)); // 线程安全更新 cache.AddOrUpdate(\u0026#34;counter\u0026#34;, 1, (key, oldValue) =\u0026gt; oldValue + 1); 完整示例：\n1 2 3 4 5 6 7 8 9 var dict = new ConcurrentDictionary\u0026lt;string, int\u0026gt;(); Parallel.For(0, 1000, i =\u0026gt; { dict.AddOrUpdate(\u0026#34;count\u0026#34;, 1, (key, old) =\u0026gt; old + 1); }); Console.WriteLine($\u0026#34;最终计数: {dict[\u0026#34;count\u0026#34;]}\u0026#34;); // 输出：1000（线程安全累加） ✅ 适用场景：缓存、计数器、共享状态存储\n🚦 二、BlockingCollection —— 并发集合的“增强包装器” ▶ 它是什么？ BlockingCollection\u0026lt;T\u0026gt; 不是一个新的集合，而是一个包装器，它为 IProducerConsumerCollection\u0026lt;T\u0026gt;（如 ConcurrentQueue\u0026lt;T\u0026gt;）添加了：\n✅ 阻塞操作（Take() 会阻塞直到有数据） ✅ 限界容量（Bounded Capacity） ✅ 完成标记（CompleteAdding()） ✅ 枚举支持（GetConsumingEnumerable()） ▶ 与三大集合的关系 底层集合 行为 ConcurrentQueue\u0026lt;T\u0026gt; FIFO 阻塞队列（默认） ConcurrentStack\u0026lt;T\u0026gt; LIFO 阻塞栈 ConcurrentBag\u0026lt;T\u0026gt; 无序高性能阻塞包 ▶ 示例：生产者-消费者模型（推荐写法） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 var blockingCollection = new BlockingCollection\u0026lt;int\u0026gt;(new ConcurrentQueue\u0026lt;int\u0026gt;(), 10); // 最大容量10 // 生产者 Task.Run(() =\u0026gt; { for (int i = 1; i \u0026lt;= 20; i++) { blockingCollection.Add(i); // 如果满了，会阻塞 Console.WriteLine($\u0026#34;生产: {i}\u0026#34;); Thread.Sleep(100); } blockingCollection.CompleteAdding(); // 标记完成 }); // 消费者 Task.Run(() =\u0026gt; { foreach (var item in blockingCollection.GetConsumingEnumerable()) { Console.WriteLine($\u0026#34;消费: {item}\u0026#34;); Thread.Sleep(200); // 模拟处理时间 } }); Thread.Sleep(5000); ✅ 适用场景：任务调度、数据流水线、限流缓冲区\n💡 BlockingCollection\u0026lt;T\u0026gt; 默认有序（FIFO），因为默认包装 ConcurrentQueue\u0026lt;T\u0026gt;\n🚧 三、SemaphoreSlim —— 控制并发访问数量 ▶ 它是什么？ SemaphoreSlim 是一个轻量级信号量，用于限制同时访问某资源的线程数量。\n不是集合，而是并发控制原语。\n▶ 常用方法： Wait() / WaitAsync() — 获取许可证 Release() — 释放许可证 CurrentCount — 剩余许可证数 ▶ 示例：限制最多3个并发下载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var semaphore = new SemaphoreSlim(3, 3); // 最多3个并发 var tasks = Enumerable.Range(1, 10).Select(async i =\u0026gt; { await semaphore.WaitAsync(); try { Console.WriteLine($\u0026#34;开始下载文件 {i}，当前并发: {3 - semaphore.CurrentCount}\u0026#34;); await Task.Delay(1000); // 模拟下载 Console.WriteLine($\u0026#34;完成下载文件 {i}\u0026#34;); } finally { semaphore.Release(); } }); await Task.WhenAll(tasks); ✅ 适用场景：限流、数据库连接池、API调用限频、资源池\n⚙️ 四、volatile 与 Interlocked —— 并发编程的基石 1. volatile 关键字 用于修饰字段，确保多线程环境下对该字段的读写不被编译器/CPU重排序或缓存。\n适用场景：标志位、状态变量、引用替换\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Worker { private volatile bool _shouldStop = false; public void DoWork() { while (!_shouldStop) { // 工作逻辑 } } public void RequestStop() { _shouldStop = true; // 其他线程能立即看到 } } ⚠️ volatile 不能替代锁！它只保证可见性和禁止重排序，不保证原子性。\n2. Interlocked 类 提供原子操作，如自增、自减、交换、比较交换（CAS）\n常用方法：\nInterlocked.Increment(ref variable) Interlocked.Exchange(ref location, value) — 原子替换 Interlocked.CompareExchange(ref location, newValue, comparand) — CAS 示例 1：线程安全计数器\n1 2 3 4 5 6 7 8 private long _counter = 0; Parallel.For(0, 10000, _ =\u0026gt; { Interlocked.Increment(ref _counter); }); Console.WriteLine(_counter); // 10000 示例 2：原子替换（用于动态替换 SemaphoreSlim）\n1 2 3 4 5 6 7 8 private volatile SemaphoreSlim _semaphore = new(4); public void SetMaxConcurrency(int newMax) { var newSemaphore = new SemaphoreSlim(newMax); var old = Interlocked.Exchange(ref _semaphore, newSemaphore); old?.Dispose(); } ✅ 适用场景：计数器、状态机、无锁数据结构、动态资源替换\n🔄 五、它们之间的关系图谱 1 2 3 4 5 6 7 8 graph TD A[ConcurrentQueue\u0026lt;T\u0026gt;] --\u0026gt;|包装| B(BlockingCollection\u0026lt;T\u0026gt;) C[ConcurrentStack\u0026lt;T\u0026gt;] --\u0026gt;|包装| B D[ConcurrentBag\u0026lt;T\u0026gt;] --\u0026gt;|包装| B E[SemaphoreSlim] --\u0026gt;|控制| F[并发任务数/资源访问数] G[volatile + Interlocked] --\u0026gt;|支撑| H[无锁编程、动态替换、状态同步] B --\u0026gt;|常与| E F --\u0026gt;|依赖| G BlockingCollection\u0026lt;T\u0026gt; 依赖底层并发集合\nSemaphoreSlim 常用于控制 BlockingCollection 消费者或任务并发数\nvolatile + Interlocked 是实现无锁替换、状态同步的基础\n🎯 六、实战：构建一个带并发限制的任务调度器 结合以上所有知识点：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class LimitedTaskScheduler\u0026lt;T\u0026gt; { private readonly BlockingCollection\u0026lt;Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt;\u0026gt; _taskQueue; private readonly SemaphoreSlim _semaphore; private readonly ILogger _logger; public LimitedTaskScheduler(int maxConcurrency, ILogger logger) { _taskQueue = new BlockingCollection\u0026lt;Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt;\u0026gt;(new ConcurrentQueue\u0026lt;Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt;\u0026gt;()); _semaphore = new SemaphoreSlim(maxConcurrency, maxConcurrency); _logger = logger; } public void QueueTask(Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt; task) { _taskQueue.Add(task); } public async Task StartAsync() { var tasks = new List\u0026lt;Task\u0026gt;(); foreach (var workItem in _taskQueue.GetConsumingEnumerable()) { tasks.Add(ExecuteWithLimit(workItem)); } await Task.WhenAll(tasks); } private async Task ExecuteWithLimit(Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt; workItem) { await _semaphore.WaitAsync(); try { await workItem(); } finally { _semaphore.Release(); } } public void CompleteAdding() =\u0026gt; _taskQueue.CompleteAdding(); } 使用：\n1 2 3 4 5 6 7 8 9 10 11 12 var scheduler = new LimitedTaskScheduler\u0026lt;string\u0026gt;(3, logger); scheduler.QueueTask(() =\u0026gt; Task.Run(async () =\u0026gt; { await Task.Delay(1000); return \u0026#34;Task1 Result\u0026#34;; })); scheduler.QueueTask(/* ... */); scheduler.CompleteAdding(); await scheduler.StartAsync(); 📝 七、最佳实践总结 组件 使用建议 ConcurrentQueue 默认首选，FIFO，适合任务队列 ConcurrentStack 适合撤销栈、对象池 ConcurrentDictionary 缓存、计数器首选，用 GetOrAdd / AddOrUpdate 避免竞态 BlockingCollection 需要阻塞/限界/完成通知时使用，包装 ConcurrentQueue 最常用 SemaphoreSlim 控制并发数，配合 using 或 try/finally 确保 Release volatile 用于布尔标志、引用替换，确保可见性 Interlocked 计数器、无锁状态切换、原子替换（如动态调整并发数） 🧭 八、常见误区 ❌ “ConcurrentBag 是无序的，性能最好，所以我所有地方都用它”\n→ 仅在顺序无关、频繁增删时使用，否则用 ConcurrentQueue\n❌ “BlockingCollection.Take() 是非阻塞的”\n→ 默认是阻塞的！除非用 TryTake\n❌ “volatile 能保证原子性”\n→ 不能！i++ 即使是 volatile 也不是原子的，要用 Interlocked.Increment\n❌ “SemaphoreSlim 是集合”\n→ 它是同步原语，不是数据容器\n✅ 结语 .NET 的并发集合与同步原语构成了强大而易用的并发编程基础设施。掌握：\nConcurrentQueue / ConcurrentStack / ConcurrentDictionary BlockingCollection\u0026lt;T\u0026gt; 的阻塞与包装能力 SemaphoreSlim 的并发控制 volatile 与 Interlocked 的无锁支撑 你就能在多线程世界中游刃有余，写出高性能、高可靠性的并发程序。\n📌 源码示例已全部测试通过，可直接复制到项目中运行。\n📌 建议收藏 + 实践 + 分享给团队，提升整体并发编程能力！\n🔖 附录：命名空间引用 确保项目中引用：\n1 2 3 4 5 using System; using System.Collections.Concurrent; using System.Threading; using System.Threading.Tasks; using System.Linq; 🎉 感谢阅读！如果你觉得有帮助，欢迎点赞、收藏、转发！\n下期预告：《用 Channel 替代 BlockingCollection —— .NET 6+ 现代并发数据流》\n","date":"2025-09-11T21:08:09+08:00","image":"https://www.notion.so/images/page-cover/met_joseph_hidley_1870.jpg","permalink":"https://dumbnessrf.github.io/p/meet_parallel_programing/","title":"Meet Parallel Programing"},{"content":"🎯 SharpBoxesCore.Wpf.PropertyGrid 一个功能强大、高度可扩展的 WPF 属性编辑器（PropertyGrid），专为现代 MVVM 应用设计。支持自动 UI 生成、属性分组、描述显示、范围验证、滑块调节、自定义按钮、命令绑定、复合类型嵌套、集合编辑、动态刷新、防抖优化等高级功能，开箱即用，适用于配置面板、调试工具、设计器、参数设置等场景。\n✨ 核心特性 功能 说明 🔹 自动属性发现 扫描对象的公共可读写属性 🔹 属性分组（Category） 支持 [Category(\u0026quot;分组名\u0026quot;)] 分类显示 🔹 属性排序 支持 [PropertyOrder(1)] 自定义排序 🔹 描述显示 鼠标悬停或聚焦时显示 [Description] 内容 🔹 显示名称 支持 [DisplayName(\u0026quot;别名\u0026quot;)] 自定义名称 🔹 枚举支持 显示 [Description] 文本，支持可空枚举 🔹 数值范围验证 支持 [Range(0, 100)] 输入限制 🔹 滑块调节 配合 [ShowSlider] 显示 Slider 控件 🔹 自定义按钮 支持 [AddButton] 添加操作按钮 🔹 命令绑定 按钮可绑定 ICommand，支持参数传递 🔹 降级机制 命令不存在时 fallback 到 ButtonClicked 事件 🔹 折叠面板 每个 Category 支持 Expander 折叠/展开 🔹 事件回调 支持 ButtonClicked 和 PropertyValueChanged 事件 🔹 错误提示 边框变红，显示错误提示，不更新数据源 🔹 文件/文件夹选择 支持 [SelectFilePath] / [SelectFolder] 对话框 🔹 下拉框编辑 支持 [EnumerableProperty] 绑定数据源 🔹 复合类型嵌套 支持类属性展开为子属性面板 🔹 集合编辑 支持 List\u0026lt;T\u0026gt; / Dictionary\u0026lt;K,V\u0026gt; 弹窗编辑 🔹 动态刷新 数据源变化自动更新 UI 🔹 类型安全 编辑时保留原始类型，支持自动解析 🔹 防抖机制 高频更新时自动合并刷新，提升性能 🔹 高度自适应 支持滚动条，内容展开自动拉伸 🔹 搜索属性字段 支持搜索指定名称属性编辑 🔹 一键展开、折叠 支持一键展开、折叠所有属性 🚀 快速开始 1. 安装引用 .NET CLI 1 dotnet add package SharpBoxesCore.Wpf --version 1.1.2 PackageReference 1 \u0026lt;PackageReference Include=\u0026#34;SharpBoxesCore.Wpf\u0026#34; Version=\u0026#34;1.1.2\u0026#34; /\u0026gt; CPM Directory.Packages.props\n1 \u0026lt;PackageVersion Include=\u0026#34;SharpBoxesCore.Wpf\u0026#34; Version=\u0026#34;1.1.2\u0026#34; /\u0026gt; Project file\n1 \u0026lt;PackageReference Include=\u0026#34;SharpBoxesCore.Wpf\u0026#34; /\u0026gt; 2. 在 XAML 中使用 1 2 3 4 5 6 7 \u0026lt;Window x:Class=\u0026#34;YourApp.MainWindow\u0026#34; xmlns:local=\u0026#34;clr-namespace:SharpBoxesCore.Wpf.PropertyGrid\u0026#34; ...\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;local:PropertyGrid x:Name=\u0026#34;propertyGrid\u0026#34; Padding=\u0026#34;10\u0026#34; /\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Window\u0026gt; 3. 绑定数据对象 1 2 3 4 5 6 7 8 9 10 11 12 public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); propertyGrid.SelectedObject = new SampleObject(); // 订阅事件 propertyGrid.ButtonClicked += OnButtonClicked; propertyGrid.PropertyValueChanged += OnPropertyValueChanged; } } 📦 示例：完整数据模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 public class SampleObject : INotifyPropertyChanged { [Category(\u0026#34;基本信息\u0026#34;)] [DisplayName(\u0026#34;姓名\u0026#34;)] [Description(\u0026#34;用户的全名\u0026#34;)] [EnumerableProperty(\u0026#34;AvaliableNames\u0026#34;, true)] public string Name { get; set; } = \u0026#34;张三\u0026#34;; [Category(\u0026#34;数值设置\u0026#34;)] [DisplayName(\u0026#34;音量\u0026#34;)] [Description(\u0026#34;调节音量大小\u0026#34;)] [Range(0, 100)] [ShowSlider(10, true)] public int Volume { get; set; } = 75; [Category(\u0026#34;高级\u0026#34;)] [DisplayName(\u0026#34;数据模式\u0026#34;)] public DataMode Mode { get; set; } = DataMode.Development; [Category(\u0026#34;文件\u0026#34;)] [DisplayName(\u0026#34;配置文件\u0026#34;)] [SelectFilePath(Title = \u0026#34;选择配置文件\u0026#34;, Filter = \u0026#34;JSON Files|*.json\u0026#34;)] public string ConfigFile { get; set; } = \u0026#34;\u0026#34;; [Category(\u0026#34;路径\u0026#34;)] [DisplayName(\u0026#34;工作目录\u0026#34;)] [SelectFolder(Title = \u0026#34;选择工作目录\u0026#34;)] public string WorkDir { get; set; } = \u0026#34;\u0026#34;; [Category(\u0026#34;集合\u0026#34;)] public List\u0026lt;string\u0026gt; Hobbies { get; set; } = new() { \u0026#34;阅读\u0026#34;, \u0026#34;音乐\u0026#34; }; [Category(\u0026#34;字典\u0026#34;)] public Dictionary\u0026lt;string, int\u0026gt; Scores { get; set; } = new() { [\u0026#34;数学\u0026#34;] = 90, [\u0026#34;英语\u0026#34;] = 85 }; [Category(\u0026#34;嵌套对象\u0026#34;)] public Address HomeAddress { get; set; } = new(); [Category(\u0026#34;操作\u0026#34;)] [AddButton(\u0026#34;ResetCommand\u0026#34;, \u0026#34;重置\u0026#34;)] [AddButton(\u0026#34;LogCommand\u0026#34;, \u0026#34;记录当前值\u0026#34;)] public int RetryCount { get; set; } = 3; // 命令定义 public ICommand ResetCommand =\u0026gt; new RelayCommand\u0026lt;string\u0026gt;(_ =\u0026gt; RetryCount = 0); public ICommand LogCommand =\u0026gt; new RelayCommand\u0026lt;string\u0026gt;(action =\u0026gt; Debug.WriteLine($\u0026#34;日志: {action}, Count={RetryCount}\u0026#34;)); // 下拉数据源 public ObservableCollection\u0026lt;string\u0026gt; AvaliableNames { get; } = new() { \u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charlie\u0026#34; }; public event PropertyChangedEventHandler PropertyChanged; protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null) =\u0026gt; PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } 🎨 UI 效果预览 分组折叠/展开 滑块与文本框联动 按钮自动布局 错误输入红色提示 描述信息实时显示 复合对象嵌套展开 集合点击“编辑\u0026hellip;”弹窗 滚动条支持长内容 🔧 高级功能详解 1. 枚举显示 [Description] 1 2 3 4 5 6 7 8 public enum DataMode { [Description(\u0026#34;开发模式\u0026#34;)] Development, [Description(\u0026#34;生产模式\u0026#34;)] Production } ✅ 显示为“开发模式”而非 Development\n2. 滑块调节 [ShowSlider] 1 2 3 [Range(0, 100)] [ShowSlider(5, true)] public int Brightness { get; set; } ✅ 自动生成 Slider + TextBox 联动控件\n3. 自定义按钮与命令绑定 1 2 3 [AddButton(\u0026#34;SaveCommand\u0026#34;, \u0026#34;保存\u0026#34;, \u0026#34;另存为\u0026#34;)] [AddButton(\u0026#34;DeleteCommand\u0026#34;, \u0026#34;删除\u0026#34;)] public string FileName { get; set; } ✅ 存在命令 → 绑定执行 ❌ 不存在 → 触发 ButtonClicked 事件 1 2 3 4 propertyGrid.ButtonClicked += (s, e) =\u0026gt; { MessageBox.Show($\u0026#34;按钮点击: {e.PropertyName} - {e.ButtonText}\u0026#34;); }; 4. 数值范围验证 1 2 [Range(1, 1000)] public int Count { get; set; } ✅ 输入非法时：\n边框变红 显示错误提示 不更新数据源 5. 下拉框 [EnumerableProperty] 1 2 [EnumerableProperty(\u0026#34;AvaliableNames\u0026#34;, true)] public string Theme { get; set; } ✅ 显示下拉框，支持自定义输入，数据源动态刷新\n6. 文件/文件夹选择 1 2 3 4 5 [SelectFilePath(Title = \u0026#34;选择日志\u0026#34;)] public string LogFile { get; set; } [SelectFolder] public string BackupDir { get; set; } ✅ 使用 Ookii.Dialogs.Wpf 提供专业对话框\n7. 复合类型（嵌套对象） 1 2 3 4 5 6 7 8 public class Address { public string Street { get; set; } public string City { get; set; } } [DisplayName(\u0026#34;家庭地址\u0026#34;)] public Address HomeAddress { get; set; } ✅ 自动展开为子属性面板，支持 INotifyPropertyChanged 动态刷新\n8. 集合编辑（List / Dictionary） 1 2 public List\u0026lt;string\u0026gt; Hobbies { get; set; } public Dictionary\u0026lt;string, int\u0026gt; Scores { get; set; } ✅ 点击“编辑\u0026hellip;”弹出 ListEditor / DictEditor，支持类型保留编辑\n🧩 事件系统 PropertyValueChanged — 属性更改事件 1 2 3 4 5 6 7 propertyGrid.PropertyValueChanged += (s, e) =\u0026gt; { Console.WriteLine($\u0026#34;属性更改: {e.PropertyName}\u0026#34;); Console.WriteLine($\u0026#34; 类型: {e.PropertyType.Name}\u0026#34;); Console.WriteLine($\u0026#34; 旧值: {e.OldValue}\u0026#34;); Console.WriteLine($\u0026#34; 新值: {e.NewValue}\u0026#34;); }; ✅ 所有编辑操作（包括集合、文件选择）均触发此事件\nButtonClicked — 按钮点击事件（fallback） 1 2 3 4 propertyGrid.ButtonClicked += (s, e) =\u0026gt; { if (e.ButtonText == \u0026#34;重置\u0026#34;) ResetLogic(); }; ✅ 用于未绑定 ICommand 的按钮\n🛠️ 自定义 Attribute 说明 Attribute 用途 示例 [Category(\u0026quot;分组\u0026quot;)] 属性分组 Category(\u0026quot;网络\u0026quot;) [DisplayName(\u0026quot;别名\u0026quot;)] 自定义显示名 DisplayName(\u0026quot;IP地址\u0026quot;) [Description(\u0026quot;说明\u0026quot;)] 描述信息 Description(\u0026quot;服务器IP\u0026quot;) [PropertyOrder(1)] 排序优先级 数字越小越靠前 [Range(0,100)] 数值范围 支持 int/double/float [ShowSlider(10)] 显示滑块 TickFrequency=10 [AddButton(\u0026quot;Cmd\u0026quot;, \u0026quot;按钮\u0026quot;)] 添加操作按钮 支持多标签 [EnumerableProperty(\u0026quot;Source\u0026quot;, true)] 下拉框 绑定数据源 [SelectFilePath] 文件选择 打开 OpenFileDialog [SelectFolder] 文件夹选择 打开 FolderBrowserDialog ⚙️ 高级配置 防抖机制（Debounce） 默认启用，防止高频刷新：\n1 propertyGrid.DebounceEnabled = true; // 默认 true 可调整延迟时间（内部使用 DispatcherTimer）\n手动触发属性更改 1 propertyGrid.RaisePropertyValueChanged(\u0026#34;Name\u0026#34;, \u0026#34;旧值\u0026#34;, \u0026#34;新值\u0026#34;); 用于代码修改属性后通知外部系统\n📚 已知限制 限制 说明 ❌ 不支持集合增删项 ListEditor 仅支持修改值 ❌ 不支持复杂对象列表编辑 仅支持简单类型列表 ❌ 不支持 DateTime 专用控件 可用 TextBox 输入 ✅ 后续计划支持：DatePicker、ColorPicker、IEditableObject 撤销\n如果你喜欢这篇文章，欢迎点赞、收藏、分享！\n也可以关注我的博客，获取更多 WPF / .NET 技术干货 😊\n","date":"2025-09-02T23:01:03+08:00","image":"https://www.notion.so/images/page-cover/met_winslow_homer_maine_coast.jpg","permalink":"https://dumbnessrf.github.io/p/propertygrid/","title":"PropertyGrid"},{"content":"🚀 在 WPF 中使用 Microsoft.Xaml.Behaviors：行为（Behaviors）的优雅解决方案 ✅ 什么是 Microsoft.Xaml.Behaviors？ Microsoft.Xaml.Behaviors 是一个开源库，最初由 Expression Blend 团队开发，后来被微软官方维护并托管在 GitHub 上。这个库允许开发者通过 XAML 行为（Behaviors） 和 触发器（Triggers） 来扩展 UI 控件的功能，而无需编写复杂的代码或修改控件本身。\n💡 核心概念 Behavior（行为）：一种可重用的组件，附加到某个 UI 元素上，并为其添加额外的行为。 Trigger（触发器）：根据某些条件或事件执行特定的操作。 Action（动作）：触发器执行的具体操作，如调用方法、改变属性等。 GitHub 地址：https://github.com/microsoft/XamlBehaviors\n📦 安装 Microsoft.Xaml.Behaviors 你可以通过 NuGet 包管理器轻松地将 Microsoft.Xaml.Behaviors.Wpf 添加到你的 WPF 项目中。\n使用 NuGet 安装命令： 1 Install-Package Microsoft.Xaml.Behaviors.Wpf 或者通过 Visual Studio 的 NuGet 包管理器搜索并安装：\n打开菜单：工具 \u0026gt; NuGet 包管理器 \u0026gt; 管理解决方案的 NuGet 包 搜索关键词：Microsoft.Xaml.Behaviors.Wpf 安装最新版本 🛠️ XAML 命名空间引用 在 XAML 文件顶部添加以下命名空间引用，以便使用 Behaviors：\n1 xmlns:i=\u0026#34;http://schemas.microsoft.com/expression/2010/interactivity\u0026#34; 🎯 使用示例与应用场景 下面我们将通过几个典型的使用场景来展示 Microsoft.Xaml.Behaviors 的强大之处。\n示例 1：点击按钮时弹出消息框（不使用代码） 场景说明： 你希望点击按钮时显示一个简单的消息框，但不想在代码后台写任何逻辑。\n实现方式： 1 2 3 4 5 6 7 \u0026lt;Button Content=\u0026#34;点击我\u0026#34;\u0026gt; \u0026lt;i:Interaction.Triggers\u0026gt; \u0026lt;i:EventTrigger EventName=\u0026#34;Click\u0026#34;\u0026gt; \u0026lt;i:InvokeCommandAction Command=\u0026#34;{Binding ShowMessageCommand}\u0026#34; /\u0026gt; \u0026lt;/i:EventTrigger\u0026gt; \u0026lt;/i:Interaction.Triggers\u0026gt; \u0026lt;/Button\u0026gt; ViewModel 中定义命令： 1 2 3 4 5 6 7 public ICommand ShowMessageCommand { get; } public MyViewModel() { ShowMessageCommand = new RelayCommand(() =\u0026gt; MessageBox.Show(\u0026#34;你好，世界！\u0026#34;)); } 示例 2：文本框内容变化时更新绑定值（实时验证） 场景说明： 用户在输入框中输入内容时，自动触发验证逻辑。\n实现方式： 1 2 3 4 5 6 7 \u0026lt;TextBox Text=\u0026#34;{Binding Name}\u0026#34;\u0026gt; \u0026lt;i:Interaction.Triggers\u0026gt; \u0026lt;i:EventTrigger EventName=\u0026#34;TextChanged\u0026#34;\u0026gt; \u0026lt;i:InvokeCommandAction Command=\u0026#34;{Binding ValidateNameCommand}\u0026#34; /\u0026gt; \u0026lt;/i:EventTrigger\u0026gt; \u0026lt;/i:Interaction.Triggers\u0026gt; \u0026lt;/TextBox\u0026gt; 示例 3：鼠标悬停时高亮元素 场景说明： 当鼠标悬停在一个按钮上时，改变其背景颜色。\n实现方式： 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;Button Content=\u0026#34;悬停试试看\u0026#34;\u0026gt; \u0026lt;i:Interaction.Triggers\u0026gt; \u0026lt;i:EventTrigger EventName=\u0026#34;MouseEnter\u0026#34;\u0026gt; \u0026lt;i:ChangePropertyAction TargetObject=\u0026#34;{Binding ElementName=MyButton}\u0026#34; PropertyName=\u0026#34;Background\u0026#34; Value=\u0026#34;LightBlue\u0026#34;/\u0026gt; \u0026lt;/i:EventTrigger\u0026gt; \u0026lt;i:EventTrigger EventName=\u0026#34;MouseLeave\u0026#34;\u0026gt; \u0026lt;i:ChangePropertyAction TargetObject=\u0026#34;{Binding ElementName=MyButton}\u0026#34; PropertyName=\u0026#34;Background\u0026#34; Value=\u0026#34;White\u0026#34;/\u0026gt; \u0026lt;/i:EventTrigger\u0026gt; \u0026lt;/i:Interaction.Triggers\u0026gt; \u0026lt;/Button\u0026gt; 示例 4：自定义行为 —— 右键菜单 场景说明： 为任意控件添加右键菜单功能。\n自定义行为类（C#）： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class RightClickMenuBehavior : Behavior\u0026lt;FrameworkElement\u0026gt; { public static readonly DependencyProperty ContextMenuProperty = DependencyProperty.Register(\u0026#34;ContextMenu\u0026#34;, typeof(ContextMenu), typeof(RightClickMenuBehavior)); public ContextMenu ContextMenu { get { return (ContextMenu)GetValue(ContextMenuProperty); } set { SetValue(ContextMenuProperty, value); } } protected override void OnAttached() { AssociatedObject.MouseRightButtonDown += OnMouseRightButtonDown; } protected override void OnDetaching() { AssociatedObject.MouseRightButtonDown -= OnMouseRightButtonDown; } private void OnMouseRightButtonDown(object sender, MouseButtonEventArgs e) { if (ContextMenu != null) { ContextMenu.PlacementTarget = AssociatedObject; ContextMenu.IsOpen = true; } } } XAML 使用方式： 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;Button Content=\u0026#34;右键点击我\u0026#34;\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;local:RightClickMenuBehavior\u0026gt; \u0026lt;local:RightClickMenuBehavior.ContextMenu\u0026gt; \u0026lt;ContextMenu\u0026gt; \u0026lt;MenuItem Header=\u0026#34;复制\u0026#34; /\u0026gt; \u0026lt;MenuItem Header=\u0026#34;粘贴\u0026#34; /\u0026gt; \u0026lt;/ContextMenu\u0026gt; \u0026lt;/local:RightClickMenuBehavior.ContextMenu\u0026gt; \u0026lt;/local:RightClickMenuBehavior\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; \u0026lt;/Button\u0026gt; 🧩 应用场景总结 场景 描述 ⚙️ 事件绑定 将 UI 事件绑定到 ViewModel 中的命令，实现 MVVM 解耦 🔍 输入验证 实时验证用户输入内容，提升用户体验 🖱️ 鼠标交互 处理鼠标悬停、单击、拖拽等交互逻辑 🔄 动态样式 根据状态动态更改控件外观 🧪 单元测试 减少代码耦合，提高可测试性 🧱 自定义行为 快速构建可复用的 UI 行为模块 🧠 总结 Microsoft.Xaml.Behaviors 是 WPF 开发中非常强大的辅助工具。它不仅简化了 UI 与逻辑之间的绑定，还提升了代码的可维护性和可测试性。通过使用行为和触发器，我们可以实现更加灵活、解耦的 UI 设计，特别适合 MVVM 架构下的开发。\n如果你正在寻找一种更优雅的方式来处理 UI 交互逻辑，那么 Microsoft.Xaml.Behaviors 绝对值得一试！\n📚 参考资料 GitHub - Microsoft.Xaml.Behaviors NuGet - Microsoft.Xaml.Behaviors.Wpf MSDN - Interactivity Library 如果你喜欢这篇文章，欢迎点赞、收藏、分享！\n也可以关注我的博客，获取更多 WPF / .NET 技术干货 😊\n","date":"2025-07-23T23:01:03+08:00","image":"https://www.notion.so/images/page-cover/met_horace_pippin.jpg","permalink":"https://dumbnessrf.github.io/p/xaml_behaviors/","title":"Xaml Behaviors"},{"content":"在 WPF、Xamarin.Forms 和 .NET MAUI 开发中，数据绑定（Data Binding） 是 MVVM 架构的核心机制。但有时我们希望对绑定的数据进行转换、格式化或逻辑处理，这时候就需要使用 IValueConverter 接口实现值转换器。\nValueConverters.NET 是一个由 Thomas Galliker 维护的开源项目，它提供了一组常用的 IValueConverter 实现，帮助开发者快速构建强大的数据绑定逻辑。\n📦 安装方法 你可以通过 NuGet 包安装适用于不同平台的版本：\n平台 命令 WPF / WinForms / UWP / Avalonia 等 Install-Package ValueConverters Xamarin.Forms Install-Package ValueConverters.Forms .NET MAUI Install-Package ValueConverters.MAUI ✅ 如何使用 ValueConverters.NET？ 步骤一：在 XAML 中定义资源 1 2 3 4 \u0026lt;Window.Resources\u0026gt; \u0026lt;converters:DateTimeConverter x:Key=\u0026#34;DateTimeConverter\u0026#34; Format=\u0026#34;d\u0026#34; MinValueString=\u0026#34;-\u0026#34;/\u0026gt; \u0026lt;converters:BooleanToVisibilityConverter x:Key=\u0026#34;BooleanToVisibilityConverter\u0026#34;/\u0026gt; \u0026lt;/Window.Resources\u0026gt; 步骤二：在绑定中使用 Converter 1 2 \u0026lt;TextBlock Text=\u0026#34;{Binding BirthDate, Converter={StaticResource DateTimeConverter}}\u0026#34; /\u0026gt; \u0026lt;TextBox Visibility=\u0026#34;{Binding IsVisible, Converter={StaticResource BooleanToVisibilityConverter}}\u0026#34; /\u0026gt; 🧩 核心 Converters 及其示例 下面介绍几个最常用且实用的转换器及其应用场景。\n1. DateTimeConverter：日期格式化 示例代码： 1 2 // ViewModel public DateTime BirthDate { get; set; } = new DateTime(1990, 5, 20); 1 2 \u0026lt;!-- XAML --\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding BirthDate, Converter={StaticResource DateTimeConverter}, ConverterParameter=\u0026#39;yyyy-MM-dd\u0026#39;}\u0026#34; /\u0026gt; 支持参数： Format: 指定格式字符串（如 \u0026quot;yyyy-MM-dd\u0026quot;） MinValueString: 当值为 DateTime.MinValue 时显示替代文本 应用场景： 显示生日、创建时间等日期字段 处理空日期显示为 - 或 N/A 2. BooleanToVisibilityConverter：布尔值转可见性 示例代码： 1 2 // ViewModel public bool IsBusy { get; set; } = true; 1 2 \u0026lt;!-- XAML --\u0026gt; \u0026lt;ProgressBar Visibility=\u0026#34;{Binding IsBusy, Converter={StaticResource BooleanToVisibilityConverter}}\u0026#34; /\u0026gt; 支持参数： TrueValue: true 时返回的值（默认 Visibility.Visible） FalseValue: false 时返回的值（默认 Visibility.Collapsed） 应用场景： 控制按钮、进度条、加载动画的显示隐藏 动态切换控件状态 3. EnumWrapperConverter：枚举本地化展示 示例代码： 1 2 3 4 5 6 7 8 // 枚举定义 public enum PartyMode { [Display(Name = \u0026#34;PartyMode_Off\u0026#34;, ResourceType = typeof(PartyModeResources))] Off, [Display(Name = \u0026#34;PartyMode_On\u0026#34;, ResourceType = typeof(PartyModeResources))] On } 1 2 // ViewModel public PartyMode Mode { get; set; } = PartyMode.On; 1 2 \u0026lt;!-- XAML --\u0026gt; \u0026lt;Label Content=\u0026#34;{Binding Mode, Converter={StaticResource EnumWrapperConverter}}\u0026#34; /\u0026gt; 支持特性： 使用 [Display] 注解配合 .resx 资源文件实现多语言支持 自动识别当前 CurrentUICulture 应用场景： 国际化应用中的下拉菜单、状态标签 将枚举值以用户友好的方式展示 4. InvertBooleanConverter：取反布尔值 示例代码： 1 2 // ViewModel public bool IsLoggedIn { get; set; } = false; 1 2 \u0026lt;!-- XAML --\u0026gt; \u0026lt;Button Content=\u0026#34;登录\u0026#34; Visibility=\u0026#34;{Binding IsLoggedIn, Converter={StaticResource InvertBooleanConverter}}\u0026#34; /\u0026gt; 特点： 直接将 true 变为 false，反之亦然 应用场景： 控制“登录”和“登出”的切换显示 快速反转控件状态 5. NullToVisibilityConverter：空值控制可见性 示例代码： 1 2 // ViewModel public string UserName { get; set; } = null; 1 2 3 \u0026lt;!-- XAML --\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding UserName}\u0026#34; Visibility=\u0026#34;{Binding UserName, Converter={StaticResource NullToVisibilityConverter}}\u0026#34; /\u0026gt; 支持参数： WhenNull: 设置为 Visibility.Collapsed 或 Visibility.Hidden WhenNotNull: 同上 应用场景： 隐藏空字段 控制非空内容的显示 6. EnumToBooleanConverter：枚举匹配判断布尔值 示例代码： 1 2 3 4 5 6 7 8 9 10 // 枚举 public enum UserLevel { Guest, Member, Admin } // ViewModel public UserLevel Level { get; set; } = UserLevel.Admin; 1 2 3 \u0026lt;!-- XAML --\u0026gt; \u0026lt;Button Content=\u0026#34;删除用户\u0026#34; Visibility=\u0026#34;{Binding Level, Converter={StaticResource EnumToBooleanConverter}, ConverterParameter=Admin}\u0026#34; /\u0026gt; 应用场景： 根据角色权限显示/隐藏按钮 枚举匹配时启用某些操作 7. MultiBindingConverters：多个绑定值组合转换 示例：根据两个布尔值决定是否启用按钮 1 2 3 4 5 6 7 8 \u0026lt;Button Content=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;Button.Visibility\u0026gt; \u0026lt;MultiBinding Converter=\u0026#34;{StaticResource BooleanAndToVisibilityConverter}\u0026#34;\u0026gt; \u0026lt;Binding Path=\u0026#34;IsFormValid\u0026#34; /\u0026gt; \u0026lt;Binding Path=\u0026#34;IsNetworkAvailable\u0026#34; /\u0026gt; \u0026lt;/MultiBinding\u0026gt; \u0026lt;/Button.Visibility\u0026gt; \u0026lt;/Button\u0026gt; 支持的 MultiConverter： BooleanAndConverter BooleanOrConverter BooleanXorConverter BooleanAndToVisibilityConverter BooleanOrToVisibilityConverter 应用场景： 多条件判断控件状态 表单验证联动控制 8. ImageSourceConverter：图像路径转 ImageSource 示例代码： 1 2 // ViewModel public string AvatarPath { get; set; } = \u0026#34;Images/avatar.png\u0026#34;; 1 2 \u0026lt;!-- XAML --\u0026gt; \u0026lt;Image Source=\u0026#34;{Binding AvatarPath, Converter={StaticResource ImageSourceConverter}}\u0026#34; /\u0026gt; 支持参数： 支持相对路径、绝对路径、Base64 图像等 应用场景： 数据绑定图像地址 动态加载头像、图标等 9. FileSizeToStringConverter：字节大小自动转 KB/MB/GB 示例代码： 1 2 // ViewModel public long FileSize { get; set; } = 1024 * 1024 * 10; // 10 MB 1 2 \u0026lt;!-- XAML --\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding FileSize, Converter={StaticResource FileSizeToStringConverter}}\u0026#34; /\u0026gt; 输出结果：10.00 MB\n应用场景： 文件管理器、磁盘清理工具等显示文件大小 日志系统、监控系统中显示内存占用 10. StringFormatConverter：自定义字符串格式化 示例代码： 1 2 // ViewModel public decimal Price { get; set; } = 99.99m; 1 2 \u0026lt;!-- XAML --\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding Price, Converter={StaticResource StringFormatConverter}, ConverterParameter=\u0026#39;{}{0:C}\u0026#39;}\u0026#34; /\u0026gt; 输出结果：$99.99（根据文化设置）\n应用场景： 货币、百分比、数字格式化显示 支持动态格式模板 🌍 文化敏感支持（Culture Awareness） 所有转换器都支持文化感知：\n1 2 // 在 App.xaml.cs 或初始化时配置 ValueConvertersConfig.DefaultPreferredCulture = ConverterCulture.CurrentUICulture; 你也可以在运行时更改语言并刷新界面：\n1 Thread.CurrentThread.CurrentUICulture = new CultureInfo(\u0026#34;zh-CN\u0026#34;); 📦 总结 转换器名称 功能 应用场景 DateTimeConverter 日期格式化 时间戳展示 BooleanToVisibilityConverter 布尔转可视性 控件显示隐藏 EnumWrapperConverter 枚举本地化 下拉框、状态栏 InvertBooleanConverter 布尔取反 控件状态反转 NullToVisibilityConverter 空值控制可视性 隐藏空字段 EnumToBooleanConverter 枚举匹配布尔 权限控制 ImageSourceConverter 字符串路径转图像源 图像绑定 FileSizeToStringConverter 字节数大小转易读格式 文件信息展示 StringFormatConverter 字符串格式化 货币、百分比 BooleanAndConverter, BooleanOrConverter 多个布尔值逻辑运算 表单验证 🧩 结语：为什么推荐使用 ValueConverters.NET？ ✅ 提供了常见场景下的高质量 IValueConverter 实现 ✅ 支持多语言、文化敏感 ✅ 支持 WPF、Xamarin.Forms、MAUI 等主流 UI 框架 ✅ 可扩展性强，易于封装复用 ✅ 减少 Code-Behind，增强 MVVM 解耦能力 📦 推荐使用方式 安装包： 1 PM\u0026gt; Install-Package ValueConverters 全局注册（App.xaml）： 1 2 3 4 \u0026lt;Application.Resources\u0026gt; \u0026lt;converters:BooleanToVisibilityConverter x:Key=\u0026#34;BoolToVisConverter\u0026#34;/\u0026gt; \u0026lt;converters:DateTimeConverter x:Key=\u0026#34;DateTimeConverter\u0026#34; Format=\u0026#34;yyyy-MM-dd\u0026#34;/\u0026gt; \u0026lt;/Application.Resources\u0026gt; 📚 参考资料 GitHub 仓库：https://github.com/thomasgalliker/ValueConverters.NET NuGet 地址： WPF / WinForms / UWP Xamarin.Forms .NET MAUI ","date":"2025-06-24T17:39:03+08:00","image":"https://www.notion.so/images/page-cover/webb3.jpg","permalink":"https://dumbnessrf.github.io/p/value_converters/","title":"Value Converters"},{"content":"CalcBinding 是一个 WPF 第三方绑定增强库，它允许你在 XAML 中使用表达式进行数据绑定计算，而无需在 ViewModel 中写额外的属性或转换器（Converter）。\u0026ndash;它非常适合用于简单的数学运算、字符串拼接、条件判断等场景。\n📦 一、简介 GitHub 地址：https://github.com/Alex198711/CalcBinding 功能：支持类似 {calcBinding Path=Width*2+Height} 的表达式绑定 不依赖 IValueConverter 支持多绑定、条件语句、函数调用等 🧩 二、安装方式 你可以通过 NuGet 安装：\n1 Install-Package CalcBinding 然后在 XAML 中添加命名空间引用：\n1 xmlns:calc=\u0026#34;clr-namespace:CalcBinding;assembly=CalcBinding\u0026#34; 📘 三、常见用法与示例 ✅ 示例 1：基本数学运算 1 \u0026lt;TextBlock Text=\u0026#34;{calc:Binding Path=Width * 2 + Height}\u0026#34; /\u0026gt; 将 Width 乘以 2 再加上 Height，结果作为 TextBlock.Text\n✅ 示例 2：字符串拼接 1 \u0026lt;TextBlock Text=\u0026#34;{calc:Binding Path=FirstName + \u0026#39; \u0026#39; + LastName}\u0026#34; /\u0026gt; 把两个字段拼接成完整姓名\n✅ 示例 3：布尔值转可见性（Visibility） 1 2 \u0026lt;Button Content=\u0026#34;Submit\u0026#34; Visibility=\u0026#34;{calc:Binding Path=IsEnabled ? Visible : Collapsed}\u0026#34; /\u0026gt; 使用三元运算符实现 Visibility 控制，无需 Converter\n✅ 示例 4：绑定多个属性并做计算 1 \u0026lt;TextBlock Text=\u0026#34;{calc:MultiBinding Path1=Value1, Path2=Value2, Expression=Path1 + Path2}\u0026#34; /\u0026gt; 多绑定支持最多 5 个路径（Path1~Path5），可以组合任意表达式\n✅ 示例 5：使用 Math 函数（如 Max、Min、Round） 1 \u0026lt;TextBlock Text=\u0026#34;{calc:Binding Path=Math.Max(Width, Height)}\u0026#34; /\u0026gt; 显示 Width 和 Height 中较大的那个\n支持的函数包括：\nMath.Abs Math.Round Math.Min Math.Max Math.Ceiling Math.Floor Math.Pow(x, y) Math.Sqrt(x) ✅ 示例 6：条件判断结合绑定 1 \u0026lt;TextBlock Text=\u0026#34;{calc:Binding Path=Value \u0026gt; 0 ? Value : 0}\u0026#34; /\u0026gt; 如果 Value 大于 0，则显示 Value，否则显示 0\n✅ 示例 7：绑定集合元素 1 \u0026lt;TextBlock Text=\u0026#34;{calc:Binding Path=Items[0].Price * Items[0].Quantity}\u0026#34; /\u0026gt; 绑定集合中第一个元素的属性并进行计算\n✅ 示例 8：绑定资源中的静态值 1 2 3 4 5 \u0026lt;Window.Resources\u0026gt; \u0026lt;sys:Double x:Key=\u0026#34;ScaleFactor\u0026#34;\u0026gt;1.5\u0026lt;/sys:Double\u0026gt; \u0026lt;/Window.Resources\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{calc:Binding Path=Width * {StaticResource ScaleFactor}}\u0026#34; /\u0026gt; 可以在表达式中嵌入静态资源\n✅ 示例 9：使用方法调用（需要注册） 你可以在代码中注册自定义函数，例如：\n1 CalcBindingHelper.RegisterFunction(\u0026#34;Format\u0026#34;, (string format, object arg) =\u0026gt; string.Format(format, arg)); 然后在 XAML 中使用：\n1 \u0026lt;TextBlock Text=\u0026#34;{calc:Binding Path=Format(\u0026#39;{0:C}\u0026#39;, Price)}\u0026#34; /\u0026gt; 类似格式化货币输出，替代 StringFormat\n✅ 示例 10：绑定依赖属性（如控件尺寸） 1 2 3 4 5 \u0026lt;Canvas\u0026gt; \u0026lt;Ellipse Width=\u0026#34;50\u0026#34; Height=\u0026#34;50\u0026#34; Canvas.Left=\u0026#34;{calc:Binding ElementName=canvas, Path=ActualWidth / 2 - 25}\u0026#34; Canvas.Top=\u0026#34;{calc:Binding ElementName=canvas, Path=ActualHeight / 2 - 25}\u0026#34; /\u0026gt; \u0026lt;/Canvas\u0026gt; 计算控件居中位置，不需要在后台代码中设置布局逻辑\n🧪 四、性能与注意事项 注意点 说明 表达式复杂度 避免过于复杂的嵌套表达式，影响可读性和调试 调试困难 表达式错误不会抛出异常，只会显示为空或默认值 性能 相比普通绑定稍慢，但对 UI 影响不大 兼容性 支持 WPF，不支持 UWP 或 .NET MAUI 🎯 五、适合使用的场景 简单的数学计算绑定 字符串拼接 条件控制（Visible/Collapsed） 布局调整（基于控件大小） 替代简单 Converter 的场景 🧩 六、替代方案对比 方案 优点 缺点 CalcBinding 快速编写表达式，无需 Converter 不易调试，不适合复杂逻辑 IValueConverter 更强类型安全和逻辑控制 需要编写额外类 MultiBinding + IMultiValueConverter 支持多值绑定 实现繁琐 XAML Binding.StringFormat 简单格式化 不支持表达式计算 ","date":"2025-06-06T14:46:48+08:00","image":"https://www.notion.so/images/page-cover/rijksmuseum_mignons_1660.jpg","permalink":"https://dumbnessrf.github.io/p/calcbinding/","title":"WPF技巧-XAML中使用表达式进行数据绑定计算"},{"content":"ReactiveUI 基础用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 using System; using System.Reactive.Linq; using ReactiveUI; namespace AvaloniaApplication1.ViewModels; public partial class MainWindowViewModel : ViewModelBase { [ObservableProperty] public partial string Text1 { get; set; } [ObservableProperty] public partial string Text2 { get; set; } [ObservableProperty] public partial string Result { get; set; } public MainWindowViewModel() { this.WhenAnyValue(s =\u0026gt; s.Text1, s =\u0026gt; s.Text2) .Where(s =\u0026gt; double.TryParse(s.Item1, out _) \u0026amp;\u0026amp; double.TryParse(s.Item2, out _)) .Subscribe(s =\u0026gt; Calculate()); this.WhenAnyValue(s =\u0026gt; s.Text1, s =\u0026gt; s.Text2) .Where(s =\u0026gt; !double.TryParse(s.Item1, out _) || !double.TryParse(s.Item2, out _)) .Subscribe(s =\u0026gt; Clear()); } void Calculate() { Result = (double.Parse(Text1) + double.Parse(Text2)).ToString(); } void Clear() { Result = string.Empty; } } 只有当Text1和Text2发生变化且不为空时才订阅Calculate事件，为空时订阅Clear事件\nWhenAny、WhenAnyValue、WhenAnyObservable WhenAny 是一组扩展方法，每个方法都以前缀 WhenAny 开头，可用于在对象的属性发生更改时获取通知。\n在可能的情况下，WhenAnyValue 应该优先于 WhenAny，并且您不需要知道Sender或Expression\nWhenAny 变体支持多种属性更改通知。例如，它可以支持视图模型的 INotifyPropertyChanged 、基于 Windows 的 XAML 平台上的 DependencyProperty 以及 Apple 平台上的 NSObject 属性更改通知。要获取值更改通知，您的对象必须实现这些已知的属性更改通知机制之一。 如果其中一个不支持，您将只能获取属性的初始值，而不会收到任何更新通知。此外，运行时还会发出警告（请确保您已注册 ILogger 服务以便查看此警告）。\nWhenAnyValue IObservable\u0026lt;TRet\u0026gt; WhenAnyValue\u0026lt;TSender, TRet\u0026gt;( this TSender? sender, Expression\u0026lt;Func\u0026lt;TSender, TRet\u0026gt;\u0026gt; property1)\n由于表达式尚不支持此功能，因此 WhenAnyValue 不能直接执行空传播。 你可以通过将 WhenAnyValue() 调用链接到每个属性来模拟对空值传播的支持。以下是示例：\n1 2 this.WhenAnyValue(x =\u0026gt; x.Foo, x =\u0026gt; x.Foo.Bar, x =\u0026gt; x.Foo.Bar.Baz, (foo, bar, baz) =\u0026gt; foo?.Bar?.Baz) .Subscribe(x =\u0026gt; Console.WriteLine(x)); WhenAny WhenAny 允许您获取传递到 WhenAny 中的表达式和表达式。这对于一些场景是很有用的，比如在视图中，你需要知道调用属性改变的控件。\nWhenAny 仅告知您输入表达式的最终值何时发生变化。即使最终的变化是由于表达式链中的中间值引起的，也是如此。以下是一个解释性示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 this.WhenAny(x =\u0026gt; x.Foo.Bar.Baz, _ =\u0026gt; \u0026#34;Hello!\u0026#34;) .Subscribe(x =\u0026gt; Console.WriteLine(x)); // Example 1 this.Foo.Bar.Baz = \u0026#34;Something\u0026#34;; \u0026gt;\u0026gt;\u0026gt; Hello! // Example 2: Nothing printed! Because the string value does not change this.Foo.Bar.Baz = \u0026#34;Something\u0026#34;; // Example 3: Still nothing！Because the expression is Foo.Bar.Baz，not Foo.Bar this.Foo.Bar = new Bar() { Baz = \u0026#34;Something\u0026#34; }; // Example 4: The result changes, so we print this.Foo.Bar = new Bar() { Baz = \u0026#34;Else\u0026#34; }; \u0026gt;\u0026gt;\u0026gt; Hello! WhenAny 仅在读取给定表达式不会抛出 NullReferenceException 时才会发送通知。请考虑以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 this.WhenAny(x =\u0026gt; x.Foo.Bar.Baz, _ =\u0026gt; \u0026#34;Hello!\u0026#34;) .Subscribe(x =\u0026gt; Console.WriteLine(x)); // Example 1 this.Foo.Bar.Baz = null; \u0026gt;\u0026gt;\u0026gt; Hello! // Example 2: Nothing printed! this.Foo.Bar = null; // Example 3 this.Foo.Bar = new Bar() { Baz = \u0026#34;Something\u0026#34; }; \u0026gt;\u0026gt;\u0026gt; Hello! WhenAnyObservable WhenAnyObservable 会观察一个或多个可观察对象并提供最新的可观察值，处理新可观察对象的自动订阅以及 WhenAnyObservable 可观察对象的处理。WhenAnyObservable 默认为惰性订阅，这意味着在订阅之前不会获得任何值(其他的When在Ctor完成时就会通知，这个只有在更改时才会通知)。\n每当文档保存时，它都会打印来自 IsSaved 可观察变量的值。当 Document 属性发生更改时，它将自动取消订阅并重新订阅。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class MyViewModel { [Reactive] public Document Document { get; set; } public MyViewModel() { this.WhenAnyObservable(x =\u0026gt; x.Document.IsSaved).Subscribe(x =\u0026gt; Console.WriteLine($\u0026#34;Document Saved: {x}\u0026#34;)); } } public class Document { public IObservable\u0026lt;bool\u0026gt; IsSaved { get; } } Where 仅从 Observable 中发出那些通过谓词测试的项 IObservable\u0026lt;TSource\u0026gt; Where\u0026lt;TSource\u0026gt;(this IObservable\u0026lt;TSource\u0026gt; source, Func\u0026lt;TSource, bool\u0026gt; predicate)\nSubscribe 根据事件源的发出的事件或通知进行操作\n注意：该操作符之后将返回IDisposable，而不是IObservable\nIDisposable Subscribe\u0026lt;T\u0026gt;(this IObservable\u0026lt;T\u0026gt; source, Action\u0026lt;T\u0026gt; onNext)\nSubscribeOn 指定事件源在订阅时应使用的调度器\nSubscribeOn 运算符指定 Observable 将开始在哪个线程上运行，而不管该运算符在运算符链中的哪个点被调用。另一方面，ObserveOn 会影响 Observable 将使用的线程， 该线程位于该运算符出现的位置下方。 因此，您可以调用 在 Observable 链中的不同点多次进行 ObserveOn 运算符，以便更改某些运算符在哪些线程上进行作。\nIObservable\u0026lt;TSource\u0026gt; SubscribeOn\u0026lt;TSource\u0026gt;(this IObservable\u0026lt;TSource\u0026gt; source, IScheduler scheduler)\n📢 1 2 3 4 this.WhenAnyValue(s =\u0026gt; s.Text1, s =\u0026gt; s.Text2) .SubscribeOn(RxApp.MainThreadScheduler) .SubscribeOn(RxApp.TaskpoolScheduler) .SubscribeOn(SynchronizationContext.Current) 📢 RxApp.MainThreadScheduler\n获取或设置一个调度器，该调度器用于对那些应在 “用户界面 (UI) 线程上” 运行的工作项进行调度。在正常模式下，这将是 DispatcherScheduler（分发器调度器），而在单元测试模式下，这将是 Immediate（即时调度器），以便简化常见单元测试的编写工作。\nRxApp.TaskpoolScheduler\n获取或设置用于调度工作项以在后台线程中运行的调度器。在两种模式下，这些工作项都将在 TPL（任务并行库）任务池中运行。\nSynchronizationContext.Current Thread.CurrentThread._synchronizationContext\nThrottle 此操作符会对源序列进行限流，具体做法是对每个元素保留 dueTime（指定时长）。若在这个时间窗口内又产生了另一个元素，那么前一个元素会被丢弃，并且会为当前元素启动一个新的计时器，如此循环往复。对于元素间间隔从不大于或等于 dueTime 的流，经过处理后的流将不会产生任何元素。若要在保证元素周期性产生的同时减少流的数据量，可考虑使用 Observable.Sample 系列操作符。\n1 2 3 this.WhenAnyValue(s =\u0026gt; s.Text1) .Throttle(TimeSpan.FromSeconds(1)) .Subscribe(s =\u0026gt; Calculate()); Sample、Interval 1 2 3 4 5 6 var sub = Observable .Interval(TimeSpan.FromSeconds(0.01)) .Sample(TimeSpan.FromMilliseconds(500)) .Subscribe(s =\u0026gt; Result=s.ToString()); await Task.Delay(TimeSpan.FromSeconds(2)); sub.Dispose(); 每 10 毫秒发出一个值的可观察序列，每 500 毫秒对这个序列进行一次采样，将采样得到的值转换为字符串并赋值给 Result 变量，持续执行 2 秒后取消订阅并释放资源；尽管2s内通过Interval产生了200个，但是由于Sample，我只采样到了4个\nTimer、Amb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 using System.Reactive.Linq; var observable1 = Observable.Timer(TimeSpan.FromMilliseconds(200)) .Select(_ =\u0026gt; \u0026#34;Observable 1\u0026#34;); // 创建第二个可观测序列，延迟 100 毫秒后发射元素 var observable2 = Observable.Timer(TimeSpan.FromMilliseconds(100)) .Select(_ =\u0026gt; \u0026#34;Observable 2\u0026#34;); // 使用 Amb 操作符选择第一个产生元素的序列 var result = observable1.Amb(observable2); // 订阅结果序列 result.Subscribe( value =\u0026gt; Console.WriteLine($\u0026#34;Received: {value}\u0026#34;), error =\u0026gt; Console.WriteLine($\u0026#34;Error: {error}\u0026#34;), () =\u0026gt; Console.WriteLine(\u0026#34;Completed\u0026#34;) ); 借助 Observable.Timer 来创建两个可观测序列 observable1 和 observable2，它们会在特定延迟后发射元素。\n在这个示例中，由于 observable2 延迟 100 毫秒，比 observable1 的 200 毫秒延迟要短，所以 observable2 会率先产生元素，Amb 操作符会选择 observable2 并忽略 observable1。\nReceived: Observable 2\nCompleted\nRetry、Catch Retry允许在发生错误时或抛出错误时重新订阅源序列。例如，以下代码创建一个会抛出异常的序列，并通过Retry(2)最多重试2次：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 using System; using System.Reactive.Disposables; using System.Reactive.Linq; var source = Observable.Create\u0026lt;int\u0026gt;(observer =\u0026gt; { Console.WriteLine(\u0026#34;Doing work...\u0026#34;); // throw new Exception(\u0026#34;Initial failure\u0026#34;); observer.OnError(new Exception(\u0026#34;Initial failure\u0026#34;)); return Disposable.Empty; }); source .Retry(2) // 发生错误时重新订阅源序列，最多尝试2次 .Subscribe( x =\u0026gt; Console.WriteLine(\u0026#34;OnNext: \u0026#34; + x), ex =\u0026gt; Console.WriteLine(\u0026#34;OnError: \u0026#34; + ex.Message), () =\u0026gt; Console.WriteLine(\u0026#34;OnCompleted\u0026#34;) ); 输出\nDoing work\u0026hellip;\nDoing work\u0026hellip;\nOnError: Initial failure\n**Catch**用于捕获异常并替换为新的序列。例如，以下代码在发生错误后返回一个备用值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 using System; using System.Reactive.Disposables; using System.Reactive.Linq; var source = Observable.Create\u0026lt;int\u0026gt;(observer =\u0026gt; { observer.OnError(new Exception(\u0026#34;Primary error\u0026#34;)); return Disposable.Empty; }); source .Catch(Observable.Return(42)) // 捕获异常并替换为值42 .Subscribe( x =\u0026gt; Console.WriteLine(\u0026#34;OnNext: \u0026#34; + x), ex =\u0026gt; Console.WriteLine(\u0026#34;OnError: \u0026#34; + ex.Message), () =\u0026gt; Console.WriteLine(\u0026#34;OnCompleted\u0026#34;) ); OnNext: 42\nOnCompleted\nScan、Buffer Scan 用于对序列中的每个元素连续应用累积函数，并输出中间结果。类似于LINQ的 Aggregate，但会发射所有中间值\n1 2 3 4 5 6 7 using System.Reactive.Linq; var source = Observable.Range(1, 5); // 生成1到5的序列 source .Scan(0, (acc, val) =\u0026gt; acc + val) // 初始值0，累加当前值 .Subscribe(x =\u0026gt; Console.WriteLine(\u0026#34;Scan Result: \u0026#34; + x)); Scan Result: 1\nScan Result: 3\nScan Result: 6\nScan Result: 10\nScan Result: 15\nBuffer 将事件流按时间或数量分组，输出批量数据。常见用法包括按时间窗口或元素数量缓冲。\n1 2 3 4 5 6 7 8 9 using System.Reactive.Linq; var source = Observable.Interval(TimeSpan.FromSeconds(1)) // 每秒发射递增数 .Take(10); // 限制总发射次数 // 按时间窗口（5秒）和最大数量（3个元素）缓冲 source .Buffer(TimeSpan.FromSeconds(5), 3) .Subscribe(buffer =\u0026gt; Console.WriteLine($\u0026#34;Buffered Count: {buffer.Count}\u0026#34;)); Buffered Count: 3 // 第1-3秒的数据\nBuffered Count: 3 // 第4-5秒的数据（可能触发时间窗口）\nBuffered Count: 3 // 下一个窗口\nBuffered Count: 1 // 剩余1个元素\n📢 Buffer 支持多种分组策略，如纯时间窗口（Buffer(TimeSpan)）、纯数量（Buffer(count)）或两者结合\nDistinct、DistinctUntilChanged Distinct：过滤序列中所有重复的元素，仅保留首次出现的元素。\n1 2 3 4 var source = new[] { 1, 2, 2, 3, 3, 3 }; source.ToObservable() .Distinct() .Subscribe(x =\u0026gt; Console.WriteLine(x)); 输出 ：1, 2, 3\nDistinctUntilChanged：仅过滤连续重复 的元素，保留第一个，后续连续相同的元素被丢弃。\n1 2 3 4 var source = new[] { 1, 2, 2, 3, 2, 2 }; source.ToObservable() .DistinctUntilChanged() .Subscribe(x =\u0026gt; Console.WriteLine(x)); 输出 ：1, 2, 3, 2\nZip Zip 用于合并两个序列，逐个配对元素并生成结果。在 Rx 中，它常用于组合多个异步数据流。\n1 2 3 4 5 6 7 using System.Reactive.Linq; var numbers = Observable.Range(1, 3); // 1, 2, 3 var letters = Observable.Return(\u0026#34;A\u0026#34;).Concat(Observable.Return(\u0026#34;B\u0026#34;)); // A, B numbers.Zip(letters, (n, l) =\u0026gt; $\u0026#34;{n}{l}\u0026#34;) .Subscribe(result =\u0026gt; Console.WriteLine(result)); 1A\n2B\nDelay、Do、TimeInterval 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 using System; using System.Reactive.Linq; using System.Reactive.Concurrency; class Program { static void Main() { var source = Observable.Interval(TimeSpan.FromSeconds(1)) // 每秒发射递增数 .Take(5); // 限制发射次数为5次 source .Delay(TimeSpan.FromSeconds(0.5)) // 延迟0.5秒后发射元素 [[4]] .Do(x =\u0026gt; Console.WriteLine($\u0026#34;Do: 被延迟的值 = {x}\u0026#34;)) // 记录中间状态 [[6]] .TimeInterval() // 测量连续事件的时间间隔 [[1]] .Subscribe( interval =\u0026gt; Console.WriteLine($\u0026#34;TimeInterval: 值={interval.Value}, 间隔={interval.Interval.TotalSeconds}秒\u0026#34;), ex =\u0026gt; Console.WriteLine($\u0026#34;OnError: {ex.Message}\u0026#34;), () =\u0026gt; Console.WriteLine(\u0026#34;OnCompleted\u0026#34;) // 序列结束 [[10]] ); // 确保主线程等待足够时间以观察输出 Console.ReadLine(); } } 流程 ： 每秒生成一个数字（Interval）。 延迟0.5秒后发射（Delay）。 记录延迟后的值（Do）。 计算相邻值的发射时间间隔（TimeInterval）。 序列结束时自动触发 OnCompleted。 Do: 被延迟的值 = 0\nTimeInterval: 值=0, 间隔=1.5369618秒\nDo: 被延迟的值 = 1\nTimeInterval: 值=1, 间隔=0.9820277秒\nDo: 被延迟的值 = 2\nTimeInterval: 值=2, 间隔=0.9995484秒\nDo: 被延迟的值 = 3\nTimeInterval: 值=3, 间隔=1.0001499秒\nDo: 被延迟的值 = 4\nTimeInterval: 值=4, 间隔=1.0005686秒\nOnCompleted\nAverage、Concat、Count、Max、Min、Aggregate、Sum 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 using System; using System.Reactive.Linq; class Program { static void Main() { // 创建第一个序列 var source1 = Observable.Range(1, 3); // 发射 1, 2, 3 // 创建第二个序列 var source2 = Observable.Range(4, 2); // 发射 4, 5 // 使用 Concat 合并两个序列 [[3]] var concatenated = source1.Concat(source2); // 应用聚合操作符 concatenated .Count() // 计算总项数 [[1]] .Subscribe(count =\u0026gt; Console.WriteLine($\u0026#34;Total Count: {count}\u0026#34;)); concatenated .Sum() // 计算总和 [[9]] .Subscribe(sum =\u0026gt; Console.WriteLine($\u0026#34;Total Sum: {sum}\u0026#34;)); concatenated .Average() // 计算平均值 [[9]] .Subscribe(avg =\u0026gt; Console.WriteLine($\u0026#34;Average: {avg}\u0026#34;)); concatenated .Min() // 查找最小值 .Subscribe(min =\u0026gt; Console.WriteLine($\u0026#34;Min: {min}\u0026#34;)); concatenated .Max() // 查找最大值 .Subscribe(max =\u0026gt; Console.WriteLine($\u0026#34;Max: {max}\u0026#34;)); // 使用 Aggregate 自定义聚合逻辑（类似 Sum） concatenated .Aggregate((acc, val) =\u0026gt; acc + val) // 累积求和 [[9]] .Subscribe(total =\u0026gt; Console.WriteLine($\u0026#34;Reduce (Custom Sum): {total}\u0026#34;)); Console.ReadLine(); // 防止控制台退出 } } Total Count: 5\nTotal Sum: 15\nAverage: 3\nMin: 1\nMax: 5\nReduce (Custom Sum): 15\nAll、Contains、TakeUntil、StartWith 、Join 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 using System; using System.Reactive.Linq; class Program { static void Main() { // 示例序列1：数字序列 [1, 2, 3, 4, 5] var numbers = Observable.Range(1, 5); // 示例序列2：字符串序列 [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;] var letters = Observable.Range(0, 3).Select(x =\u0026gt; ((char)(\u0026#39;A\u0026#39; + x)).ToString()); // StartWith: 在序列开始前添加元素 [0, 1, 2, 3, 4, 5] var startWithExample = numbers.StartWith(0); startWithExample.Subscribe(x =\u0026gt; Console.WriteLine($\u0026#34;StartWith: {x}\u0026#34;)); // All: 检查所有元素是否大于0 numbers.All(x =\u0026gt; x \u0026gt; 0) .Subscribe(result =\u0026gt; Console.WriteLine($\u0026#34;All \u0026gt; 0: {result}\u0026#34;)); // 输出 true // Contains: 判断序列是否包含元素 3 numbers.Contains(3) .Subscribe(result =\u0026gt; Console.WriteLine($\u0026#34;Contains 3: {result}\u0026#34;)); // 输出 true // TakeUntil: 当另一个序列（如定时器）触发时停止 var takeUntilExample = numbers.TakeUntil(Observable.Timer(TimeSpan.FromSeconds(2))); takeUntilExample.Subscribe( x =\u0026gt; Console.WriteLine($\u0026#34;TakeUntil: {x}\u0026#34;), () =\u0026gt; Console.WriteLine(\u0026#34;TakeUntil Completed\u0026#34;)); // Join: 合并两个序列（基于时间窗口） var now = DateTime.Now; var source1 = Observable.Interval(TimeSpan.FromSeconds(1)).Take(3).Select(x =\u0026gt; $\u0026#34;N{x}\u0026#34;); var source2 = Observable.Interval(TimeSpan.FromSeconds(1.5)).Take(3).Select(x =\u0026gt; $\u0026#34;L{x}\u0026#34;); source1.Join( source2, _ =\u0026gt; Observable.Timer(TimeSpan.FromSeconds(2)), // 左侧元素存活时间 _ =\u0026gt; Observable.Timer(TimeSpan.FromSeconds(2)), // 右侧元素存活时间 (n, l) =\u0026gt; $\u0026#34;{n}+{l}\u0026#34; ).Subscribe(result =\u0026gt; Console.WriteLine($\u0026#34;Join Result: {result}\u0026#34;)); Console.ReadLine(); // 防止控制台退出 } } 应用StartWith添加初始元素。 使用All检查条件。 使用Contains判断是否存在元素。 使用TakeUntil在另一个序列触发后停止。 使用Join合并两个序列。 每个操作符后订阅结果并输出。 添加必要的引用标注。 StartWith: 0\nStartWith: 1\nStartWith: 2\nStartWith: 3\nStartWith: 4\nStartWith: 5\nAll \u0026gt; 0: True\nContains 3: True\nTakeUntil: 1\nTakeUntil: 2\nTakeUntil: 3\nTakeUntil: 4\nTakeUntil: 5\nTakeUntil Completed\nJoin Result: N0+L0\nJoin Result: N1+L0\nJoin Result: N0+L1\nJoin Result: N1+L1\nJoin Result: N2+L0\nJoin Result: N2+L1\nJoin Result: N2+L2\n","date":"2025-06-06T11:04:44+08:00","image":"https://www.notion.so/images/page-cover/woodcuts_6.jpg","permalink":"https://dumbnessrf.github.io/p/reactive_programing/","title":"ReactiveUI 与 Rx 常用方法总结"},{"content":"什么是依赖注入（Dependency Injection） 📌 概念 依赖注入（Dependency Injection，简称 DI）是一种常见的软件设计模式，主要用于解耦组件之间的依赖关系，提高代码的可维护性和可测试性。\n在 C# 开发中，如果不使用依赖注入，类 A 可能会在内部直接实例化类 B，导致两个类之间形成强耦合。而通过依赖注入的方式，可以将类 B 的实例从外部传递给类 A（通常通过构造函数、属性或方法参数），从而实现松耦合的设计。\n✅ 主要作用 提升可维护性\n当系统规模变大时，如果各个组件之间紧密耦合，修改一个组件可能会引发连锁反应。通过依赖注入，可以使依赖关系更加清晰明了，便于后期维护。\n简化单元测试\n在编写单元测试时，可以轻松地模拟（Mock）依赖对象，而不是依赖真实的复杂对象，使测试更简单、更精准。\n🛠 常用依赖注入框架及示例 1. Microsoft.Extensions.DependencyInjection 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 using Microsoft.Extensions.DependencyInjection; class MyClassA { private readonly MyClassB _dependency; public MyClassA(MyClassB dependency) =\u0026gt; _dependency = dependency; public void DoSomething() =\u0026gt; _dependency.SomeMethod(); } class MyClassB { public void SomeMethod() =\u0026gt; Console.WriteLine(\u0026#34;MyClassB\u0026#39;s method is called.\u0026#34;); } class Program { static void Main() { var serviceCollection = new ServiceCollection(); serviceCollection.AddTransient\u0026lt;MyClassB\u0026gt;(); serviceCollection.AddTransient\u0026lt;MyClassA\u0026gt;(); var serviceProvider = serviceCollection.BuildServiceProvider(); var a = serviceProvider.GetService\u0026lt;MyClassA\u0026gt;(); a.DoSomething(); } } 2. Autofac 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 using Autofac; class MyClassA { private readonly MyClassB _dependency; public MyClassA(MyClassB dependency) =\u0026gt; _dependency = dependency; public void DoSomething() =\u0026gt; _dependency.SomeMethod(); } class MyClassB { public void SomeMethod() =\u0026gt; Console.WriteLine(\u0026#34;MyClassB\u0026#39;s method is called.\u0026#34;); } class Program { static void Main() { var builder = new ContainerBuilder(); builder.RegisterType\u0026lt;MyClassB\u0026gt;().AsSelf(); builder.RegisterType\u0026lt;MyClassA\u0026gt;().AsSelf(); var container = builder.Build(); var a = container.Resolve\u0026lt;MyClassA\u0026gt;(); a.DoSomething(); } } 什么是动态加载程序集（Dynamic Assembly Loading） 📌 定义 在 C# 中，动态加载程序集允许程序在运行时加载并使用 DLL 文件，而不是在编译时静态引用它们。这种方式提供了更高的灵活性，例如：\n根据不同的条件或用户需求加载不同的功能模块。 在程序运行过程中更新某些功能模块，而无需重新编译整个项目。 🧪 示例：动态加载 DLL 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 using System.Reflection; class Program { static void Main() { // 加载程序集 Assembly assembly = Assembly.Load(\u0026#34;xxx.dll\u0026#34;); // 获取类型 Type type = assembly.GetType(\u0026#34;MyNamespace.MyClass\u0026#34;); // 创建实例 object instance = Activator.CreateInstance(type); // 调用方法 MethodInfo method = type.GetMethod(\u0026#34;DoSomething\u0026#34;); method.Invoke(instance, null); } } ⚠️ 注意：使用 Assembly.Load(\u0026quot;xxx.dll\u0026quot;) 加载的程序集会一直占用该 DLL 文件。若需要卸载或更新 DLL，建议使用如下方式：\n1 2 byte[] rawAssembly = File.ReadAllBytes(dllPath); Assembly assembly = Assembly.Load(rawAssembly); 🔄 将动态加载的 DLL 注入到依赖容器中（以 Autofac 为例） 我们以 Autofac 作为依赖注入容器，演示如何对动态加载的 DLL 进行服务注册与解析。\n步骤 1：加载程序集 1 2 byte[] rawAssembly = File.ReadAllBytes(dllPath); Assembly assembly = Assembly.Load(rawAssembly); 步骤 2：定义注入特性（Attribute） 为了筛选需要注册的服务类型，我们可以自定义一个 [Inject] 特性：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)] public class InjectAttribute(string name, string category) : Attribute { public string Name { get; } = name; public string Category { get; } = category; } public interface ITool { void DoWork(); void ShowDialog(); } // 示例类 [Inject(\u0026#34;工具2\u0026#34;, \u0026#34;类别1\u0026#34;)] public class MainFrame : ITool { public void DoWork() { /* 实现逻辑 */ } public void ShowDialog() { /* 实现逻辑 */ } } 步骤 3：注册服务到 Autofac 容器 1 2 3 4 5 6 7 8 9 10 11 12 13 var builder = new ContainerBuilder(); var types = assembly.DefinedTypes.ToList().Where(IsToolType).ToList(); foreach (var type in types) { var attr = type.CustomAttributes.First(a =\u0026gt; a.AttributeType == typeof(InjectAttribute)); var name = attr.ConstructorArguments[0].Value?.ToString(); var category = attr.ConstructorArguments[1].Value?.ToString(); string key = $\u0026#34;{category}_{name}\u0026#34;; builder.RegisterType(type).Named\u0026lt;ITool\u0026gt;(key); } 步骤 4：构建容器并解析服务 1 2 3 4 5 6 7 8 9 10 var container = builder.Build(); var tool1 = container.ResolveNamed\u0026lt;ITool\u0026gt;(\u0026#34;类别1_工具1\u0026#34;); tool1.DoWork(); var tool2 = container.ResolveNamed\u0026lt;ITool\u0026gt;(\u0026#34;类别1_工具2\u0026#34;); tool2.ShowDialog(); var tool3 = container.ResolveNamed\u0026lt;ITool\u0026gt;(\u0026#34;类别2_工具1\u0026#34;); tool3.ShowDialog(); 🧩 依赖自动解析能力 当被注入的类型存在其他依赖项时，如日志 (ILogger) 或数据库 (IDatabase) 接口，依赖注入容器会自动完成这些依赖的解析。\n1 2 3 4 5 6 7 8 9 10 public interface ILogger { void Log(string message); } public interface IDatabase { List\u0026lt;string\u0026gt; Select(); void Insert\u0026lt;T\u0026gt;(T entity); } 示例：单例注入 1 2 builder.RegisterType\u0026lt;ConsoleLogger\u0026gt;().SingleInstance().As\u0026lt;ILogger\u0026gt;(); builder.RegisterType\u0026lt;MysqlMocker\u0026gt;().SingleInstance().As\u0026lt;IDatabase\u0026gt;(); 使用示例类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 [Inject(\u0026#34;工具1\u0026#34;, \u0026#34;类别1\u0026#34;)] public class Tool1 : ITool { private readonly ILogger _logger; private readonly IDatabase _database; public Tool1(ILogger logger, IDatabase database) { _logger = logger; _database = database; } public void DoWork() { _logger.Log(\u0026#34;This is a log message from Tool1\u0026#34;); _logger.Log(\u0026#34;Doing work in MainFrame\u0026#34;); var data = _database.Select(); var str = JsonConvert.SerializeObject(data); _logger.Log($\u0026#34;Data from database: {str}\u0026#34;); } public void ShowDialog() { } } ✅ 总结 功能 描述 依赖注入 解耦组件，提升可维护性和可测试性 动态加载 灵活加载 DLL，支持热插拔和运行时扩展 结合使用 可以将动态加载的 DLL 类型注册为服务，并由 DI 容器管理其生命周期和依赖关系 通过上述方式，你可以实现一个高度模块化、易于扩展和维护的 C# 应用架构，适用于插件式系统、微服务架构等场景。\n","date":"2025-06-04T14:04:44+08:00","image":"https://www.notion.so/images/page-cover/met_william_morris_1877_willow.jpg","permalink":"https://dumbnessrf.github.io/p/dependency_injection_with_dynamic_loaded_dll.md/","title":"C#对动态加载的DLL依赖注入"},{"content":"🧩 Avalonia 框架概览 🔍 简介 Avalonia 是一个 跨平台的 .NET 用户界面框架，支持使用 C# 和 XAML 构建桌面、移动和 Web 应用程序。其设计灵感来源于 WPF 和 UWP，但具有更强的跨平台兼容性。\n✅ 主要特点： 使用熟悉的 XAML 语法 支持多种 UI 控件和样式 可运行于多个操作系统 支持 MVVM 模式及依赖注入 🌐 平台支持 Avalonia 支持以下平台：\n平台 支持情况 Windows 完全支持 Linux 完全支持 macOS 完全支持 Android/iOS 实验性支持（需额外适配） WebAssembly 支持（通过 WASM 渲染器） 💡 Avalonia 提供了真正的跨平台开发能力，适用于需要统一多端体验的应用场景。\n⚙️ 性能表现 Avalonia 的渲染引擎经过优化，具备高效的绘制能力和良好的硬件加速支持，尤其在处理复杂图形与数据可视化时表现出色。\n高效的渲染管道 支持 GPU 加速 低延迟响应用户交互 例如：当应用中存在大量动态图表或动画元素时，Avalonia 能保持流畅的帧率，避免卡顿现象。\n🔄 Microsoft.Extensions.DependencyInjection 详解 📦 概述 Microsoft.Extensions.DependencyInjection 是 .NET 中的一个 轻量级依赖注入（DI）容器，它提供了一种灵活的方式来管理应用程序中的对象及其依赖关系。\n💡 为什么使用 DI？ 解耦业务逻辑与具体实现 提高代码可测试性和可维护性 支持模块化开发 🕒 服务生命周期（Service Lifecycle） 生命周期类型 描述 Transient（瞬态） 每次请求都会创建新实例，适合无状态服务 Scoped（作用域） 同一作用域内共享同一个实例，常用于 Web 请求上下文 Singleton（单例） 整个应用程序周期内共享唯一实例，适合全局资源管理 示例说明： Transient：每次调用 IDataProcessor 都会返回一个新的实例。 Scoped：在一次 HTTP 请求中，所有对 IDatabaseContext 的请求都返回同一个实例。 Singleton：如 IAppSettings，在整个应用程序中始终为同一实例。 🧪 示例：在 Avalonia 中集成依赖注入 📝以下示例将添加Redis和第三方Avalonia样式库SukiUI作为参考\n1️⃣ 安装依赖注入包 1 install-package Microsoft.Extensions.DependencyInjection 2️⃣ 初始化服务容器 在 App.xaml.cs 中重写 OnFrameworkInitializationCompleted() 方法以注册并构建服务容器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public override void OnFrameworkInitializationCompleted() { var collection = new ServiceCollection(); collection.AddCommonServices(); collection.AddDistributedCache(); _services = collection.BuildServiceProvider(); var vm = _services.GetRequiredService\u0026lt;MainWindowViewModel\u0026gt;(); var toastService = _services.GetRequiredService\u0026lt;ISukiToastManager\u0026gt;(); var dialogService = _services.GetRequiredService\u0026lt;ISukiDialogManager\u0026gt;(); if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop) { desktop.MainWindow = _services.GetRequiredService\u0026lt;MainWindow\u0026gt;(); } else if (ApplicationLifetime is ISingleViewApplicationLifetime singleViewPlatform) { singleViewPlatform.MainView = new MainWindow(toastService, dialogService) { DataContext = vm, }; } base.OnFrameworkInitializationCompleted(); } 3️⃣ 注册服务 自定义扩展方法注册常用服务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static void AddCommonServices(this IServiceCollection collection) { collection.AddSingleton\u0026lt;MainWindowViewModel\u0026gt;(); collection.AddSingleton\u0026lt;MainWindow\u0026gt;(s =\u0026gt; new MainWindow( s.GetRequiredService\u0026lt;ISukiToastManager\u0026gt;(), s.GetRequiredService\u0026lt;ISukiDialogManager\u0026gt;() ) { DataContext = s.GetRequiredService\u0026lt;MainWindowViewModel\u0026gt;(), }); collection.AddSingleton\u0026lt;ISukiToastManager\u0026gt;(s =\u0026gt; DialogExManager.GetToastManager()); collection.AddSingleton\u0026lt;ISukiDialogManager\u0026gt;(s =\u0026gt; DialogExManager.GetDialogManager()); } 注册 Redis 缓存服务 1 2 3 4 5 6 7 8 9 10 11 12 public static void AddDistributedCache(this IServiceCollection collection) { var connection = ConnectionMultiplexer.Connect(\u0026#34;127.0.0.1:6379\u0026#34;); var redis = connection.GetDatabase(); collection.AddSingleton(redis); collection.AddSingleton(connection); collection.AddSingleton\u0026lt;IDistributedCache, RedisCache\u0026gt;(s =\u0026gt; { return new RedisCache(s.GetRequiredService\u0026lt;IDatabase\u0026gt;()); }); } 4️⃣ 辅助类：对话框与 Toast 管理器 1 2 3 4 5 6 7 8 public static class DialogExManager { private static readonly ISukiToastManager ToastManager = new SukiToastManager(); private static readonly ISukiDialogManager DialogManager = new SukiDialogManager(); public static ISukiToastManager GetToastManager() =\u0026gt; ToastManager; public static ISukiDialogManager GetDialogManager() =\u0026gt; DialogManager; } 5️⃣ 视图定位器（ViewLocator） 如果启用了 ViewLocator，则 ViewModel 与 View 将自动绑定。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class ViewLocator : IDataTemplate { public Control? Build(object? param) { if (param is null) return null; var name = param.GetType().FullName!.Replace(\u0026#34;ViewModel\u0026#34;, \u0026#34;View\u0026#34;, StringComparison.Ordinal); var type = Type.GetType(name); return type != null ? (Control)Activator.CreateInstance(type)! : new TextBlock { Text = \u0026#34;Not Found: \u0026#34; + name }; } public bool Match(object? data) { return data is ViewModelBase; } } 📝 如果未启用 ViewLocator，则需要手动设置 DataContext。\n✅ 总结 Avalonia 是一个强大的跨平台 UI 框架，结合 Microsoft.Extensions.DependencyInjection 可实现高度解耦和模块化的应用程序架构。通过合理配置服务生命周期和使用视图定位器等机制，可以显著提升开发效率和代码质量。\n","date":"2025-06-04T11:04:44+08:00","image":"https://images.unsplash.com/photo-1649972904349-6e44c42644a7?ixlib=rb-4.0.3\u0026q=85\u0026fm=jpg\u0026crop=entropy\u0026cs=srgb\u0026w=3600","permalink":"https://dumbnessrf.github.io/p/dependency_injection/","title":"Avalonia中使用依赖注入重构代码"},{"content":"Converter 类型详解与使用示例 目录 Normal Converter IMultiValueConverter FuncValueConverter 为了提高 Converter 的利用率，可以将其实例定义为静态资源，避免重复创建实例。例如：\n1 2 3 4 /// \u0026lt;summary\u0026gt; /// 获取 MathAddConverter 的静态实例 /// \u0026lt;/summary\u0026gt; public static MathAddConverter AddConverter { get; } = new MathAddConverter(); 在 XAML 中调用该静态资源的方式如下：\n1 2 \u0026lt;NumericUpDown Grid.Row=\u0026#34;1\u0026#34; Grid.Column=\u0026#34;1\u0026#34; Value=\u0026#34;{Binding Number1, Converter={x:Static MathAddConverter.AddConverter}, ConverterParameter={StaticResource MyConverterParameter}}\u0026#34; /\u0026gt; Normal Converter 普通值转换器（IValueConverter）：用于单个绑定值的转换，但 ConverterParameter 不支持动态绑定。\n示例：AddConverter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class AddConverter : IValueConverter { public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture) { if (value is decimal d1 \u0026amp;\u0026amp; parameter is decimal d2) { return d1 + d2; } return null; } public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture) { if (value is decimal d1 \u0026amp;\u0026amp; parameter is decimal d2) { return d1 - d2; } return null; } } XAML 资源定义 1 2 3 4 \u0026lt;Window.Resources\u0026gt; \u0026lt;conv:AddConverter x:Key=\u0026#34;AddConverter\u0026#34; /\u0026gt; \u0026lt;x:Decimal x:Key=\u0026#34;inputAddValue\u0026#34;\u0026gt;2\u0026lt;/x:Decimal\u0026gt; \u0026lt;/Window.Resources\u0026gt; 使用示例 1 2 3 4 5 6 7 8 9 10 \u0026lt;StackPanel Orientation=\u0026#34;Horizontal\u0026#34;\u0026gt; \u0026lt;TextBlock Classes=\u0026#34;Header\u0026#34; Text=\u0026#34;NormalConverter\u0026#34; /\u0026gt; \u0026lt;TextBlock Text=\u0026#34;Input a number to sum\u0026#34; /\u0026gt; \u0026lt;NumericUpDown Increment=\u0026#34;0.1\u0026#34; Value=\u0026#34;{Binding Number}\u0026#34; /\u0026gt; \u0026lt;TextBlock Text=\u0026#34;Sum\u0026#34; /\u0026gt; \u0026lt;NumericUpDown Value=\u0026#34;{Binding Number, Converter={StaticResource AddConverter}, ConverterParameter={StaticResource inputAddValue}}\u0026#34; /\u0026gt; \u0026lt;/StackPanel\u0026gt; IMultiValueConverter 多值转换器（IMultiValueConverter）：支持多个绑定值输入，ConverterParameter 支持绑定。\n示例：MultiValueAddConverter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class MultiValueAddConverter : IMultiValueConverter { public object? Convert(IList\u0026lt;object?\u0026gt; values, Type targetType, object? parameter, CultureInfo culture) { if (values.Any(s =\u0026gt; s is not decimal)) { return new BindingNotification( new InvalidOperationException( \u0026#34;Not all input parameter type is decimal, this converter only support decimal type\u0026#34; ), BindingErrorType.Error ); } return values.Sum(s =\u0026gt; (decimal)s); } } 使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;StackPanel Orientation=\u0026#34;Horizontal\u0026#34;\u0026gt; \u0026lt;TextBlock Classes=\u0026#34;Header\u0026#34; Text=\u0026#34;MultiValueConverter\u0026#34; /\u0026gt; \u0026lt;TextBlock Text=\u0026#34;Input numbers to sum\u0026#34; /\u0026gt; \u0026lt;NumericUpDown Increment=\u0026#34;0.1\u0026#34; Value=\u0026#34;{Binding Number1}\u0026#34; /\u0026gt; \u0026lt;NumericUpDown Increment=\u0026#34;0.1\u0026#34; Value=\u0026#34;{Binding Number2}\u0026#34; /\u0026gt; \u0026lt;NumericUpDown Increment=\u0026#34;0.1\u0026#34; Value=\u0026#34;{Binding Number3}\u0026#34; /\u0026gt; \u0026lt;TextBlock Text=\u0026#34;Sum\u0026#34; /\u0026gt; \u0026lt;NumericUpDown IsReadOnly=\u0026#34;True\u0026#34;\u0026gt; \u0026lt;NumericUpDown.Value\u0026gt; \u0026lt;MultiBinding Converter=\u0026#34;{StaticResource MultiValueAddConverter}\u0026#34; Mode=\u0026#34;OneWay\u0026#34;\u0026gt; \u0026lt;Binding Path=\u0026#34;Number1\u0026#34; /\u0026gt; \u0026lt;Binding Path=\u0026#34;Number2\u0026#34; /\u0026gt; \u0026lt;Binding Path=\u0026#34;Number3\u0026#34; /\u0026gt; \u0026lt;/MultiBinding\u0026gt; \u0026lt;/NumericUpDown.Value\u0026gt; \u0026lt;/NumericUpDown\u0026gt; \u0026lt;/StackPanel\u0026gt; FuncValueConverter 函数式转换器（FuncValueConverter）：通过委托方式定义转换逻辑，适用于类型明确、逻辑简单的场景。\n示例：字符串转画刷 1 2 3 4 5 6 7 8 9 10 11 12 13 public class FuncValueConverters { public static FuncValueConverter\u0026lt;string?, Brush?\u0026gt; StringToBrushFuncConverter { get; } = new(s =\u0026gt; { Color color; if (Color.TryParse(s, out color) || Color.TryParse($\u0026#34;#{s}\u0026#34;, out color)) { return new SolidColorBrush(color); } return null; }); } 使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;StackPanel Orientation=\u0026#34;Horizontal\u0026#34;\u0026gt; \u0026lt;TextBlock Classes=\u0026#34;Header\u0026#34; Text=\u0026#34;FuncValueConverter\u0026#34; /\u0026gt; \u0026lt;TextBox Text=\u0026#34;red\u0026#34; UseFloatingWatermark=\u0026#34;True\u0026#34; Watermark=\u0026#34;Type the color to parse (e.g.: red, green, blue, #FF112233)\u0026#34;\u0026gt; \u0026lt;TextBox.InnerLeftContent\u0026gt; \u0026lt;Ellipse Fill=\u0026#34;{Binding $parent[TextBox].Text, Converter={x:Static conv:FuncValueConverters.StringToBrushFuncConverter}}\u0026#34; Height=\u0026#34;20\u0026#34; Margin=\u0026#34;5,0,0,0\u0026#34; Stroke=\u0026#34;Gray\u0026#34; StrokeThickness=\u0026#34;1\u0026#34; Width=\u0026#34;20\u0026#34; /\u0026gt; \u0026lt;/TextBox.InnerLeftContent\u0026gt; \u0026lt;/TextBox\u0026gt; \u0026lt;/StackPanel\u0026gt; 如需扩展更多转换逻辑，可以继续添加新的 Converter 或使用 FuncValueConverter 快速实现轻量级转换逻辑。\n","date":"2025-06-04T11:04:44+08:00","image":"https://www.notion.so/images/page-cover/rijksmuseum_jansz_1637.jpg","permalink":"https://dumbnessrf.github.io/p/converter-in-avalonia/","title":"Avalonia中的各种Converter使用"},{"content":"WPF 中的 DataTemplateSelector：高级数据模板选择技巧与应用 在 WPF（Windows Presentation Foundation）开发中，DataTemplate 是我们用来定义如何显示绑定数据的重要工具。然而，有时候我们需要根据不同的数据对象动态地选择不同的 DataTemplate 来呈现 UI。这时，DataTemplateSelector 就派上用场了。\n本文将介绍：\n什么是 DataTemplateSelector 如何自定义一个 DataTemplateSelector 实际应用场景和代码示例 使用技巧与最佳实践 一、什么是 DataTemplateSelector？ DataTemplateSelector 是一个抽象类，它允许你根据绑定项的内容来决定使用哪个 DataTemplate。你可以继承这个类并重写它的 SelectTemplate 方法，从而实现自定义的模板选择逻辑。\n二、如何自定义一个 DataTemplateSelector？ 我们先来看一个简单的例子。\n示例场景：聊天消息列表 假设我们有一个聊天程序，每条消息可能是用户发送的，也可能是系统自动发送的。我们想对这两种消息应用不同的样式。\n1. 定义数据模型 1 2 3 4 5 6 7 8 9 10 11 public class Message { public string Content { get; set; } public MessageType Type { get; set; } } public enum MessageType { User, System } 2. 创建两个不同的 DataTemplate 在 XAML 中定义两种不同风格的消息模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;Window.Resources\u0026gt; \u0026lt;!-- 用户消息模板 --\u0026gt; \u0026lt;DataTemplate x:Key=\u0026#34;UserMessageTemplate\u0026#34;\u0026gt; \u0026lt;Border Background=\u0026#34;LightBlue\u0026#34; Padding=\u0026#34;10\u0026#34; Margin=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding Content}\u0026#34; /\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;!-- 系统消息模板 --\u0026gt; \u0026lt;DataTemplate x:Key=\u0026#34;SystemMessageTemplate\u0026#34;\u0026gt; \u0026lt;Border Background=\u0026#34;LightGray\u0026#34; Padding=\u0026#34;10\u0026#34; Margin=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding Content}\u0026#34; FontStyle=\u0026#34;Italic\u0026#34;/\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/Window.Resources\u0026gt; 3. 自定义 DataTemplateSelector 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class MessageTemplateSelector : DataTemplateSelector { public DataTemplate UserMessageTemplate { get; set; } public DataTemplate SystemMessageTemplate { get; set; } public override DataTemplate SelectTemplate(object item, DependencyObject container) { if (item is Message message) { switch (message.Type) { case MessageType.User: return UserMessageTemplate; case MessageType.System: return SystemMessageTemplate; } } return base.SelectTemplate(item, container); } } 4. 在 XAML 中注册并使用 TemplateSelector 1 2 3 4 5 6 7 8 \u0026lt;Window.Resources\u0026gt; \u0026lt;local:MessageTemplateSelector x:Key=\u0026#34;messageTemplateSelector\u0026#34; UserMessageTemplate=\u0026#34;{StaticResource UserMessageTemplate}\u0026#34; SystemMessageTemplate=\u0026#34;{StaticResource SystemMessageTemplate}\u0026#34; /\u0026gt; \u0026lt;/Window.Resources\u0026gt; \u0026lt;ListBox ItemsSource=\u0026#34;{Binding Messages}\u0026#34; ItemTemplateSelector=\u0026#34;{StaticResource messageTemplateSelector}\u0026#34; /\u0026gt; 注意：local 需要引用你的命名空间，例如：\n1 2 \u0026lt;Window xmlns:local=\u0026#34;clr-namespace:YourNamespace\u0026#34; ... 三、应用场景举例 场景 1：多类型列表展示（如新闻、通知、订单等混合展示） 你可以为不同类型的数据项选择不同的模板，使得同一个列表中能展示多种结构不同的信息。\n场景 2：UI 主题或状态变化 根据对象的状态（如“已读”、“未读”、“错误”等）切换不同的 UI 样式。\n场景 3：个性化内容展示 比如在一个论坛应用中，帖子作者、管理员、普通用户的发言需要不同颜色或图标标识。\n四、使用技巧与最佳实践 ✅ 技巧 1：保持 TemplateSelector 的可复用性 目标： 设计一个通用的 DataTemplateSelector，可以通过依赖属性传入模板，提高组件复用性。\n实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class ReusableTemplateSelector : DataTemplateSelector { public DataTemplate DefaultTemplate { get; set; } public DataTemplate AlternateTemplate { get; set; } public override DataTemplate SelectTemplate(object item, DependencyObject container) { if (item is ICustomType customItem \u0026amp;\u0026amp; customItem.IsSpecial) { return AlternateTemplate; } return DefaultTemplate ?? base.SelectTemplate(item, container); } } // 接口用于判断是否是“特殊类型” public interface ICustomType { bool IsSpecial { get; } } 使用 XAML： 1 2 3 \u0026lt;local:ReusableTemplateSelector x:Key=\u0026#34;reusableSelector\u0026#34; DefaultTemplate=\u0026#34;{StaticResource NormalTemplate}\u0026#34; AlternateTemplate=\u0026#34;{StaticResource SpecialTemplate}\u0026#34; /\u0026gt; 应用场景： 多个页面中重复使用同一个选择器。 不同业务逻辑下只需更换绑定的 DataTemplate。 ✅ 技巧 2：结合 MVVM 模式使用 目标： 在 MVVM 架构中使用 DataTemplateSelector，将 UI 展示与数据分离。\n实现： ViewModel 示例： 1 2 3 4 5 6 7 8 9 10 11 public class MessageViewModel : INotifyPropertyChanged { public string Content { get; set; } public MessageType Type { get; set; } // User / System } public enum MessageType { User, System } 自定义 Selector： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class MessageTypeSelector : DataTemplateSelector { public DataTemplate UserTemplate { get; set; } public DataTemplate SystemTemplate { get; set; } public override DataTemplate SelectTemplate(object item, DependencyObject container) { if (item is MessageViewModel msg) { return msg.Type == MessageType.User ? UserTemplate : SystemTemplate; } return base.SelectTemplate(item, container); } } XAML 中绑定： 1 2 \u0026lt;ListBox ItemsSource=\u0026#34;{Binding Messages}\u0026#34; ItemTemplateSelector=\u0026#34;{StaticResource messageTypeSelector}\u0026#34; /\u0026gt; 优势： 完全解耦 View 和 ViewModel。 易于维护和测试。 ✅ 技巧 3：避免过度复杂的逻辑 目标： 确保 SelectTemplate 方法逻辑简洁，不嵌套复杂判断。\n反面例子（不推荐）： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public override DataTemplate SelectTemplate(...) { if (item is Order o) { if (o.Status == \u0026#34;Pending\u0026#34;) { if (o.CustomerLevel == \u0026#34;VIP\u0026#34;) return VipPendingTemplate; else return PendingTemplate; } else if (o.Status == \u0026#34;Completed\u0026#34;) { ... } } } 改进方式： 使用策略模式或状态枚举映射 1 2 3 4 5 6 7 8 9 10 11 12 13 public class OrderTemplateSelector : DataTemplateSelector { public Dictionary\u0026lt;OrderState, DataTemplate\u0026gt; Templates { get; } = new(); public override DataTemplate SelectTemplate(object item, DependencyObject container) { if (item is Order order) { return Templates.GetValueOrDefault(order.State); } return base.SelectTemplate(item, container); } } XAML 配置： 1 2 3 4 5 6 \u0026lt;local:OrderTemplateSelector x:Key=\u0026#34;orderSelector\u0026#34;\u0026gt; \u0026lt;local:OrderTemplateSelector.Templates\u0026gt; \u0026lt;Component:TemplateMapEntry Key=\u0026#34;Pending\u0026#34; Value=\u0026#34;{StaticResource PendingTemplate}\u0026#34; /\u0026gt; \u0026lt;Component:TemplateMapEntry Key=\u0026#34;Completed\u0026#34; Value=\u0026#34;{StaticResource CompletedTemplate}\u0026#34; /\u0026gt; \u0026lt;/local:OrderTemplateSelector.Templates\u0026gt; \u0026lt;/local:OrderTemplateSelector\u0026gt; 💡 注：你可以自定义 TemplateMapEntry 类型来支持这种字典结构。\n✅ 技巧 4：调试时注意 Binding 上下文问题 常见错误： 在 SelectTemplate 中获取不到正确对象。 绑定路径错误导致无法识别类型。 解决方法： 确保绑定上下文正确 1 2 \u0026lt;ListBox ItemsSource=\u0026#34;{Binding MyItems}\u0026#34; ItemTemplateSelector=\u0026#34;{StaticResource mySelector}\u0026#34; /\u0026gt; 确保 MyItems 是 IEnumerable\u0026lt;T\u0026gt;，且每一项类型都能被识别。\n添加日志辅助调试： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public override DataTemplate SelectTemplate(object item, DependencyObject container) { if (item == null) { Debug.WriteLine(\u0026#34;Item is null\u0026#34;); return base.SelectTemplate(item, container); } Debug.WriteLine($\u0026#34;Item type: {item.GetType().Name}\u0026#34;); if (item is CustomType ct) { return ct.IsSpecial ? SpecialTemplate : NormalTemplate; } return base.SelectTemplate(item, container); } 五、总结 DataTemplateSelector 是 WPF 中非常强大且灵活的功能，它帮助我们实现了数据驱动的 UI 模板选择。无论是构建复杂的 UI 列表还是实现高度定制化的展示逻辑，DataTemplateSelector 都是一个值得掌握的技能。\n","date":"2025-05-30T14:46:48+08:00","image":"https://www.notion.so/images/page-cover/nasa_new_york_city_grid.jpg","permalink":"https://dumbnessrf.github.io/p/data-template-selector-tips/","title":"WPF技巧-数据模板动态选择"},{"content":"解锁.NET 新姿势：基于文件的程序特性深度解析与实战 在.NET 的世界里，新项目的创建和运行往往离不开.csproj项目文件，从编写代码到调试运行，需要一系列繁琐的步骤。但随着.NET 技术的不断演进，基于文件的程序（File-based programs） 这一新特性的出现，打破了这一传统模式，为开发者带来了更加便捷、高效的开发体验。\n基于文件的程序特性概述 基于文件的程序，简单来说，就是将部分 MSBuild 项目功能嵌入到 C# 代码中，允许开发者直接运行单个 C# 文件，就像运行一个完整的项目一样。在以往，运行 C# 代码通常需要先创建一个项目，编写 .csproj 文件来配置项目的各种属性，如引用的包、目标框架等。而基于文件的程序则无需这些复杂的操作，它通过在 C# 源文件中添加特殊的 #: 指令，在内存中生成一个 “虚拟项目”，然后将这个 “虚拟项目” 传递给 MSBuild 进行构建和运行。\n其背后的运行机制是：当使用 dotnet run 命令运行一个 C# 文件时，命令行会解析源文件中的 #: 指令，根据这些指令在内存中构建一个 C# 项目 XML 文档，这个文档就相当于一个常规项目的 .csproj 文件。随后，MSBuild 会基于这个内存中的项目文档进行编译和运行，使得单个文件能够像完整项目一样执行 。\n应用示例详解 示例 1：经典 Hello World 1 2 3 // HelloWorld.cs #:r \u0026#34;System.Net.Http\u0026#34; Console.WriteLine(\u0026#34;Hello, World!\u0026#34;); 在这个简单示例中，#:r \u0026quot;System.Net.Http\u0026quot; 是一个 #: 指令，它用于引用 System.Net.Http 程序集。虽然代码中没有传统的项目文件配置，但通过这条指令，我们为程序添加了所需的引用。在命令行中进入该文件所在目录，执行 dotnet run HelloWorld.cs，就能看到熟悉的 “Hello, World!” 输出。这展示了基于文件的程序最基础的运行方式，仅需一个 C# 文件和简单指令，即可快速运行代码。\n示例 2：引用外部 NuGet 包 1 2 3 4 5 6 7 8 9 10 11 12 13 // NewtonsoftJsonExample.cs #:package Newtonsoft.Json 13.0.1 using Newtonsoft.Json; class Program { static void Main() { var person = new { Name = \u0026#34;Alice\u0026#34;, Age = 30 }; var json = JsonConvert.SerializeObject(person); Console.WriteLine(json); } } 在这个示例中，#:package Newtonsoft.Json 13.0.1 指令用于引入 Newtonsoft.Json 包及其指定版本。引入后，代码中就能使用 Newtonsoft.Json 提供的功能，如将对象序列化为 JSON 字符串。运行时，dotnet run 命令会根据该指令自动下载并引用所需的 NuGet 包，无需手动在项目文件中添加包引用，极大地简化了使用外部包的流程 。\n示例 3：多文件协作 假设我们有一个简单的数学计算项目，包含两个文件：Calculator.cs 和 Program.cs。\nCalculator.cs 文件内容如下：\n1 2 3 4 5 6 7 8 9 10 11 // Calculator.cs namespace MathUtils { public static class Calculator { public static int Add(int a, int b) { return a + b; } } } Program.cs 文件内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 // Program.cs #:r \u0026#34;System.Net.Http\u0026#34; using MathUtils; class Program { static void Main() { int result = Calculator.Add(5, 3); Console.WriteLine($\u0026#34;The result of addition is: {result}\u0026#34;); } } 在基于文件的程序中，无需手动在项目文件中配置文件引用关系。当使用 dotnet run Program.cs 命令运行时，SDK CLI 会自动解析 Program.cs 所在目录树中的所有 .cs 文件，将 Calculator.cs 包含在编译过程中，使得不同文件之间能够顺利协作，实现复杂的功能 。\n与传统项目模式的对比优势 降低入门门槛\n对于初学者来说，传统的 .csproj 项目文件配置复杂，包含众多属性和节点，容易让新手感到困惑。而基于文件的程序模式，只需关注代码本身和简单的 #: 指令，无需深入了解项目文件配置，能够更快地编写和运行代码，降低了学习成本。\n快速原型开发\n在开发初期进行原型设计时，往往需要快速验证想法和功能。基于文件的程序无需创建完整项目结构，直接编写单个文件并运行，能够大大提高开发效率，快速迭代原型。\n简化小型工具开发\n对于一些简单的小型工具或脚本，使用传统项目模式显得过于繁琐。基于文件的程序可以用最少的配置和步骤实现功能，使代码更加简洁、轻便，便于维护和管理。\n使用注意事项 虽然基于文件的程序带来了诸多便利，但在使用过程中也有一些需要注意的地方：\n目前基于文件的程序在功能上还存在一定限制，例如对某些复杂的项目配置和构建自定义支持不够完善。 由于其依赖于 #: 指令来配置项目属性，指令的语法和使用规则需要开发者熟练掌握，否则可能会出现引用错误或构建失败等问题。 在团队协作开发中，基于文件的程序可能会因为成员使用不同版本的 .NET SDK 而导致运行结果不一致，需要统一开发环境。 以上就是对 .NET 基于文件的程序特性的详细介绍和应用示例。这一特性为开发者提供了更灵活高效的开发方式，无论是初学者快速上手，还是经验丰富的开发者进行快速开发，都能发挥重要作用。不妨亲自尝试，感受它带来的便捷！如果你在使用过程中有新的发现或遇到问题，欢迎一起交流探讨。\n","date":"2025-05-29T11:04:44+08:00","image":"https://www.notion.so/images/page-cover/rijksmuseum_mignons_1660.jpg","permalink":"https://dumbnessrf.github.io/p/single-file-run/","title":"单文件运行C#代码"}]